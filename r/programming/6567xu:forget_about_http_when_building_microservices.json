[{"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t3", "data": {"contest_mode": false, "banned_by": null, "media_embed": {}, "subreddit": "programming", "selftext_html": null, "selftext": "", "likes": null, "suggested_sort": null, "user_reports": [], "secure_media": null, "link_flair_text": null, "id": "6567xu", "gilded": 0, "secure_media_embed": {}, "clicked": false, "score": 21, "report_reasons": null, "author": "bergie", "saved": false, "mod_reports": [], "name": "t3_6567xu", "subreddit_name_prefixed": "r/programming", "approved_by": null, "over_18": false, "domain": "bergie.iki.fi", "hidden": false, "thumbnail": "", "subreddit_id": "t5_2fwo", "edited": false, "link_flair_css_class": null, "author_flair_css_class": null, "downs": 0, "brand_safe": true, "archived": false, "removal_reason": null, "is_self": false, "hide_score": false, "spoiler": false, "permalink": "/r/programming/comments/6567xu/forget_about_http_when_building_microservices/", "num_reports": null, "locked": false, "stickied": false, "created": 1492126594.0, "url": "http://bergie.iki.fi/blog/forget-http-microservices/", "author_flair_text": null, "quarantine": false, "title": "Forget about HTTP when building microservices", "created_utc": 1492097794.0, "distinguished": null, "media": null, "upvote_ratio": 0.69, "num_comments": 56, "visited": false, "subreddit_type": "public", "ups": 21}}], "after": null, "before": null}}, {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": "", "user_reports": [], "id": "dg8cvk5", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "nope_42", "parent_id": "t1_dg87tx5", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "You are correct. The easiest solution is only allowing one submission at a time from the UI for the user.  Alternatively with http you get responses so you know your data is fully written to the backend and can return the current state.  This at least allows the user to have a consistent view of the data.\n\nI think messaging systems like Kafka are probably the future for this sort of thing since they solve the ordering issues in an elegant way.\n", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;You are correct. The easiest solution is only allowing one submission at a time from the UI for the user.  Alternatively with http you get responses so you know your data is fully written to the backend and can return the current state.  This at least allows the user to have a consistent view of the data.&lt;/p&gt;\n\n&lt;p&gt;I think messaging systems like Kafka are probably the future for this sort of thing since they solve the ordering issues in an elegant way.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg8cvk5", "score_hidden": false, "stickied": false, "created": 1492152326.0, "created_utc": 1492123526.0, "depth": 4, "mod_reports": [], "subreddit_type": "public", "ups": 2}}], "after": null, "before": null}}, "user_reports": [], "id": "dg87tx5", "gilded": 0, "archived": false, "score": 4, "report_reasons": null, "author": "skratlo", "parent_id": "t1_dg875hu", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "Good point, but correct me if I'm wrong: how does http ensure ordering? Say you have a cluster of address updating http micro services and a load balancer. Where is the ordering enforced? ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Good point, but correct me if I&amp;#39;m wrong: how does http ensure ordering? Say you have a cluster of address updating http micro services and a load balancer. Where is the ordering enforced? &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg87tx5", "score_hidden": false, "stickied": false, "created": 1492145972.0, "created_utc": 1492117172.0, "depth": 3, "mod_reports": [], "subreddit_type": "public", "ups": 4}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": "", "user_reports": [], "id": "dgb5bj3", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "nope_42", "parent_id": "t1_dga9iju", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "It really will depend upon the specifics of the message.  If the message only contains what fields were updated and not the entire address model then this solution would mean we've potentially lost data since the second message may be updating additional fields.\n\nAlso consider that multiple systems could be sending the address update message.  In this scenario we have to consider both clock synchronization and if we are sending the entirety of the model then we have even more potential for lost data in messages.\n\nThis is why you want to have a single source of truth for updates if you can and preferably that single source is deterministic in its ordering so your systems are easier to reason about.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;It really will depend upon the specifics of the message.  If the message only contains what fields were updated and not the entire address model then this solution would mean we&amp;#39;ve potentially lost data since the second message may be updating additional fields.&lt;/p&gt;\n\n&lt;p&gt;Also consider that multiple systems could be sending the address update message.  In this scenario we have to consider both clock synchronization and if we are sending the entirety of the model then we have even more potential for lost data in messages.&lt;/p&gt;\n\n&lt;p&gt;This is why you want to have a single source of truth for updates if you can and preferably that single source is deterministic in its ordering so your systems are easier to reason about.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dgb5bj3", "score_hidden": false, "stickied": false, "created": 1492317769.0, "created_utc": 1492288969.0, "depth": 4, "mod_reports": [], "subreddit_type": "public", "ups": 2}}], "after": null, "before": null}}, "user_reports": [], "id": "dga9iju", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "throwawayayayay33333", "parent_id": "t1_dg875hu", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "What about just attaching a timestamp to messages as they're generated, and only apply changes that have a timestamp greater than the one for the current state (and update the timestamp on the record)?\n\nIf the first record arrives after the second (more recent) message it will just not be applied due to failing the timestamp check.\n\nObviously you take a bit of a hit on performance doing the timestamp comparisons, but apart from that it seems like it would solve it? ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;What about just attaching a timestamp to messages as they&amp;#39;re generated, and only apply changes that have a timestamp greater than the one for the current state (and update the timestamp on the record)?&lt;/p&gt;\n\n&lt;p&gt;If the first record arrives after the second (more recent) message it will just not be applied due to failing the timestamp check.&lt;/p&gt;\n\n&lt;p&gt;Obviously you take a bit of a hit on performance doing the timestamp comparisons, but apart from that it seems like it would solve it? &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dga9iju", "score_hidden": false, "stickied": false, "created": 1492258228.0, "created_utc": 1492229428.0, "depth": 3, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg875hu", "gilded": 0, "archived": false, "score": 5, "report_reasons": null, "author": "nope_42", "parent_id": "t1_dg868ex", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "Can I prove that they absolutely need ordering?  No, but I think I can show that things are much easier and less error prone with guaranteed ordering.\n\nTake a simple Address update command.  If a customer updates their address record twice in a row you have two messages in flight which can be swapped in order.  If the first record is applied after the second you now have invalid data.  You can alleviate this some by marking which actual fields changed and applying only those changes, but fields can conflict also; so you can still end up with bad data.\n\nYou can also make the message wholly idempotent.. if your update was a simple boolean toggle then you could send a Toggle message instead.  I'm not sure how you would make an Address update truly idempotent though.\n\nIf you have a guarantee on message ordering then all of this complexity goes away and you can just treat the message queue as your single point of truth for writes.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Can I prove that they absolutely need ordering?  No, but I think I can show that things are much easier and less error prone with guaranteed ordering.&lt;/p&gt;\n\n&lt;p&gt;Take a simple Address update command.  If a customer updates their address record twice in a row you have two messages in flight which can be swapped in order.  If the first record is applied after the second you now have invalid data.  You can alleviate this some by marking which actual fields changed and applying only those changes, but fields can conflict also; so you can still end up with bad data.&lt;/p&gt;\n\n&lt;p&gt;You can also make the message wholly idempotent.. if your update was a simple boolean toggle then you could send a Toggle message instead.  I&amp;#39;m not sure how you would make an Address update truly idempotent though.&lt;/p&gt;\n\n&lt;p&gt;If you have a guarantee on message ordering then all of this complexity goes away and you can just treat the message queue as your single point of truth for writes.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg875hu", "score_hidden": false, "stickied": false, "created": 1492145204.0, "created_utc": 1492116404.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 5}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": "", "user_reports": [], "id": "dga0z6u", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "dccorona", "parent_id": "t1_dg868ex", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "&gt; I think is taken care of by use of acknowledgements\n\nNot really. Acknowledgements help, but they don't get rid of the possibility of duplicate deliveries. For one, services like SQS don't guarantee that a single message won't be outright sent twice (as two literally distinct messages). I think that at this point its for all intents and purposes a soft guarantee...I've never seen it happen nor heard about it happening, but it's very possible for it to have happened when I wasn't looking. \n\nEven if we assume a system which guarantees never to do duplicate deliveries, acknowledgements don't give you exactly once processing guarantees. If you use positive acknowledgements (i.e. delete the message from the queue when done), then there's a chance a healthy processor takes too long to acknowledge the message and it is unhidden, or fails to acknowledge it, or the queue is being polled so fast that it's not able to hide the message in time to avoid delivering it twice. So basically, you get at best at-least-once semantics. The flip side (negative acknowledgements) gives you the opposite (at-most-once) for basically the exact same reasons, just reversed. \n\nThe only way I know of to get exactly-once delivery semantics (and that relies on the queue consumer itself being written in such a way to guarantee them in the face of failover as well) is a random-access message log (Kafka, Kinesis, etc) where single partitions are read strictly in order by a single processor host, which checkpoints its progress into durable storage of some kind along the way.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;blockquote&gt;\n&lt;p&gt;I think is taken care of by use of acknowledgements&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Not really. Acknowledgements help, but they don&amp;#39;t get rid of the possibility of duplicate deliveries. For one, services like SQS don&amp;#39;t guarantee that a single message won&amp;#39;t be outright sent twice (as two literally distinct messages). I think that at this point its for all intents and purposes a soft guarantee...I&amp;#39;ve never seen it happen nor heard about it happening, but it&amp;#39;s very possible for it to have happened when I wasn&amp;#39;t looking. &lt;/p&gt;\n\n&lt;p&gt;Even if we assume a system which guarantees never to do duplicate deliveries, acknowledgements don&amp;#39;t give you exactly once processing guarantees. If you use positive acknowledgements (i.e. delete the message from the queue when done), then there&amp;#39;s a chance a healthy processor takes too long to acknowledge the message and it is unhidden, or fails to acknowledge it, or the queue is being polled so fast that it&amp;#39;s not able to hide the message in time to avoid delivering it twice. So basically, you get at best at-least-once semantics. The flip side (negative acknowledgements) gives you the opposite (at-most-once) for basically the exact same reasons, just reversed. &lt;/p&gt;\n\n&lt;p&gt;The only way I know of to get exactly-once delivery semantics (and that relies on the queue consumer itself being written in such a way to guarantee them in the face of failover as well) is a random-access message log (Kafka, Kinesis, etc) where single partitions are read strictly in order by a single processor host, which checkpoints its progress into durable storage of some kind along the way.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dga0z6u", "score_hidden": false, "stickied": false, "created": 1492245744.0, "created_utc": 1492216944.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg868ex", "gilded": 0, "archived": false, "score": 6, "report_reasons": null, "author": "skratlo", "parent_id": "t1_dg7yr8j", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "&gt; Most queues only guarantee at least once delivery so you may process the same message multiple times\n\nI think is taken care of by use of acknowledgements\n\n&gt; something you have to think heavily\n\nCan you prove that most use cases for MQ need ordering? In my experience they don't. I use them to distribute work, and IMO most use cases relate to work distribution and data collection / aggregation. Most MQ consumers are more or less stateless processes.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;blockquote&gt;\n&lt;p&gt;Most queues only guarantee at least once delivery so you may process the same message multiple times&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;I think is taken care of by use of acknowledgements&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;something you have to think heavily&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Can you prove that most use cases for MQ need ordering? In my experience they don&amp;#39;t. I use them to distribute work, and IMO most use cases relate to work distribution and data collection / aggregation. Most MQ consumers are more or less stateless processes.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg868ex", "score_hidden": false, "stickied": false, "created": 1492144158.0, "created_utc": 1492115358.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 6}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": "", "user_reports": [], "id": "dg81co6", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "hqv1", "parent_id": "t1_dg7yr8j", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "I agree that message idempotency is extremely important and has to be designed upfront. And aside from Kafka, Amazon Kinesis looks really good.\n", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I agree that message idempotency is extremely important and has to be designed upfront. And aside from Kafka, Amazon Kinesis looks really good.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg81co6", "score_hidden": false, "stickied": false, "created": 1492138819.0, "created_utc": 1492110019.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 3}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": "", "user_reports": [], "id": "dg8oi2o", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "w2qw", "parent_id": "t1_dg7yr8j", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "None of those things are different with http", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;None of those things are different with http&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg8oi2o", "score_hidden": false, "stickied": false, "created": 1492168414.0, "created_utc": 1492139614.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 3}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": "", "user_reports": [], "id": "dga14xs", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "dccorona", "parent_id": "t1_dg8p9qx", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "The AWS equivalent of Kafka is Kinesis, and it's very much in a (post) 1.0 state. I've found it to be very robust, and it has a great featureset, despite being a little hard to work with at times (recent API improvements have made that better, and between the KCL and Apache Flink, there's generally a library/platform out there to make it easy enough to use for most use cases). It's a little slower than SQS, but its stronger guarantees coupled with its significantly lower costs make it a great option for a lot more use cases than I think you'd expect...it works well even if your throughput is (moderately) low. ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;The AWS equivalent of Kafka is Kinesis, and it&amp;#39;s very much in a (post) 1.0 state. I&amp;#39;ve found it to be very robust, and it has a great featureset, despite being a little hard to work with at times (recent API improvements have made that better, and between the KCL and Apache Flink, there&amp;#39;s generally a library/platform out there to make it easy enough to use for most use cases). It&amp;#39;s a little slower than SQS, but its stronger guarantees coupled with its significantly lower costs make it a great option for a lot more use cases than I think you&amp;#39;d expect...it works well even if your throughput is (moderately) low. &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dga14xs", "score_hidden": false, "stickied": false, "created": 1492245957.0, "created_utc": 1492217157.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg8p9qx", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "TomCallahanJr", "parent_id": "t1_dg7yr8j", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "Rabbit works really well and is stable. Kafka is nice too but it's not even in a 1.0 state yet and it's usefulness comes in streaming the messages when you have a shit-ton of messages to flow through the queue.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Rabbit works really well and is stable. Kafka is nice too but it&amp;#39;s not even in a 1.0 state yet and it&amp;#39;s usefulness comes in streaming the messages when you have a shit-ton of messages to flow through the queue.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg8p9qx", "score_hidden": false, "stickied": false, "created": 1492169602.0, "created_utc": 1492140802.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 2}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": "", "user_reports": [], "id": "dgc06ol", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "dccorona", "parent_id": "t1_dgbw6bu", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "&gt; If you have competing consumers, whatever the technology, you will make a choice between a message being endlessly delivered to a dead consumer, or a message potentially delivered to more than one consumer\n\nThat is true, but you can eliminate this issue with a shared queue (Kafka/Kinesis). Maybe I missed it, but I didn't think RabbitMQ had native support for such a setup, and so without a lot of extra work, it doesn't effectively achieve exactly-once delivery semantics without huge compromises. A single consumer isn't a workable restriction for a large number of setups. It puts a hard upper limit on your scaling potential, and limits availability significantly without a lot of extra work that you don't want to have to do. ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;blockquote&gt;\n&lt;p&gt;If you have competing consumers, whatever the technology, you will make a choice between a message being endlessly delivered to a dead consumer, or a message potentially delivered to more than one consumer&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;That is true, but you can eliminate this issue with a shared queue (Kafka/Kinesis). Maybe I missed it, but I didn&amp;#39;t think RabbitMQ had native support for such a setup, and so without a lot of extra work, it doesn&amp;#39;t effectively achieve exactly-once delivery semantics without huge compromises. A single consumer isn&amp;#39;t a workable restriction for a large number of setups. It puts a hard upper limit on your scaling potential, and limits availability significantly without a lot of extra work that you don&amp;#39;t want to have to do. &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dgc06ol", "score_hidden": false, "stickied": false, "created": 1492376755.0, "created_utc": 1492347955.0, "depth": 4, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dgbw6bu", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "codebje", "parent_id": "t1_dga1aqb", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "&gt; How does RabbitMQ achieve exactly-once delivery semantics?\n\nThe same way every unreliable message service does: sliding window sequence numbers and acknowledgements.  Acks give you at-least-once, sequence numbers give you at-most-once, the two together give you exactly-once.\n\nIf you have competing consumers, whatever the technology, you will make a choice between a message being endlessly delivered to a dead consumer, or a message potentially delivered to more than one consumer.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;blockquote&gt;\n&lt;p&gt;How does RabbitMQ achieve exactly-once delivery semantics?&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;The same way every unreliable message service does: sliding window sequence numbers and acknowledgements.  Acks give you at-least-once, sequence numbers give you at-most-once, the two together give you exactly-once.&lt;/p&gt;\n\n&lt;p&gt;If you have competing consumers, whatever the technology, you will make a choice between a message being endlessly delivered to a dead consumer, or a message potentially delivered to more than one consumer.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dgbw6bu", "score_hidden": false, "stickied": false, "created": 1492365271.0, "created_utc": 1492336471.0, "depth": 3, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dga1aqb", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "dccorona", "parent_id": "t1_dg8syt0", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "How does RabbitMQ achieve exactly-once delivery semantics? I didn't think it offered that guarantee. As far as I know, it's similar to SQS, and that definitely doesn't enable such a guarantee, and even Apache Flink, a platform that prides itself on enabling exactly-once processing semantics, is only able to offer that with RabbitMQ [when there is only a single queue consumer](https://ci.apache.org/projects/flink/flink-docs-release-1.2/dev/connectors/rabbitmq.html).", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;How does RabbitMQ achieve exactly-once delivery semantics? I didn&amp;#39;t think it offered that guarantee. As far as I know, it&amp;#39;s similar to SQS, and that definitely doesn&amp;#39;t enable such a guarantee, and even Apache Flink, a platform that prides itself on enabling exactly-once processing semantics, is only able to offer that with RabbitMQ &lt;a href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.2/dev/connectors/rabbitmq.html\"&gt;when there is only a single queue consumer&lt;/a&gt;.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dga1aqb", "score_hidden": false, "stickied": false, "created": 1492246181.0, "created_utc": 1492217381.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg8syt0", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "codebje", "parent_id": "t1_dg7yr8j", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "&gt; \u2026 making messages idempotent \u2026\n\nI hear sliding window sequence numbers are good this time of year.\n\nSeriously, as an industry we have half a century's experience in turning unreliable message streams into reliable ones.\n\n&gt; At least we have new alternatives like Kafka and Event hubs to fix the ordered messaging issue.\n\nWe have stable, mature alternatives both free (RabbitMQ) and with enterprise support (IBM MQ).  These solutions have given us ordered, exactly-once delivery semantics for about a decade.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;blockquote&gt;\n&lt;p&gt;\u2026 making messages idempotent \u2026&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;I hear sliding window sequence numbers are good this time of year.&lt;/p&gt;\n\n&lt;p&gt;Seriously, as an industry we have half a century&amp;#39;s experience in turning unreliable message streams into reliable ones.&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;At least we have new alternatives like Kafka and Event hubs to fix the ordered messaging issue.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;We have stable, mature alternatives both free (RabbitMQ) and with enterprise support (IBM MQ).  These solutions have given us ordered, exactly-once delivery semantics for about a decade.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg8syt0", "score_hidden": false, "stickied": false, "created": 1492176016.0, "created_utc": 1492147216.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 2}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": "", "user_reports": [], "id": "dgb4y6r", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "nope_42", "parent_id": "t1_dg99oo1", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "With the address example I was just considering that the user had a typo or something in the first update and was correcting it with the second.   There are lots of ways to solve these issues but the gist is it's easier to just use a messaging platform that gives you a guaranteed message order.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;With the address example I was just considering that the user had a typo or something in the first update and was correcting it with the second.   There are lots of ways to solve these issues but the gist is it&amp;#39;s easier to just use a messaging platform that gives you a guaranteed message order.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dgb4y6r", "score_hidden": false, "stickied": false, "created": 1492317274.0, "created_utc": 1492288474.0, "depth": 4, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg99oo1", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "aherpiesderpies", "parent_id": "t1_dg96f6w", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "Right I get you. \n\nI presume these frameworks give you the code to issue messages too and it could be handled there but the real issue then is that the users may call the send_message function lots for the same event making it impossible for the messaging stack to detect as it has received 2 different messages that just happened to have the same content?\n\nIs this not just an artifact of bad design on the library users side? \n\nAlso, can debouncing techniques not be used to stop users double dunting buttons and suchlike?", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Right I get you. &lt;/p&gt;\n\n&lt;p&gt;I presume these frameworks give you the code to issue messages too and it could be handled there but the real issue then is that the users may call the send_message function lots for the same event making it impossible for the messaging stack to detect as it has received 2 different messages that just happened to have the same content?&lt;/p&gt;\n\n&lt;p&gt;Is this not just an artifact of bad design on the library users side? &lt;/p&gt;\n\n&lt;p&gt;Also, can debouncing techniques not be used to stop users double dunting buttons and suchlike?&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg99oo1", "score_hidden": false, "stickied": false, "created": 1492212270.0, "created_utc": 1492183470.0, "depth": 3, "mod_reports": [], "subreddit_type": "public", "ups": 2}}], "after": null, "before": null}}, "user_reports": [], "id": "dg96f6w", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "nope_42", "parent_id": "t1_dg95fod", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "No, but then you are solving the ordering issues yourself rather than relying on your messaging stack to do it for you.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;No, but then you are solving the ordering issues yourself rather than relying on your messaging stack to do it for you.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg96f6w", "score_hidden": false, "stickied": false, "created": 1492208127.0, "created_utc": 1492179327.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 2}}], "after": null, "before": null}}, "user_reports": [], "id": "dg95fod", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "aherpiesderpies", "parent_id": "t1_dg7yr8j", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "Is there a reason that messages cannot include a nonce to solve the ordering issue? \n\nDisclaimer: I work closer to transistors than html", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Is there a reason that messages cannot include a nonce to solve the ordering issue? &lt;/p&gt;\n\n&lt;p&gt;Disclaimer: I work closer to transistors than html&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg95fod", "score_hidden": false, "stickied": false, "created": 1492206729.0, "created_utc": 1492177929.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 2}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": "", "user_reports": [], "id": "dg8n04n", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "salgat", "parent_id": "t1_dg7yr8j", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "With EventStore (for example) both ordering is guaranteed and you're almost forced to use idempotency for things like event sourcing. It's very doable (and very awesome when done right) but the problem is that very few people have the architectural chops and experience to do it right.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;With EventStore (for example) both ordering is guaranteed and you&amp;#39;re almost forced to use idempotency for things like event sourcing. It&amp;#39;s very doable (and very awesome when done right) but the problem is that very few people have the architectural chops and experience to do it right.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg8n04n", "score_hidden": false, "stickied": false, "created": 1492166200.0, "created_utc": 1492137400.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 1}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": "", "user_reports": [], "id": "dga0jkg", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "dccorona", "parent_id": "t1_dg7yr8j", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "&gt; and I have yet to see a real world use case where all messages are idempotent\n\nI deal with literally dozens of them at work. It's not really that hard to achieve in certain problem spaces...if you can express your eventual storage layer writes with some sort of conditional expression, you can probably achieve idempotency. Sure, there's tons of examples where that's not possible, or where the exact same thing being done twice actually isn't equal to it being done once (i.e. running a credit card charge through), but there's also tons of scenarios where it is.\n\nAs for Kafka/Kinesis, they (and similar technologies) actually address both the ordered message issue *and* the at least once issue...they offer exactly once delivery if the consumer is coded in a way that will achieve it as well. In particular, they make it possible to write truly 100% reliable stateful stream processors (for example, real-time counts that are 100% accurate).", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;blockquote&gt;\n&lt;p&gt;and I have yet to see a real world use case where all messages are idempotent&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;I deal with literally dozens of them at work. It&amp;#39;s not really that hard to achieve in certain problem spaces...if you can express your eventual storage layer writes with some sort of conditional expression, you can probably achieve idempotency. Sure, there&amp;#39;s tons of examples where that&amp;#39;s not possible, or where the exact same thing being done twice actually isn&amp;#39;t equal to it being done once (i.e. running a credit card charge through), but there&amp;#39;s also tons of scenarios where it is.&lt;/p&gt;\n\n&lt;p&gt;As for Kafka/Kinesis, they (and similar technologies) actually address both the ordered message issue &lt;em&gt;and&lt;/em&gt; the at least once issue...they offer exactly once delivery if the consumer is coded in a way that will achieve it as well. In particular, they make it possible to write truly 100% reliable stateful stream processors (for example, real-time counts that are 100% accurate).&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dga0jkg", "score_hidden": false, "stickied": false, "created": 1492245172.0, "created_utc": 1492216372.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg7yr8j", "gilded": 0, "archived": false, "score": 18, "report_reasons": null, "author": "nope_42", "parent_id": "t3_6567xu", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "I've heard the 'throw it on a message queue' answer a number of times and each time I think about the guarantees most queuing technology gives you.. which is not many.  \n\nA couple of issues:\n1) Most queues allow for out of order messages\n2) Most queues only guarantee at least once delivery so you may process the same message multiple times.\n\nThe ways to resolve the above issues are making messages idempotent (which almost no one is good at); and I have yet to see a real world use case where all messages are idempotent.\n\nIn the real world what I've seen is people just ignoring the issues and things working out OK, until they don't.\n\nAt least we have new alternatives like Kafka and Event hubs to fix the ordered messaging issue.  That said, it's still something you have to think heavily about when defining how your messages flow through your system.\n", "edited": 1492107518.0, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;ve heard the &amp;#39;throw it on a message queue&amp;#39; answer a number of times and each time I think about the guarantees most queuing technology gives you.. which is not many.  &lt;/p&gt;\n\n&lt;p&gt;A couple of issues:\n1) Most queues allow for out of order messages\n2) Most queues only guarantee at least once delivery so you may process the same message multiple times.&lt;/p&gt;\n\n&lt;p&gt;The ways to resolve the above issues are making messages idempotent (which almost no one is good at); and I have yet to see a real world use case where all messages are idempotent.&lt;/p&gt;\n\n&lt;p&gt;In the real world what I&amp;#39;ve seen is people just ignoring the issues and things working out OK, until they don&amp;#39;t.&lt;/p&gt;\n\n&lt;p&gt;At least we have new alternatives like Kafka and Event hubs to fix the ordered messaging issue.  That said, it&amp;#39;s still something you have to think heavily about when defining how your messages flow through your system.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg7yr8j", "score_hidden": false, "stickied": false, "created": 1492136047.0, "created_utc": 1492107247.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 18}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": "", "user_reports": [], "id": "dgbv0wn", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "adymitruk", "parent_id": "t1_dg7qk82", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "It's the only way I build all software now. Interesting ramifications about single source of truth and allowing external events to only update read-side projections.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;It&amp;#39;s the only way I build all software now. Interesting ramifications about single source of truth and allowing external events to only update read-side projections.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dgbv0wn", "score_hidden": false, "stickied": false, "created": 1492361326.0, "created_utc": 1492332526.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 2}}], "after": null, "before": null}}, "user_reports": [], "id": "dg7qk82", "gilded": 0, "archived": false, "score": 6, "report_reasons": null, "author": "romaneremin", "parent_id": "t3_6567xu", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "Eventsourcing and CQRS for microservices looks like a natural fit", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Eventsourcing and CQRS for microservices looks like a natural fit&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg7qk82", "score_hidden": false, "stickied": false, "created": 1492127329.0, "created_utc": 1492098529.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 6}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": "", "user_reports": [], "id": "dga9opy", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "dccorona", "parent_id": "t1_dga87x9", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "&gt; But RabbitMQ is the bottleneck for your entire service graph, not just a single service that can't do more than 40k/s\n\nThat statement implies you were suggesting such a setup...otherwise, queuing bottlenecks are no different from service bottlenecks.\n\nNothing you're saying is untrue...it's just not unique to queue-based approaches. My point is queues and HTTP servers bottleneck in more or less the same way. And while it's true a self-hosted queues are usually going to be harder to scale than an HTTP server, there are better options out there. RabbitMQ isn't the only game in town. \n\nSQS, for example, scales effectively infinitely, and entirely automatically...you don't have to do anything (except make sure you have enough queue pollers on the other side. The only bottleneck you really have to concern yourself with is a 120k message *instantaneous throughput* (not per second, per instant). This results in trading a web server that you have to scale on your own for a queue that scales entirely automatically. The bottleneck is effectively gone for good.\n\n&gt; So no, I cannot and will not ever advocate for the used of RabbitMQ as a RPC transport\n\nI wasn't either. If you really need RPC, a queue is almost certainly not worth the tradeoffs. The point is you can often design your system in such a way that you *don't* need RPC, it is just one possible way of achieving your business goal. When that is the case, there is usually a queue-based approach that makes for a more scalable and more operationally sound system. That doesn't mean you're using queues to do RPC, it means you're designed around queues instead of RPC in the first place.\n", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;blockquote&gt;\n&lt;p&gt;But RabbitMQ is the bottleneck for your entire service graph, not just a single service that can&amp;#39;t do more than 40k/s&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;That statement implies you were suggesting such a setup...otherwise, queuing bottlenecks are no different from service bottlenecks.&lt;/p&gt;\n\n&lt;p&gt;Nothing you&amp;#39;re saying is untrue...it&amp;#39;s just not unique to queue-based approaches. My point is queues and HTTP servers bottleneck in more or less the same way. And while it&amp;#39;s true a self-hosted queues are usually going to be harder to scale than an HTTP server, there are better options out there. RabbitMQ isn&amp;#39;t the only game in town. &lt;/p&gt;\n\n&lt;p&gt;SQS, for example, scales effectively infinitely, and entirely automatically...you don&amp;#39;t have to do anything (except make sure you have enough queue pollers on the other side. The only bottleneck you really have to concern yourself with is a 120k message &lt;em&gt;instantaneous throughput&lt;/em&gt; (not per second, per instant). This results in trading a web server that you have to scale on your own for a queue that scales entirely automatically. The bottleneck is effectively gone for good.&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;So no, I cannot and will not ever advocate for the used of RabbitMQ as a RPC transport&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;I wasn&amp;#39;t either. If you really need RPC, a queue is almost certainly not worth the tradeoffs. The point is you can often design your system in such a way that you &lt;em&gt;don&amp;#39;t&lt;/em&gt; need RPC, it is just one possible way of achieving your business goal. When that is the case, there is usually a queue-based approach that makes for a more scalable and more operationally sound system. That doesn&amp;#39;t mean you&amp;#39;re using queues to do RPC, it means you&amp;#39;re designed around queues instead of RPC in the first place.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dga9opy", "score_hidden": false, "stickied": false, "created": 1492258521.0, "created_utc": 1492229721.0, "depth": 5, "mod_reports": [], "subreddit_type": "public", "ups": 3}}], "after": null, "before": null}}, "user_reports": [], "id": "dga87x9", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "Xorlev", "parent_id": "t1_dga815o", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "I never said that. You can have a queue per service&lt;-&gt;service link and still run into issues. A noisy queue on the same machine, or hitting the limits of a single RabbitMQ box for a single service&lt;-&gt;service link.\n\nWe ran RabbitMQ with dozens of queues. It always found a way to come bite us.\n\nSo no, I cannot and will not ever advocate for the used of RabbitMQ as a RPC transport: just use real RPC and shed load if you're over capacity. Your users certainly won't be hanging around for 6 minutes while more capacity is launched for their very stale request to go through.\n\nI'm happy to go into more details about issues we faced and patterns we adopted that have worked well for us if desired.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I never said that. You can have a queue per service&amp;lt;-&amp;gt;service link and still run into issues. A noisy queue on the same machine, or hitting the limits of a single RabbitMQ box for a single service&amp;lt;-&amp;gt;service link.&lt;/p&gt;\n\n&lt;p&gt;We ran RabbitMQ with dozens of queues. It always found a way to come bite us.&lt;/p&gt;\n\n&lt;p&gt;So no, I cannot and will not ever advocate for the used of RabbitMQ as a RPC transport: just use real RPC and shed load if you&amp;#39;re over capacity. Your users certainly won&amp;#39;t be hanging around for 6 minutes while more capacity is launched for their very stale request to go through.&lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;m happy to go into more details about issues we faced and patterns we adopted that have worked well for us if desired.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dga87x9", "score_hidden": false, "stickied": false, "created": 1492256096.0, "created_utc": 1492227296.0, "depth": 4, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dga815o", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "dccorona", "parent_id": "t1_dga7tve", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "You don't have to route the entire architecture through a single queue...", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;You don&amp;#39;t have to route the entire architecture through a single queue...&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dga815o", "score_hidden": false, "stickied": false, "created": 1492255802.0, "created_utc": 1492227002.0, "depth": 3, "mod_reports": [], "subreddit_type": "public", "ups": 3}}], "after": null, "before": null}}, "user_reports": [], "id": "dga7tve", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "Xorlev", "parent_id": "t1_dga1q01", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "That's the limit of your single service, yes. But RabbitMQ is _the_ bottleneck for your entire service graph, not just a single service that can't do more than 40k/s. It's very easy to get massive traffic amplification in microservice architectures, that is: service A -&gt; service B -&gt; service {C,D}, etc. -- a single frontend request turns into half a dozen or more subsequent requests, so this isn't a just a theoretical problem. For what it's worth, in our experience, RabbitMQ tends to be more difficult to horizontally scale than a stateless service (though that might not be true of the database behind it).", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;That&amp;#39;s the limit of your single service, yes. But RabbitMQ is &lt;em&gt;the&lt;/em&gt; bottleneck for your entire service graph, not just a single service that can&amp;#39;t do more than 40k/s. It&amp;#39;s very easy to get massive traffic amplification in microservice architectures, that is: service A -&amp;gt; service B -&amp;gt; service {C,D}, etc. -- a single frontend request turns into half a dozen or more subsequent requests, so this isn&amp;#39;t a just a theoretical problem. For what it&amp;#39;s worth, in our experience, RabbitMQ tends to be more difficult to horizontally scale than a stateless service (though that might not be true of the database behind it).&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dga7tve", "score_hidden": false, "stickied": false, "created": 1492255486.0, "created_utc": 1492226686.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dga1q01", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "dccorona", "parent_id": "t1_dg8bdv4", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "&gt; Can your queue do 40,000 messages/s? Well, that's the limit of your service&lt;-&gt;service communications until you scale it\n\nHow is this any different than a synchronous setup? If the downstream service is set up to do 40,000 TPS, then...that's the limit of your service-to-service communications until you scale it, too.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;blockquote&gt;\n&lt;p&gt;Can your queue do 40,000 messages/s? Well, that&amp;#39;s the limit of your service&amp;lt;-&amp;gt;service communications until you scale it&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;How is this any different than a synchronous setup? If the downstream service is set up to do 40,000 TPS, then...that&amp;#39;s the limit of your service-to-service communications until you scale it, too.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dga1q01", "score_hidden": false, "stickied": false, "created": 1492246745.0, "created_utc": 1492217945.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg8bdv4", "gilded": 0, "archived": false, "score": 5, "report_reasons": null, "author": "Xorlev", "parent_id": "t3_6567xu", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "The biggest problem there is you pin your entire infrastructure on a message queue. Can your queue do 40,000 messages/s? Well, that's the limit of your service&lt;-&gt;service communications until you scale it. Having used RabbitMQ for about 4 years, I'd never trust it with all my service traffic: it simply isn't reliable enough under heavy load. We've swapped the majority of our load to SQS or Kafka at this point, depending on the type of communication.\n\nThat said, if work is asynchronous then it seems like a MQ of some sort is fine. At that point you're no longer talking about fulfilling an API call with multiple collaborating services, but instead orchestrating a multi-stage graph of computation which communicates via message queue. Higher latency, but if it's async then who cares? If you're concerned about consistency (since you've now built a big ole' eventually-consistent heterogenous database), you'll need to look into the [Saga Pattern](https://cararuseugeniu.blogspot.com/p/saga-pattern.html) as a way of trying to handle rollbacks. Welcome to distributed systems.\n\nIn our experience, most of our \"microservices\" require immediate responses, at which point we're already fighting lots of queues (TCP, routers, TCP, RPC handler queue). No need to add another centralized one. I imagine request tracing looks a little different with message queuing too (if you go ahead and do the RabbitMQ RPC pattern), which would include explicit queue waits.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;The biggest problem there is you pin your entire infrastructure on a message queue. Can your queue do 40,000 messages/s? Well, that&amp;#39;s the limit of your service&amp;lt;-&amp;gt;service communications until you scale it. Having used RabbitMQ for about 4 years, I&amp;#39;d never trust it with all my service traffic: it simply isn&amp;#39;t reliable enough under heavy load. We&amp;#39;ve swapped the majority of our load to SQS or Kafka at this point, depending on the type of communication.&lt;/p&gt;\n\n&lt;p&gt;That said, if work is asynchronous then it seems like a MQ of some sort is fine. At that point you&amp;#39;re no longer talking about fulfilling an API call with multiple collaborating services, but instead orchestrating a multi-stage graph of computation which communicates via message queue. Higher latency, but if it&amp;#39;s async then who cares? If you&amp;#39;re concerned about consistency (since you&amp;#39;ve now built a big ole&amp;#39; eventually-consistent heterogenous database), you&amp;#39;ll need to look into the &lt;a href=\"https://cararuseugeniu.blogspot.com/p/saga-pattern.html\"&gt;Saga Pattern&lt;/a&gt; as a way of trying to handle rollbacks. Welcome to distributed systems.&lt;/p&gt;\n\n&lt;p&gt;In our experience, most of our &amp;quot;microservices&amp;quot; require immediate responses, at which point we&amp;#39;re already fighting lots of queues (TCP, routers, TCP, RPC handler queue). No need to add another centralized one. I imagine request tracing looks a little different with message queuing too (if you go ahead and do the RabbitMQ RPC pattern), which would include explicit queue waits.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg8bdv4", "score_hidden": false, "stickied": false, "created": 1492150354.0, "created_utc": 1492121554.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 5}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": "", "user_reports": [], "id": "dg86j40", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "skratlo", "parent_id": "t1_dg862dn", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "That's a one good answer. HTTP is overrated because most devs only know this one protocol (or at least they think they know it). It's heavily over-used in cases where it really doesn't fit.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;That&amp;#39;s a one good answer. HTTP is overrated because most devs only know this one protocol (or at least they think they know it). It&amp;#39;s heavily over-used in cases where it really doesn&amp;#39;t fit.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg86j40", "score_hidden": false, "stickied": false, "created": 1492144495.0, "created_utc": 1492115695.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 3}}], "after": null, "before": null}}, "user_reports": [], "id": "dg862dn", "gilded": 0, "archived": false, "score": 18, "report_reasons": null, "author": "drysart", "parent_id": "t1_dg808c1", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "Bufferbloat specifically refers to an entirely different sort of problem than what you're describing.\n\nAnd the other things you listed all have perfectly reasonable answers that you'd expect someone who's heavily using a message queue to already have answers for:\n\n* \"It's impossible for the sender to see or process errors\" - If your sender cares about the outcome of a call to a microservice, they should be processing response messages, and those response messages can just as easily carry details about errors.\n* \"You may not know what sent the killer message\" - Good message queues should store the source of a message; and you should also have application-specific source information (*at the very least* some sort of global transaction identifier) in your payload for debugging that you can correlate with logs when necessary.\n* \"What happens when you fill the queue faster than you can digest it?\" - Then your monitoring should indicate the queue is piling up and you spin up more instances of the consumer service to handle the backlog which all clears out without issues.  Which, by the way, is a *far better story* than what happens in an HTTP-based microservice architecture in the same scenario, where requests time out, are lost, and half-completed workflows need to be abandoned entirely rather than simply delayed.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Bufferbloat specifically refers to an entirely different sort of problem than what you&amp;#39;re describing.&lt;/p&gt;\n\n&lt;p&gt;And the other things you listed all have perfectly reasonable answers that you&amp;#39;d expect someone who&amp;#39;s heavily using a message queue to already have answers for:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&amp;quot;It&amp;#39;s impossible for the sender to see or process errors&amp;quot; - If your sender cares about the outcome of a call to a microservice, they should be processing response messages, and those response messages can just as easily carry details about errors.&lt;/li&gt;\n&lt;li&gt;&amp;quot;You may not know what sent the killer message&amp;quot; - Good message queues should store the source of a message; and you should also have application-specific source information (&lt;em&gt;at the very least&lt;/em&gt; some sort of global transaction identifier) in your payload for debugging that you can correlate with logs when necessary.&lt;/li&gt;\n&lt;li&gt;&amp;quot;What happens when you fill the queue faster than you can digest it?&amp;quot; - Then your monitoring should indicate the queue is piling up and you spin up more instances of the consumer service to handle the backlog which all clears out without issues.  Which, by the way, is a &lt;em&gt;far better story&lt;/em&gt; than what happens in an HTTP-based microservice architecture in the same scenario, where requests time out, are lost, and half-completed workflows need to be abandoned entirely rather than simply delayed.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg862dn", "score_hidden": false, "stickied": false, "created": 1492143969.0, "created_utc": 1492115169.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 18}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": "", "user_reports": [], "id": "dg83lo8", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "kefeer", "parent_id": "t1_dg808c1", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "You get an sms alert from your monitoring and sort it out.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;You get an sms alert from your monitoring and sort it out.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg83lo8", "score_hidden": false, "stickied": false, "created": 1492141272.0, "created_utc": 1492112472.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 2}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": "", "user_reports": [], "id": "dg86a2f", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "skratlo", "parent_id": "t1_dg808c1", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "You (auto-)scale by monitoring queue size", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;You (auto-)scale by monitoring queue size&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg86a2f", "score_hidden": false, "stickied": false, "created": 1492144207.0, "created_utc": 1492115407.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 2}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": "", "user_reports": [], "id": "dg99wyt", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "staticassert", "parent_id": "t1_dg808c1", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "As mentioned, bufferbloat is separate.\n\nYou're describing two problems:\n\n1) Message queues are asynchronous and have no response mechanism built in\n\n2) Backpressure\n\nThese are solved in various ways.\n\n1) You can have your queue handle acks from your downstream service, and replay messages. A combination of replays and transactions for idempotency is a powerful technique. Alternatively, as with actor systems, you can have the other service send a message back when it has completed the task (I think for distributed systems this is best handled by the queue)..\n\n2) Backpressure:\n\nhttps://www.youtube.com/watch?v=IuK2NvxjvWY&amp;list=UUKrD_GYN3iDpG_uMmADPzJQ\n\nThat's a great talk on backpressure in actor-oriented systems, where everything is queue based.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;As mentioned, bufferbloat is separate.&lt;/p&gt;\n\n&lt;p&gt;You&amp;#39;re describing two problems:&lt;/p&gt;\n\n&lt;p&gt;1) Message queues are asynchronous and have no response mechanism built in&lt;/p&gt;\n\n&lt;p&gt;2) Backpressure&lt;/p&gt;\n\n&lt;p&gt;These are solved in various ways.&lt;/p&gt;\n\n&lt;p&gt;1) You can have your queue handle acks from your downstream service, and replay messages. A combination of replays and transactions for idempotency is a powerful technique. Alternatively, as with actor systems, you can have the other service send a message back when it has completed the task (I think for distributed systems this is best handled by the queue)..&lt;/p&gt;\n\n&lt;p&gt;2) Backpressure:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://www.youtube.com/watch?v=IuK2NvxjvWY&amp;amp;list=UUKrD_GYN3iDpG_uMmADPzJQ\"&gt;https://www.youtube.com/watch?v=IuK2NvxjvWY&amp;amp;list=UUKrD_GYN3iDpG_uMmADPzJQ&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;That&amp;#39;s a great talk on backpressure in actor-oriented systems, where everything is queue based.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg99wyt", "score_hidden": false, "stickied": false, "created": 1492212545.0, "created_utc": 1492183745.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg808c1", "gilded": 0, "archived": false, "score": 15, "report_reasons": null, "author": "pnpbios", "parent_id": "t3_6567xu", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "Counterpoint: https://en.wikipedia.org/wiki/Bufferbloat\n\nBy throwing units of work in a queue, you are just masking a problem. Dispatching a message to a queue is free. It takes no time, for the sender to send, and it's impossible for the sender to see or process errors.\n\nSo if something breaks down the line, you may not know what sent the killer message. What happens when you fill the queue faster than you can digest it?\n", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Counterpoint: &lt;a href=\"https://en.wikipedia.org/wiki/Bufferbloat\"&gt;https://en.wikipedia.org/wiki/Bufferbloat&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;By throwing units of work in a queue, you are just masking a problem. Dispatching a message to a queue is free. It takes no time, for the sender to send, and it&amp;#39;s impossible for the sender to see or process errors.&lt;/p&gt;\n\n&lt;p&gt;So if something breaks down the line, you may not know what sent the killer message. What happens when you fill the queue faster than you can digest it?&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg808c1", "score_hidden": false, "stickied": false, "created": 1492137618.0, "created_utc": 1492108818.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 15}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": "", "user_reports": [], "id": "dg9a1aj", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "staticassert", "parent_id": "t1_dg8z4it", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "This is not true. You can trivially model state machines as asynchronous state machines with messaging queues. Erlang's fsm and gen_server show this pattern clearly, and it's incredibly strong for responsive servers since you never block.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;This is not true. You can trivially model state machines as asynchronous state machines with messaging queues. Erlang&amp;#39;s fsm and gen_server show this pattern clearly, and it&amp;#39;s incredibly strong for responsive servers since you never block.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg9a1aj", "score_hidden": false, "stickied": false, "created": 1492212687.0, "created_utc": 1492183887.0, "depth": 3, "mod_reports": [], "subreddit_type": "public", "ups": 2}}], "after": null, "before": null}}, "user_reports": [], "id": "dg8z4it", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "CurtainDog", "parent_id": "t1_dg8lkmg", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "Not really. You either rely on an ordering or you don't. If you really do rely on a sequence of actions being ordered a particular way then  trying an asynchronous solution is pure overhead. ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Not really. You either rely on an ordering or you don&amp;#39;t. If you really do rely on a sequence of actions being ordered a particular way then  trying an asynchronous solution is pure overhead. &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg8z4it", "score_hidden": false, "stickied": false, "created": 1492192832.0, "created_utc": 1492164032.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg8lkmg", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "haimez", "parent_id": "t1_dg89i8f", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "Asynchronous implementations can be made to appear synchronous and enjoy the throughout benefits. The same can not be said of the reverse, and the human waiting is a non factor.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Asynchronous implementations can be made to appear synchronous and enjoy the throughout benefits. The same can not be said of the reverse, and the human waiting is a non factor.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg8lkmg", "score_hidden": false, "stickied": false, "created": 1492164166.0, "created_utc": 1492135366.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg89i8f", "gilded": 0, "archived": false, "score": 5, "report_reasons": null, "author": "nfrankel", "parent_id": "t3_6567xu", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "It boils down to synchronous vs asynchronous. If you can allow yourself not to wait for the answer, then message queuing is fine. When there's a human being waiting at the end of the chain, it sucks...", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;It boils down to synchronous vs asynchronous. If you can allow yourself not to wait for the answer, then message queuing is fine. When there&amp;#39;s a human being waiting at the end of the chain, it sucks...&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg89i8f", "score_hidden": false, "stickied": false, "created": 1492147984.0, "created_utc": 1492119184.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 5}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": "", "user_reports": [], "id": "dgbs9zg", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "gnus-migrate", "parent_id": "t1_dgax8f2", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "In terms of RPC calls, I hadn't considered the deployment aspect of it so you have a point there. Ignoring that aspect for a second, let's assume that all services can talk to each other and we have the option of using either.\n\nIn terms of failure scenarios, frameworks exist in order to handle common failure scenarios for RPC as well, so it isn't really much of an argument in favor of them. The question becomes where do I want to handle failures our outages of my service? There are many scenarios where the producer of the message is expecting some kind of response, and by using a message broker for everything you'll eventually build RPC semantics on top of a system which wasn't necessarily designed for it as opposed to using the tooling that already exists for that kind of use case. \n\nYou're right in that I did overlook some scenarios where message brokers might be better(the deployment aspect is definitely something I didn't think of), but my point was and still is that whenever someone is considering whether a message broker or any other technology needs to be added, there should be a clear set of use cases which should drive the need for this technology. Otherwise it's an extra unnecessary thing I need to understand and maintain.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;In terms of RPC calls, I hadn&amp;#39;t considered the deployment aspect of it so you have a point there. Ignoring that aspect for a second, let&amp;#39;s assume that all services can talk to each other and we have the option of using either.&lt;/p&gt;\n\n&lt;p&gt;In terms of failure scenarios, frameworks exist in order to handle common failure scenarios for RPC as well, so it isn&amp;#39;t really much of an argument in favor of them. The question becomes where do I want to handle failures our outages of my service? There are many scenarios where the producer of the message is expecting some kind of response, and by using a message broker for everything you&amp;#39;ll eventually build RPC semantics on top of a system which wasn&amp;#39;t necessarily designed for it as opposed to using the tooling that already exists for that kind of use case. &lt;/p&gt;\n\n&lt;p&gt;You&amp;#39;re right in that I did overlook some scenarios where message brokers might be better(the deployment aspect is definitely something I didn&amp;#39;t think of), but my point was and still is that whenever someone is considering whether a message broker or any other technology needs to be added, there should be a clear set of use cases which should drive the need for this technology. Otherwise it&amp;#39;s an extra unnecessary thing I need to understand and maintain.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dgbs9zg", "score_hidden": false, "stickied": false, "created": 1492353388.0, "created_utc": 1492324588.0, "depth": 4, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dgax8f2", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "dccorona", "parent_id": "t1_dgatuwb", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "The article is definitely hyperbole, yes. But I still think you're overlooking a lot of valuable things message queues offer you in saying that they're overkill...even if you know you only have to talk to 3 services, they're *still* extremely valuable because they give you isolation from the consumer's availability. That service can slow down or have an outage and have 0 impact on the message producer, something that is often desirable. Even if you have only 1 consumer, if it's not important that the sender of the message know when it is done being successfully processed (i.e. it is not critical path), it's still really useful...it allows you to surge over the maximum throughput of your subscriber for short periods without them needing to scale with you, it protects you from their operational issues, etc. There's tons of scenarios where message queues are desirable, no matter how many subscribers there are for a given event type. \n\nIt's also not really true any longer that RPC is simpler than asynchronous message passing. In fact, I'd argue that in some scenarios it's actually *more complex*, particularly if you're trying to operate in an environment where service-to-service communication isn't straightforward (i.e. they're not both on the public internet, nor are they both inside the same VPC...that's a common setup and it hugely complicates direct service-to-service communication, but a message queue is just as easy as it is anywhere else). But even if HTTP is simple to implement with your organization's networking setup, messages queues are still about as easy to work with. There are tons of frameworks for most popular queuing services that make it easy to not have to deal with the complications of the actual message polling or even failure scenarios, and allow you to just write your business logic and call it a day.  ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;The article is definitely hyperbole, yes. But I still think you&amp;#39;re overlooking a lot of valuable things message queues offer you in saying that they&amp;#39;re overkill...even if you know you only have to talk to 3 services, they&amp;#39;re &lt;em&gt;still&lt;/em&gt; extremely valuable because they give you isolation from the consumer&amp;#39;s availability. That service can slow down or have an outage and have 0 impact on the message producer, something that is often desirable. Even if you have only 1 consumer, if it&amp;#39;s not important that the sender of the message know when it is done being successfully processed (i.e. it is not critical path), it&amp;#39;s still really useful...it allows you to surge over the maximum throughput of your subscriber for short periods without them needing to scale with you, it protects you from their operational issues, etc. There&amp;#39;s tons of scenarios where message queues are desirable, no matter how many subscribers there are for a given event type. &lt;/p&gt;\n\n&lt;p&gt;It&amp;#39;s also not really true any longer that RPC is simpler than asynchronous message passing. In fact, I&amp;#39;d argue that in some scenarios it&amp;#39;s actually &lt;em&gt;more complex&lt;/em&gt;, particularly if you&amp;#39;re trying to operate in an environment where service-to-service communication isn&amp;#39;t straightforward (i.e. they&amp;#39;re not both on the public internet, nor are they both inside the same VPC...that&amp;#39;s a common setup and it hugely complicates direct service-to-service communication, but a message queue is just as easy as it is anywhere else). But even if HTTP is simple to implement with your organization&amp;#39;s networking setup, messages queues are still about as easy to work with. There are tons of frameworks for most popular queuing services that make it easy to not have to deal with the complications of the actual message polling or even failure scenarios, and allow you to just write your business logic and call it a day.  &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dgax8f2", "score_hidden": false, "stickied": false, "created": 1492306816.0, "created_utc": 1492278016.0, "depth": 3, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dgatuwb", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "gnus-migrate", "parent_id": "t1_dga1m58", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "Fair enough, but I would emphasize that there are situations where a timeout coupled with a retry policy is enough. Implementing an RPC call is much simpler than implementing event handling logic, so if you can design your application in such a way then you should, for example when your message has 1 consumer by design.\n\nEven if you have more than one consumer, if you know that you're going to talk to exactly three services at design time, then a message broker is still overkill.\n\nTo me a message broker is useful when you have a large number of messages going through a system such as batch jobs or systems with particularly heavy requests. I'm wasn't saying there aren't valid uses for message brokers, I'm was saying that you shouldn't default to using them as the article is claiming.", "edited": 1492273876.0, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Fair enough, but I would emphasize that there are situations where a timeout coupled with a retry policy is enough. Implementing an RPC call is much simpler than implementing event handling logic, so if you can design your application in such a way then you should, for example when your message has 1 consumer by design.&lt;/p&gt;\n\n&lt;p&gt;Even if you have more than one consumer, if you know that you&amp;#39;re going to talk to exactly three services at design time, then a message broker is still overkill.&lt;/p&gt;\n\n&lt;p&gt;To me a message broker is useful when you have a large number of messages going through a system such as batch jobs or systems with particularly heavy requests. I&amp;#39;m wasn&amp;#39;t saying there aren&amp;#39;t valid uses for message brokers, I&amp;#39;m was saying that you shouldn&amp;#39;t default to using them as the article is claiming.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dgatuwb", "score_hidden": false, "stickied": false, "created": 1492302159.0, "created_utc": 1492273359.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dga1m58", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "dccorona", "parent_id": "t1_dg7ywlf", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "&gt; If you can properly recover from a failure though, a message broker is really overkill\n\nYou're overlooking a lot of scenarios where a queue of some kind is helpful. The biggest one, for me, is when the producer, for one reason another, simply cannot allow itself to be slowed down by a slow/dead consumer. Generally, you want to avoid a scenario where a downstream service outage has impact on the upstream service...particularly if the upstream service has several consumers. In nearly any situation where a single service has more than one system downstream of it, you probably want a queue of some kind.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;blockquote&gt;\n&lt;p&gt;If you can properly recover from a failure though, a message broker is really overkill&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;You&amp;#39;re overlooking a lot of scenarios where a queue of some kind is helpful. The biggest one, for me, is when the producer, for one reason another, simply cannot allow itself to be slowed down by a slow/dead consumer. Generally, you want to avoid a scenario where a downstream service outage has impact on the upstream service...particularly if the upstream service has several consumers. In nearly any situation where a single service has more than one system downstream of it, you probably want a queue of some kind.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dga1m58", "score_hidden": false, "stickied": false, "created": 1492246604.0, "created_utc": 1492217804.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg7ywlf", "gilded": 0, "archived": false, "score": 6, "report_reasons": null, "author": "gnus-migrate", "parent_id": "t3_6567xu", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "It's easy to say that you should stick a message broker in there and all will be good in the world, but it's not really that clear cut. A message broker is useful when lost messages result in a corrupted state. If you can properly recover from a failure though, a message broker is really overkill.\n\nBlog posts making blanket claims like this need to stop. Understand the problems these products solve instead of just taking a side based on popularity.", "edited": 1492107717.0, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;It&amp;#39;s easy to say that you should stick a message broker in there and all will be good in the world, but it&amp;#39;s not really that clear cut. A message broker is useful when lost messages result in a corrupted state. If you can properly recover from a failure though, a message broker is really overkill.&lt;/p&gt;\n\n&lt;p&gt;Blog posts making blanket claims like this need to stop. Understand the problems these products solve instead of just taking a side based on popularity.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg7ywlf", "score_hidden": false, "stickied": false, "created": 1492136204.0, "created_utc": 1492107404.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 6}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": "", "user_reports": [], "id": "dg8c00r", "gilded": 0, "archived": false, "score": -5, "report_reasons": null, "author": "Cifize", "parent_id": "t1_dg83ocr", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "This is a joke, right?", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;This is a joke, right?&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg8c00r", "score_hidden": false, "stickied": false, "created": 1492151169.0, "created_utc": 1492122369.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": -5}}], "after": null, "before": null}}, "user_reports": [], "id": "dg83ocr", "gilded": 0, "archived": false, "score": 5, "report_reasons": null, "author": "davidk01", "parent_id": "t3_6567xu", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "People choose HTTP because it is a ubiquitous protocol and there are clients ready to go. No other protocol can say the same.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;People choose HTTP because it is a ubiquitous protocol and there are clients ready to go. No other protocol can say the same.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg83ocr", "score_hidden": false, "stickied": false, "created": 1492141349.0, "created_utc": 1492112549.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 5}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": "", "user_reports": [], "id": "dg95myb", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "littlehawk93", "parent_id": "t1_dg8ifr7", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "It's almost like different technologies have their pros and cons for different situations, and titling your technical article \"Why ____ sucks\" or \"Stop using _____\" makes it click-baity and misleading", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;It&amp;#39;s almost like different technologies have their pros and cons for different situations, and titling your technical article &amp;quot;Why ____ sucks&amp;quot; or &amp;quot;Stop using _____&amp;quot; makes it click-baity and misleading&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg95myb", "score_hidden": false, "stickied": false, "created": 1492207019.0, "created_utc": 1492178219.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg8ifr7", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "EntroperZero", "parent_id": "t1_dg8a6zo", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "And the [follow-up.](https://www.programmableweb.com/news/why-messages-queues-might-not-suck/analysis/2017/03/29)", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;And the &lt;a href=\"https://www.programmableweb.com/news/why-messages-queues-might-not-suck/analysis/2017/03/29\"&gt;follow-up.&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg8ifr7", "score_hidden": false, "stickied": false, "created": 1492159844.0, "created_utc": 1492131044.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg8a6zo", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "littlehawk93", "parent_id": "t3_6567xu", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "[I remember reading this on this sub a few weeks back](https://www.programmableweb.com/news/why-messaging-queues-suck/analysis/2017/02/13)", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;&lt;a href=\"https://www.programmableweb.com/news/why-messaging-queues-suck/analysis/2017/02/13\"&gt;I remember reading this on this sub a few weeks back&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg8a6zo", "score_hidden": false, "stickied": false, "created": 1492148845.0, "created_utc": 1492120045.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 3}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": "", "user_reports": [], "id": "dgapf3d", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "staticassert", "parent_id": "t1_dga1xix", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "&gt; As far as I'm aware, actors aren't generally durable in the state of failure\n\nThat depends on your view of durable. Pony actors do not ever die. Erlang actors do. The actor model itself doesn't really specify failure behaviors.\n\n&gt; \nActors won't give you quite the same thing, because if an actor dies with 10 messages in its mailbox, those messages are gone unless the sender has a way to be informed of their failure, and the ability to redeliver them...which ultimately ends up introducing much of the same overhead of HTTP that queues free up.\n\nThis isn't quite true. First of all, the issue isn't overhead - the issue is blocking. Second, you can totally redeliver messages with actors. Supervisors can do this for you - replaying the last message repeatedly until they meet some failure criteria, at which point the error propagates up.\n\nWhen the error propagates up to the root, the initial message, from rabbit as an example, will be sent back onto the queue *or* you can simply not ack the message, either strategy is fine, and there are other ways to deal with it.\n\nSupervisor structures and acking messages from an external queue seem like fine ways to deal with this.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;blockquote&gt;\n&lt;p&gt;As far as I&amp;#39;m aware, actors aren&amp;#39;t generally durable in the state of failure&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;That depends on your view of durable. Pony actors do not ever die. Erlang actors do. The actor model itself doesn&amp;#39;t really specify failure behaviors.&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;Actors won&amp;#39;t give you quite the same thing, because if an actor dies with 10 messages in its mailbox, those messages are gone unless the sender has a way to be informed of their failure, and the ability to redeliver them...which ultimately ends up introducing much of the same overhead of HTTP that queues free up.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;This isn&amp;#39;t quite true. First of all, the issue isn&amp;#39;t overhead - the issue is blocking. Second, you can totally redeliver messages with actors. Supervisors can do this for you - replaying the last message repeatedly until they meet some failure criteria, at which point the error propagates up.&lt;/p&gt;\n\n&lt;p&gt;When the error propagates up to the root, the initial message, from rabbit as an example, will be sent back onto the queue &lt;em&gt;or&lt;/em&gt; you can simply not ack the message, either strategy is fine, and there are other ways to deal with it.&lt;/p&gt;\n\n&lt;p&gt;Supervisor structures and acking messages from an external queue seem like fine ways to deal with this.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dgapf3d", "score_hidden": false, "stickied": false, "created": 1492295782.0, "created_utc": 1492266982.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dga1xix", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "dccorona", "parent_id": "t1_dg99r3m", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "As far as I'm aware, actors aren't generally durable in the state of failure. Most HTTP setups I've used aren't really all that different from actors in their similarity to queues...it's just a little bit more default with actors than it is with HTTP. \n\nThe nice thing about queues is that once you get that OK from the queue, you're good to go...that message is going to be received, or it's going to go into a DLQ where a human is going to figure out what is wrong with it and fix it. That's a great assumption to be able to make when trying to write a fast, high-throughput, fault-tolerant service. \n\nActors won't give you quite the same thing, because if an actor dies with 10 messages in its mailbox, those messages are gone unless the sender has a way to be informed of their failure, *and* the ability to redeliver them...which ultimately ends up introducing much of the same overhead of HTTP that queues free up.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;As far as I&amp;#39;m aware, actors aren&amp;#39;t generally durable in the state of failure. Most HTTP setups I&amp;#39;ve used aren&amp;#39;t really all that different from actors in their similarity to queues...it&amp;#39;s just a little bit more default with actors than it is with HTTP. &lt;/p&gt;\n\n&lt;p&gt;The nice thing about queues is that once you get that OK from the queue, you&amp;#39;re good to go...that message is going to be received, or it&amp;#39;s going to go into a DLQ where a human is going to figure out what is wrong with it and fix it. That&amp;#39;s a great assumption to be able to make when trying to write a fast, high-throughput, fault-tolerant service. &lt;/p&gt;\n\n&lt;p&gt;Actors won&amp;#39;t give you quite the same thing, because if an actor dies with 10 messages in its mailbox, those messages are gone unless the sender has a way to be informed of their failure, &lt;em&gt;and&lt;/em&gt; the ability to redeliver them...which ultimately ends up introducing much of the same overhead of HTTP that queues free up.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dga1xix", "score_hidden": false, "stickied": false, "created": 1492247024.0, "created_utc": 1492218224.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg99r3m", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "staticassert", "parent_id": "t3_6567xu", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "I'm surprised no one has brought up actors.\n\nIf you look at a microservice with a queue, it's very similar to an actor. As others have mentioned - at-most-once delivery is critical, as is ordering (causal ordering is incredibly useful).\n\nBut, given those guarantees, you get something wonderful - your microservices can be trivially scaled, your microservices are never tied together by sessions, everything is asynchronous, etc. It is an incredible way to model your systems. Looking at actor based systems and how reliable and scalable they are really shows this off I think. ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;m surprised no one has brought up actors.&lt;/p&gt;\n\n&lt;p&gt;If you look at a microservice with a queue, it&amp;#39;s very similar to an actor. As others have mentioned - at-most-once delivery is critical, as is ordering (causal ordering is incredibly useful).&lt;/p&gt;\n\n&lt;p&gt;But, given those guarantees, you get something wonderful - your microservices can be trivially scaled, your microservices are never tied together by sessions, everything is asynchronous, etc. It is an incredible way to model your systems. Looking at actor based systems and how reliable and scalable they are really shows this off I think. &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg99r3m", "score_hidden": false, "stickied": false, "created": 1492212352.0, "created_utc": 1492183552.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 2}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": "", "user_reports": [], "id": "dg8azis", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "Xorlev", "parent_id": "t1_dg86rob", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "Lets not be falsely surprised, there's plenty of infrastructures out there that rely on graphs of synchronous calls.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Lets not be falsely surprised, there&amp;#39;s plenty of infrastructures out there that rely on graphs of synchronous calls.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg8azis", "score_hidden": false, "stickied": false, "created": 1492149840.0, "created_utc": 1492121040.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 3}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_6567xu", "likes": null, "replies": "", "user_reports": [], "id": "dg8fz7e", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "kheiron1729", "parent_id": "t1_dg86rob", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "Think of it this way, your browser right now is communicating with the the reddit service using the HTTP protocol. Sure, the protocol is was designed to fit this use-case, but if you can find an analogous use-case then there is no reason why you shouldn't use HTTP.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Think of it this way, your browser right now is communicating with the the reddit service using the HTTP protocol. Sure, the protocol is was designed to fit this use-case, but if you can find an analogous use-case then there is no reason why you shouldn&amp;#39;t use HTTP.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg8fz7e", "score_hidden": false, "stickied": false, "created": 1492156465.0, "created_utc": 1492127665.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 3}}], "after": null, "before": null}}, "user_reports": [], "id": "dg86rob", "gilded": 0, "archived": false, "score": -5, "report_reasons": null, "author": "skratlo", "parent_id": "t3_6567xu", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "There are pople building micro-services with HTTP? Who knew.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;There are pople building micro-services with HTTP? Who knew.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg86rob", "score_hidden": false, "stickied": false, "created": 1492144767.0, "created_utc": 1492115967.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": -5}}], "after": null, "before": null}}]