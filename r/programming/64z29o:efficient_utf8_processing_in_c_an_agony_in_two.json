[{"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t3", "data": {"contest_mode": false, "banned_by": null, "media_embed": {}, "subreddit": "programming", "selftext_html": null, "selftext": "", "likes": null, "suggested_sort": null, "user_reports": [], "secure_media": null, "link_flair_text": null, "id": "64z29o", "gilded": 0, "secure_media_embed": {}, "clicked": false, "score": 20, "report_reasons": null, "author": "tkannelid", "saved": false, "mod_reports": [], "name": "t3_64z29o", "subreddit_name_prefixed": "r/programming", "approved_by": null, "over_18": false, "domain": "blog.ikeran.org", "hidden": false, "thumbnail": "", "subreddit_id": "t5_2fwo", "edited": false, "link_flair_css_class": null, "author_flair_css_class": null, "downs": 0, "brand_safe": true, "archived": false, "removal_reason": null, "is_self": false, "hide_score": false, "spoiler": false, "permalink": "/r/programming/comments/64z29o/efficient_utf8_processing_in_c_an_agony_in_two/", "num_reports": null, "locked": false, "stickied": false, "created": 1492041738.0, "url": "https://blog.ikeran.org/?p=284", "author_flair_text": null, "quarantine": false, "title": "Efficient UTF8 processing in C# (an agony in two fits)", "created_utc": 1492012938.0, "distinguished": null, "media": null, "upvote_ratio": 0.68, "num_comments": 14, "visited": false, "subreddit_type": "public", "ups": 20}}], "after": null, "before": null}}, {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_64z29o", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_64z29o", "likes": null, "replies": "", "user_reports": [], "id": "dg65qdz", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "tkannelid", "parent_id": "t1_dg6483u", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "Thanks, fixed!\n\nUsing a `byte*`would have made some things easier. `ArraySegment` exposing its indexer without casting (which would, barring JIT optimizations, allocate) would have done as well. But on the whole, it wasn't necessary.\n\nI'm glad to see that Microsoft is doing something about this. And I'm amused to see that my design is pretty much identical to theirs, though I structured my enumerator implementations a bit differently.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Thanks, fixed!&lt;/p&gt;\n\n&lt;p&gt;Using a &lt;code&gt;byte*&lt;/code&gt;would have made some things easier. &lt;code&gt;ArraySegment&lt;/code&gt; exposing its indexer without casting (which would, barring JIT optimizations, allocate) would have done as well. But on the whole, it wasn&amp;#39;t necessary.&lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;m glad to see that Microsoft is doing something about this. And I&amp;#39;m amused to see that my design is pretty much identical to theirs, though I structured my enumerator implementations a bit differently.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg65qdz", "score_hidden": false, "stickied": false, "created": 1492045030.0, "created_utc": 1492016230.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 3}}], "after": null, "before": null}}, "user_reports": [], "id": "dg6483u", "gilded": 0, "archived": false, "score": 8, "report_reasons": null, "author": "d_kr", "parent_id": "t3_64z29o", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "I'm surprised to see no unsafe code.\nAnd your blog formatting broke `ArraySegment&lt;byte&gt;`\n\nby removing`&lt;byte&gt;` thinking it was an html-tag.\n\nEdit: [.Net](https://github.com/dotnet/corefxlab/tree/c7550e52e93157885dc69fb381bf2f16102a8b0f) is currently working similar APIs:\n\n* **System.Buffers.Primitives** with [Span&lt;T&gt;](https://github.com/dotnet/corefxlab/tree/c7550e52e93157885dc69fb381bf2f16102a8b0f/docs/specs/span.md) and [Memory&lt;T&gt;](https://github.com/dotnet/corefxlab/tree/c7550e52e93157885dc69fb381bf2f16102a8b0f/docs/specs/memory.md)\n*  **System.Text.Primitives** with [System.Text.Encoding.Utf8](https://github.com/dotnet/corefxlab/tree/c7550e52e93157885dc69fb381bf2f16102a8b0f/src/System.Text.Primitives/System/Text/Encoding/Utf8)\n\n", "edited": 1492015569.0, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;m surprised to see no unsafe code.\nAnd your blog formatting broke &lt;code&gt;ArraySegment&amp;lt;byte&amp;gt;&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;by removing&lt;code&gt;&amp;lt;byte&amp;gt;&lt;/code&gt; thinking it was an html-tag.&lt;/p&gt;\n\n&lt;p&gt;Edit: &lt;a href=\"https://github.com/dotnet/corefxlab/tree/c7550e52e93157885dc69fb381bf2f16102a8b0f\"&gt;.Net&lt;/a&gt; is currently working similar APIs:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;System.Buffers.Primitives&lt;/strong&gt; with &lt;a href=\"https://github.com/dotnet/corefxlab/tree/c7550e52e93157885dc69fb381bf2f16102a8b0f/docs/specs/span.md\"&gt;Span&amp;lt;T&amp;gt;&lt;/a&gt; and &lt;a href=\"https://github.com/dotnet/corefxlab/tree/c7550e52e93157885dc69fb381bf2f16102a8b0f/docs/specs/memory.md\"&gt;Memory&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt; &lt;strong&gt;System.Text.Primitives&lt;/strong&gt; with &lt;a href=\"https://github.com/dotnet/corefxlab/tree/c7550e52e93157885dc69fb381bf2f16102a8b0f/src/System.Text.Primitives/System/Text/Encoding/Utf8\"&gt;System.Text.Encoding.Utf8&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg6483u", "score_hidden": false, "stickied": false, "created": 1492043463.0, "created_utc": 1492014663.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 8}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_64z29o", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_64z29o", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_64z29o", "likes": null, "replies": "", "user_reports": [], "id": "dg7bjk4", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "masklinn", "parent_id": "t1_dg72p3e", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "And then you need to add locale support too, for instance I and i don't caseswap to the same characters in all locales as \"dotted i\" and \"dotless i\" are very diffierent letters in Turkish and Azerbaijani (and yield the upper/lower pairs I/\u0131 and \u0130/i).\n\nBut at this point you maybe be better off using an existing Unicode handler (ICU and the like) if you need to perform text processing, hand-rolling it is a never-ending story. Alternatively, just don't try to mangle text.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;And then you need to add locale support too, for instance I and i don&amp;#39;t caseswap to the same characters in all locales as &amp;quot;dotted i&amp;quot; and &amp;quot;dotless i&amp;quot; are very diffierent letters in Turkish and Azerbaijani (and yield the upper/lower pairs I/\u0131 and \u0130/i).&lt;/p&gt;\n\n&lt;p&gt;But at this point you maybe be better off using an existing Unicode handler (ICU and the like) if you need to perform text processing, hand-rolling it is a never-ending story. Alternatively, just don&amp;#39;t try to mangle text.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg7bjk4", "score_hidden": false, "stickied": false, "created": 1492101298.0, "created_utc": 1492072498.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 2}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_64z29o", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_64z29o", "likes": null, "replies": "", "user_reports": [], "id": "dg7bho8", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "masklinn", "parent_id": "t1_dg7835r", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "Yes.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Yes.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg7bho8", "score_hidden": false, "stickied": false, "created": 1492101132.0, "created_utc": 1492072332.0, "depth": 3, "mod_reports": [], "subreddit_type": "public", "ups": 3}}], "after": null, "before": null}}, "user_reports": [], "id": "dg7835r", "gilded": 0, "archived": false, "score": 4, "report_reasons": null, "author": "txdv", "parent_id": "t1_dg72p3e", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "It is a german character, but does it need to get converted to SS?", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;It is a german character, but does it need to get converted to SS?&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg7835r", "score_hidden": false, "stickied": false, "created": 1492092017.0, "created_utc": 1492063217.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 4}}], "after": null, "before": null}}, "user_reports": [], "id": "dg72p3e", "gilded": 0, "archived": false, "score": 6, "report_reasons": null, "author": "oridb", "parent_id": "t1_dg6ej62", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "Also, you can't use one to one mappings for case conversions. Characters like \u00df get converted to SS when uppercased.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Also, you can&amp;#39;t use one to one mappings for case conversions. Characters like \u00df get converted to SS when uppercased.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg72p3e", "score_hidden": false, "stickied": false, "created": 1492082823.0, "created_utc": 1492054023.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 6}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_64z29o", "likes": null, "replies": "", "user_reports": [], "id": "dg8ondz", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "tragicshark", "parent_id": "t1_dg6ej62", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "I think you could write something like this:\n\n    static long ToLower(int character, Language languagecode, int prevCharacter, int nextCharacter) {\n      if (character &lt; 0x10000) {\n        // I think it is currently safe to split on unicode symbols below 2e16 vs above\n        // because there are no special cases right now for those above and no cases where\n        // a case change crosses this boundary\n        switch(character) {\n        case 0x00DF:\n          return 0x10000000000DF;\n          ...\n        case 0x03A3:\n          if (prevCharacter == 0x03A3 || prevCharacter == 0x03C2 || prevCharacter == 0x03C3) return 0x10000000003C2;\n          return 0x10000000003C3;\n          ...\n        case 0x0049:\n          if (languagecode == \"lt\" &amp;&amp; More_Above(nextCharacter)) return 0x2000000690307;\n          break;\n        case 0x0128:\n          if (languagecode == \"lt\") return 0x4006903070303;\n          break;\n          ...\n        case 0x0307:\n          if (prevCharacter == 0x0069 &amp;&amp; (languagecode == \"tr\" || languagecode == \"az\")) return 0;\n          break;\n          ...\n        }\n        // I think BCL returns correct results for every case of unicode &lt; 2e16 that is not special?\n        return 0x1000000000000 | char.ToLowerInvariant((char)character);\n      }\n      switch(character) { // fortunately this switch is pretty small right now \n      ...\n      case 0x01E910: // lowercase for 1E910;ADLAM CAPITAL LETTER NUN;Lu;0;R;;;;;N;;;;1E932;\n        return 0x800000001E932;\n        ...\n      }\n      // made it here: no conversion for this character\n      return 0x8000000000000 | character;\n    }\n\n\nresult is a packed long where high int16 is a flag:\n\n    0: no result       = 0x0 (remove)\n    1: 1 int16 result  = 0x100000000xxxx\n    2: 2 int16 results = 0x20000xxxxyyyy\n    4: 3 int16 results = 0x4xxxxyyyyzzzz\n    8: 1 int32 result  = 0x80000xxxxxxxx\n\nI'd be very tempted to write a program that generated this function. A trick I learned not too long ago was to make things like this instance methods on structs with no fields. Then you can call them with `default(StructType).Method(param1,...)` with minimal overhead and generate them into files on their own somewhere.\n", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I think you could write something like this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;static long ToLower(int character, Language languagecode, int prevCharacter, int nextCharacter) {\n  if (character &amp;lt; 0x10000) {\n    // I think it is currently safe to split on unicode symbols below 2e16 vs above\n    // because there are no special cases right now for those above and no cases where\n    // a case change crosses this boundary\n    switch(character) {\n    case 0x00DF:\n      return 0x10000000000DF;\n      ...\n    case 0x03A3:\n      if (prevCharacter == 0x03A3 || prevCharacter == 0x03C2 || prevCharacter == 0x03C3) return 0x10000000003C2;\n      return 0x10000000003C3;\n      ...\n    case 0x0049:\n      if (languagecode == &amp;quot;lt&amp;quot; &amp;amp;&amp;amp; More_Above(nextCharacter)) return 0x2000000690307;\n      break;\n    case 0x0128:\n      if (languagecode == &amp;quot;lt&amp;quot;) return 0x4006903070303;\n      break;\n      ...\n    case 0x0307:\n      if (prevCharacter == 0x0069 &amp;amp;&amp;amp; (languagecode == &amp;quot;tr&amp;quot; || languagecode == &amp;quot;az&amp;quot;)) return 0;\n      break;\n      ...\n    }\n    // I think BCL returns correct results for every case of unicode &amp;lt; 2e16 that is not special?\n    return 0x1000000000000 | char.ToLowerInvariant((char)character);\n  }\n  switch(character) { // fortunately this switch is pretty small right now \n  ...\n  case 0x01E910: // lowercase for 1E910;ADLAM CAPITAL LETTER NUN;Lu;0;R;;;;;N;;;;1E932;\n    return 0x800000001E932;\n    ...\n  }\n  // made it here: no conversion for this character\n  return 0x8000000000000 | character;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;result is a packed long where high int16 is a flag:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;0: no result       = 0x0 (remove)\n1: 1 int16 result  = 0x100000000xxxx\n2: 2 int16 results = 0x20000xxxxyyyy\n4: 3 int16 results = 0x4xxxxyyyyzzzz\n8: 1 int32 result  = 0x80000xxxxxxxx\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I&amp;#39;d be very tempted to write a program that generated this function. A trick I learned not too long ago was to make things like this instance methods on structs with no fields. Then you can call them with &lt;code&gt;default(StructType).Method(param1,...)&lt;/code&gt; with minimal overhead and generate them into files on their own somewhere.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg8ondz", "score_hidden": false, "stickied": false, "created": 1492168636.0, "created_utc": 1492139836.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg6ej62", "gilded": 0, "archived": false, "score": 7, "report_reasons": null, "author": "tragicshark", "parent_id": "t3_64z29o", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "Interesting. \n\nYour ToLower algorithm is wrong. There are some unicode characters   (anything above `FFFF`) which cannot be represented by a single Utf16 codepoint (`char` data type); for example (C# gets this one wrong with its strings), the hex code point `1E910` with unicode data entry:\n\n    1E910;ADLAM CAPITAL LETTER NUN;Lu;0;R;;;;;N;;;;1E932;\n\nshould lowercase to `1E932`; in js for example:\n\n    \"\\uD83A\\uDD10\".toLowerCase() === \"\\uD83A\\uDD32\"\n\nis true.\n\nC# Utf16 strings are wrong here:\n\n    var s = \"\\uD83A\\uDD10\";\n    var lower = \"\\uD83A\\uDD32\";\n    Console.WriteLine(s.ToLower() == lower);\n    Console.WriteLine(s.ToLower() == s);\n\nwrites \"False\", \"True\"\n\nI believe to implement an algorithm to convert text to lower case you would need to look up each code point in the [SpecialCasing.txt](http://www.unicode.org/Public/9.0.0/ucd/SpecialCasing.txt) file, then fall back to the 14th (2nd last) column of the record in [UnicodeData.txt](http://www.unicode.org/Public/9.0.0/ucd/UnicodeData.txt) and then return the original code point. However if you were going to implement this you should also implement normalization and Default case folding (so you can correctly do case insensitive comparisons).\n\nAlso a minor nit, it would be nice if the datatype was named `Utf8String` instead of `utf8` to match the more broad naming conventions specified by MS.\n\nThere is also some C# language work under consideration here to support [utf8 literals.](https://github.com/dotnet/csharplang/issues/184) ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Interesting. &lt;/p&gt;\n\n&lt;p&gt;Your ToLower algorithm is wrong. There are some unicode characters   (anything above &lt;code&gt;FFFF&lt;/code&gt;) which cannot be represented by a single Utf16 codepoint (&lt;code&gt;char&lt;/code&gt; data type); for example (C# gets this one wrong with its strings), the hex code point &lt;code&gt;1E910&lt;/code&gt; with unicode data entry:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;1E910;ADLAM CAPITAL LETTER NUN;Lu;0;R;;;;;N;;;;1E932;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;should lowercase to &lt;code&gt;1E932&lt;/code&gt;; in js for example:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;&amp;quot;\\uD83A\\uDD10&amp;quot;.toLowerCase() === &amp;quot;\\uD83A\\uDD32&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;is true.&lt;/p&gt;\n\n&lt;p&gt;C# Utf16 strings are wrong here:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;var s = &amp;quot;\\uD83A\\uDD10&amp;quot;;\nvar lower = &amp;quot;\\uD83A\\uDD32&amp;quot;;\nConsole.WriteLine(s.ToLower() == lower);\nConsole.WriteLine(s.ToLower() == s);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;writes &amp;quot;False&amp;quot;, &amp;quot;True&amp;quot;&lt;/p&gt;\n\n&lt;p&gt;I believe to implement an algorithm to convert text to lower case you would need to look up each code point in the &lt;a href=\"http://www.unicode.org/Public/9.0.0/ucd/SpecialCasing.txt\"&gt;SpecialCasing.txt&lt;/a&gt; file, then fall back to the 14th (2nd last) column of the record in &lt;a href=\"http://www.unicode.org/Public/9.0.0/ucd/UnicodeData.txt\"&gt;UnicodeData.txt&lt;/a&gt; and then return the original code point. However if you were going to implement this you should also implement normalization and Default case folding (so you can correctly do case insensitive comparisons).&lt;/p&gt;\n\n&lt;p&gt;Also a minor nit, it would be nice if the datatype was named &lt;code&gt;Utf8String&lt;/code&gt; instead of &lt;code&gt;utf8&lt;/code&gt; to match the more broad naming conventions specified by MS.&lt;/p&gt;\n\n&lt;p&gt;There is also some C# language work under consideration here to support &lt;a href=\"https://github.com/dotnet/csharplang/issues/184\"&gt;utf8 literals.&lt;/a&gt; &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg6ej62", "score_hidden": false, "stickied": false, "created": 1492054015.0, "created_utc": 1492025215.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 7}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_64z29o", "likes": null, "replies": "", "user_reports": [], "id": "dg62mm6", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "tkannelid", "parent_id": "t3_64z29o", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "Direct github link: https://github.com/dhasenan/FastString", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Direct github link: &lt;a href=\"https://github.com/dhasenan/FastString\"&gt;https://github.com/dhasenan/FastString&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg62mm6", "score_hidden": false, "stickied": false, "created": 1492041765.0, "created_utc": 1492012965.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 3}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_64z29o", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_64z29o", "likes": null, "replies": "", "user_reports": [], "id": "dg6kdhd", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "pdp10", "parent_id": "t1_dg6a4dj", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "For most purposes, UTF-8 is more compact.\n", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;For most purposes, UTF-8 is more compact.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg6kdhd", "score_hidden": false, "stickied": false, "created": 1492060115.0, "created_utc": 1492031315.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg6a4dj", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "WideCharr", "parent_id": "t3_64z29o", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "I wrote a zero-allocation string formatting library for largely the same purpose. Still currently UTF-16, but I've been toying with the idea of changing the backing store to UTF-8 instead. https://github.com/MikePopoloski/StringFormatter", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I wrote a zero-allocation string formatting library for largely the same purpose. Still currently UTF-16, but I&amp;#39;ve been toying with the idea of changing the backing store to UTF-8 instead. &lt;a href=\"https://github.com/MikePopoloski/StringFormatter\"&gt;https://github.com/MikePopoloski/StringFormatter&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg6a4dj", "score_hidden": false, "stickied": false, "created": 1492049470.0, "created_utc": 1492020670.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 3}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_64z29o", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_64z29o", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_64z29o", "likes": null, "replies": "", "user_reports": [], "id": "dg78i9v", "gilded": 0, "archived": false, "score": 0, "report_reasons": null, "author": "JavierTheNormal", "parent_id": "t1_dg6xifo", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "Sure, but it's so trivial you can do it yourself with almost zero effort.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Sure, but it&amp;#39;s so trivial you can do it yourself with almost zero effort.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg78i9v", "score_hidden": false, "stickied": false, "created": 1492092984.0, "created_utc": 1492064184.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 0}}], "after": null, "before": null}}, "user_reports": [], "id": "dg6xifo", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "TheMania", "parent_id": "t1_dg6hyo0", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "ArraySegment is a struct though, requiring no additional heap allocations. It should be just as fast and low overhead as equivalent member variables but better encapsulated. ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;ArraySegment is a struct though, requiring no additional heap allocations. It should be just as fast and low overhead as equivalent member variables but better encapsulated. &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg6xifo", "score_hidden": false, "stickied": false, "created": 1492076149.0, "created_utc": 1492047349.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 3}}], "after": null, "before": null}}, "user_reports": [], "id": "dg6hyo0", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "JavierTheNormal", "parent_id": "t3_64z29o", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "How funny, I just did almost the same thing the other week. One small difference is that I chose to reimplement the ArraySegment rather than embed it because it's rather trivial and it's simpler to just use member variables.\n\nC# like Java pushes you toward using many heap allocations. Those aren't free. If you keep in mind what your language is really doing, you can optimize like this.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;How funny, I just did almost the same thing the other week. One small difference is that I chose to reimplement the ArraySegment rather than embed it because it&amp;#39;s rather trivial and it&amp;#39;s simpler to just use member variables.&lt;/p&gt;\n\n&lt;p&gt;C# like Java pushes you toward using many heap allocations. Those aren&amp;#39;t free. If you keep in mind what your language is really doing, you can optimize like this.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dg6hyo0", "score_hidden": false, "stickied": false, "created": 1492057518.0, "created_utc": 1492028718.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}]