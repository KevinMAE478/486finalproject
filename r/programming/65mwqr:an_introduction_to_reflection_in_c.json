[{"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t3", "data": {"contest_mode": false, "banned_by": null, "media_embed": {}, "subreddit": "programming", "selftext_html": null, "selftext": "", "likes": null, "suggested_sort": null, "user_reports": [], "secure_media": null, "link_flair_text": null, "id": "65mwqr", "gilded": 0, "secure_media_embed": {}, "clicked": false, "score": 77, "report_reasons": null, "author": "prinnyerwin", "saved": false, "mod_reports": [], "name": "t3_65mwqr", "subreddit_name_prefixed": "r/programming", "approved_by": null, "over_18": false, "domain": "jackieokay.com", "hidden": false, "thumbnail": "", "subreddit_id": "t5_2fwo", "edited": false, "link_flair_css_class": null, "author_flair_css_class": null, "downs": 0, "brand_safe": true, "archived": false, "removal_reason": null, "is_self": false, "hide_score": false, "spoiler": false, "permalink": "/r/programming/comments/65mwqr/an_introduction_to_reflection_in_c/", "num_reports": null, "locked": false, "stickied": false, "created": 1492338017.0, "url": "http://jackieokay.com/2017/04/13/reflection1.html", "author_flair_text": null, "quarantine": false, "title": "An Introduction to Reflection in C++", "created_utc": 1492309217.0, "distinguished": null, "media": null, "upvote_ratio": 0.85, "num_comments": 15, "visited": false, "subreddit_type": "public", "ups": 77}}], "after": null, "before": null}}, {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_65mwqr", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_65mwqr", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_65mwqr", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_65mwqr", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_65mwqr", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_65mwqr", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_65mwqr", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_65mwqr", "likes": null, "replies": "", "user_reports": [], "id": "dgcih2p", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "Beaverman", "parent_id": "t1_dgc8ux1", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "&gt; you can probably not use annotations on certain results of the application of annotation processing. \n\nThis is what i meant, and I'm pretty curious if that is actually possible, although not curious enough to fire up a project. It seems according to the [documentation](https://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html) that you can actually process the result of a process. So writing class files with annotations that feed into another processor seems possible.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;blockquote&gt;\n&lt;p&gt;you can probably not use annotations on certain results of the application of annotation processing. &lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;This is what i meant, and I&amp;#39;m pretty curious if that is actually possible, although not curious enough to fire up a project. It seems according to the &lt;a href=\"https://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html\"&gt;documentation&lt;/a&gt; that you can actually process the result of a process. So writing class files with annotations that feed into another processor seems possible.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dgcih2p", "score_hidden": false, "stickied": false, "created": 1492402623.0, "created_utc": 1492373823.0, "depth": 7, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dgc8ux1", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "valenterry", "parent_id": "t1_dgc6xb8", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "&gt; But the Java example sounds completely equivalent to his example of D.\n\nThat's probably how it is. I don't know D which is why I asked /u/Tipaa to explain it in more detail in my other comment. But if D is able to represent the structure of a class in a generic way at compile time within the language than this is much more powerful than annotation (pre)processing. It also doesn't matter how the annotation processor works exactly - to understand what the code does you *need* to know how the annotations are processed and what code gets generated.\n\nAs for the annotations: I don't think you can do that, i.e. you cannot annotate annotations themself (except for predefined meta annotations), you cannot use annotations within annotations and you can probably not use annotations on certain results of the application of annotation processing. ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;blockquote&gt;\n&lt;p&gt;But the Java example sounds completely equivalent to his example of D.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;That&amp;#39;s probably how it is. I don&amp;#39;t know D which is why I asked &lt;a href=\"/u/Tipaa\"&gt;/u/Tipaa&lt;/a&gt; to explain it in more detail in my other comment. But if D is able to represent the structure of a class in a generic way at compile time within the language than this is much more powerful than annotation (pre)processing. It also doesn&amp;#39;t matter how the annotation processor works exactly - to understand what the code does you &lt;em&gt;need&lt;/em&gt; to know how the annotations are processed and what code gets generated.&lt;/p&gt;\n\n&lt;p&gt;As for the annotations: I don&amp;#39;t think you can do that, i.e. you cannot annotate annotations themself (except for predefined meta annotations), you cannot use annotations within annotations and you can probably not use annotations on certain results of the application of annotation processing. &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dgc8ux1", "score_hidden": false, "stickied": false, "created": 1492389975.0, "created_utc": 1492361175.0, "depth": 6, "mod_reports": [], "subreddit_type": "public", "ups": 2}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_65mwqr", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_65mwqr", "likes": null, "replies": "", "user_reports": [], "id": "dgcif9z", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "Beaverman", "parent_id": "t1_dgcfu0n", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "To summarize it from my perspective, as a person who doesn't know D, it seems to come down to what it always does with Java. Java usually has some functionality to do what you want, but it's very verbose, heavy-weight, and high friction. Java meta-programming is powerful, but it's far from elegant.\n\nI don't think it can be argued that annotation processors are easier than what you wrote above.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;To summarize it from my perspective, as a person who doesn&amp;#39;t know D, it seems to come down to what it always does with Java. Java usually has some functionality to do what you want, but it&amp;#39;s very verbose, heavy-weight, and high friction. Java meta-programming is powerful, but it&amp;#39;s far from elegant.&lt;/p&gt;\n\n&lt;p&gt;I don&amp;#39;t think it can be argued that annotation processors are easier than what you wrote above.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dgcif9z", "score_hidden": false, "stickied": false, "created": 1492402560.0, "created_utc": 1492373760.0, "depth": 7, "mod_reports": [], "subreddit_type": "public", "ups": 2}}], "after": null, "before": null}}, "user_reports": [], "id": "dgcfu0n", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "Tipaa", "parent_id": "t1_dgc6xb8", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "I've just had a dive into Java annotation processing [(using this link)]    (http://hannesdorfmann.com/annotation-processing/annotationprocessing101) in order to better make a comparison.\n\n* Java annotation processors are loaded by the compiler as pre-compiled plugins via the .jar file, while D introspection isn't loaded as a separate program but runs during standard code generation, more akin to how Java generics are during compilation (ignoring the generic/template divide). This allows D metaprogramming to affect/inspect itself easily, while bootstrapping a Java annotation processor appears harder.\n\n* Java requires declaring annotations where metaprogramming is wanted, while D does not. D allows annotations, but doesn't need them.\n\n* Java metaprogramming is more powerful than I expected/remembered, but damn is it verbose thanks to its compiler plugin model.\n\nI'd argue that overall, D is more powerful because its introspection and code-generation is first-class, rather than requiring a compiler plugin per code introspector or generator.\n\nDo demonstrate some of the differences, I tried implementing the same factory in D (type-safe generic factories, and it came out much shorter and didn't require any compiler pluginning:\n\n    module example;\n    import std.stdio, std.traits, std.meta;\n\n    template Factory(Base)\n    {\n        struct Factory(alias T) if(staticIndexOf!(Base, BaseClassesTuple!T) &gt; -1)\n        { string fname; auto make(){return new T();} }\n    }\n\n    auto makeWith(alias Factory)(string name)\n    {\n    \tforeach(udas; getSymbolsByUDA!(example, Factory))\n    \t{\n            foreach(uda; getUDAs!(udas, Factory))\n            {\n                if(name == uda.fname) return uda.make();\n            }\n    \t}\n    \treturn null;\n    }\n\n    alias PizzaFactory = Factory!Pizza;\n\n    abstract class Pizza\n    {\n    \tabstract string name();\n    \tabstract float price();\n    }\n\n    @PizzaFactory!Margherita(\"Margherita\")\n    class Margherita : Pizza\n    {\n    \toverride string name() { return \"Margherita\"; }\n    \toverride float price() { return 3.5f; }\n    }\n\n    alias makePizza = makeWith!PizzaFactory;\n\n    void main()\n    {\n        //Writes 'example.Margherita'\n    \twriteln(makePizza(\"Margherita\"));\n    }\n\nYou can play with this [here](https://dpaste.dzfl.pl/c90b91e556f7)", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;ve just had a dive into Java annotation processing &lt;a href=\"http://hannesdorfmann.com/annotation-processing/annotationprocessing101\"&gt;(using this link)&lt;/a&gt; in order to better make a comparison.&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;Java annotation processors are loaded by the compiler as pre-compiled plugins via the .jar file, while D introspection isn&amp;#39;t loaded as a separate program but runs during standard code generation, more akin to how Java generics are during compilation (ignoring the generic/template divide). This allows D metaprogramming to affect/inspect itself easily, while bootstrapping a Java annotation processor appears harder.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Java requires declaring annotations where metaprogramming is wanted, while D does not. D allows annotations, but doesn&amp;#39;t need them.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Java metaprogramming is more powerful than I expected/remembered, but damn is it verbose thanks to its compiler plugin model.&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;I&amp;#39;d argue that overall, D is more powerful because its introspection and code-generation is first-class, rather than requiring a compiler plugin per code introspector or generator.&lt;/p&gt;\n\n&lt;p&gt;Do demonstrate some of the differences, I tried implementing the same factory in D (type-safe generic factories, and it came out much shorter and didn&amp;#39;t require any compiler pluginning:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;module example;\nimport std.stdio, std.traits, std.meta;\n\ntemplate Factory(Base)\n{\n    struct Factory(alias T) if(staticIndexOf!(Base, BaseClassesTuple!T) &amp;gt; -1)\n    { string fname; auto make(){return new T();} }\n}\n\nauto makeWith(alias Factory)(string name)\n{\n    foreach(udas; getSymbolsByUDA!(example, Factory))\n    {\n        foreach(uda; getUDAs!(udas, Factory))\n        {\n            if(name == uda.fname) return uda.make();\n        }\n    }\n    return null;\n}\n\nalias PizzaFactory = Factory!Pizza;\n\nabstract class Pizza\n{\n    abstract string name();\n    abstract float price();\n}\n\n@PizzaFactory!Margherita(&amp;quot;Margherita&amp;quot;)\nclass Margherita : Pizza\n{\n    override string name() { return &amp;quot;Margherita&amp;quot;; }\n    override float price() { return 3.5f; }\n}\n\nalias makePizza = makeWith!PizzaFactory;\n\nvoid main()\n{\n    //Writes &amp;#39;example.Margherita&amp;#39;\n    writeln(makePizza(&amp;quot;Margherita&amp;quot;));\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You can play with this &lt;a href=\"https://dpaste.dzfl.pl/c90b91e556f7\"&gt;here&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dgcfu0n", "score_hidden": false, "stickied": false, "created": 1492399196.0, "created_utc": 1492370396.0, "depth": 6, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dgc6xb8", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "Beaverman", "parent_id": "t1_dgc2hwx", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "But the Java example sounds completely equivalent to his example of D. You get some type, and you generate code for it, like maybe a builder or a serializer. I'm just pointing out that Java has its own novel solution to the problem. I'd also like to point out that the annotation processor is written in Java. So no, you don't need to know anything besides Java.\n\nI don't think there's anything stopping you from generating annotations that another annotation processor can then generate more code from. Although I have never done it, and quite frankly don't know.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;But the Java example sounds completely equivalent to his example of D. You get some type, and you generate code for it, like maybe a builder or a serializer. I&amp;#39;m just pointing out that Java has its own novel solution to the problem. I&amp;#39;d also like to point out that the annotation processor is written in Java. So no, you don&amp;#39;t need to know anything besides Java.&lt;/p&gt;\n\n&lt;p&gt;I don&amp;#39;t think there&amp;#39;s anything stopping you from generating annotations that another annotation processor can then generate more code from. Although I have never done it, and quite frankly don&amp;#39;t know.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dgc6xb8", "score_hidden": false, "stickied": false, "created": 1492387398.0, "created_utc": 1492358598.0, "depth": 5, "mod_reports": [], "subreddit_type": "public", "ups": 2}}], "after": null, "before": null}}, "user_reports": [], "id": "dgc2hwx", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "valenterry", "parent_id": "t1_dgbz1cc", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "This is not the same. First, we are not talking about Java anymore, we need additional tooling. This is in fact just a new language transpiling to java code (or using an extended javac). This is different to having such a feature directly in the language because if you change the language via annotiations, you now need more knowledge than how Java works. Also it doesn't compose. Say someone has written a library that generates classes (by using annotations). You have written a library that serializes classes (by annotating them). This does not compose because you obviously cannot annotate the generated classes to seriazlize them. If those features are language built in, they compose. However, designing a programing language to be able to do that is quite hard and still researched. Some languages (e.g. Scala, Idris, F\\*) are able do it already, some for the better some for the worse. It is a way different beast compared to runtime reflection though - both for the language designers *and* the developers.", "edited": 1492360600.0, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;This is not the same. First, we are not talking about Java anymore, we need additional tooling. This is in fact just a new language transpiling to java code (or using an extended javac). This is different to having such a feature directly in the language because if you change the language via annotiations, you now need more knowledge than how Java works. Also it doesn&amp;#39;t compose. Say someone has written a library that generates classes (by using annotations). You have written a library that serializes classes (by annotating them). This does not compose because you obviously cannot annotate the generated classes to seriazlize them. If those features are language built in, they compose. However, designing a programing language to be able to do that is quite hard and still researched. Some languages (e.g. Scala, Idris, F*) are able do it already, some for the better some for the worse. It is a way different beast compared to runtime reflection though - both for the language designers &lt;em&gt;and&lt;/em&gt; the developers.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dgc2hwx", "score_hidden": false, "stickied": false, "created": 1492380981.0, "created_utc": 1492352181.0, "depth": 4, "mod_reports": [], "subreddit_type": "public", "ups": 3}}], "after": null, "before": null}}, "user_reports": [], "id": "dgbz1cc", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "Beaverman", "parent_id": "t1_dgbuc8u", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "Java \"Reflection\" at compile time can be done using annotation processors, although it requires outputting valid java code manually. It does allow you to insert extra stages into the default javac compiler (since java 6)", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Java &amp;quot;Reflection&amp;quot; at compile time can be done using annotation processors, although it requires outputting valid java code manually. It does allow you to insert extra stages into the default javac compiler (since java 6)&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dgbz1cc", "score_hidden": false, "stickied": false, "created": 1492374126.0, "created_utc": 1492345326.0, "depth": 3, "mod_reports": [], "subreddit_type": "public", "ups": 3}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_65mwqr", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_65mwqr", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_65mwqr", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_65mwqr", "likes": null, "replies": "", "user_reports": [], "id": "dgchp0h", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "Tipaa", "parent_id": "t1_dgce50o", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "`__traits(getMember, val, fieldname)` evaluates to `val.fieldname`, but allows `fieldname` to be a string or a symbol rather than having to convert the string of the name back to code representing the name. So in `S`, `__traits(getMember, val, \"i\")` evaluates to `val.i`, meaning that `typeof(__traits(getMember, val, \"i\"))` is `int`.\n\nStruct reversal is certainly possible - the easiest way I found was to use the `mixin(\"valid codestring;\")` feature:\n\n    //Struct with member order reversed\n    struct ReverseStruct(T)\n    {\n        //Immediately evaluating function to build the member list\n        mixin(()\n        {\n            string codegen = \"\";\n            //AliasSeq (alias sequence) of types in T, reversed\n            alias types = Reverse!(Fields!T);\n\n            //AliasSeq of names of the fields reversed\n            foreach(i, fieldname; Reverse!(FieldNameTuple!T))\n            {\n                //e.g. codegen ~= \"int\" ~ \" \" ~ \"first\" ~\";\" ; (== \"int first;\")\n                codegen ~= types[i].stringof ~ \" \" ~ fieldname~\";\" ;\n            }\n            return codegen;\n        }());\n    }\n\n    //Create a ReverseStruct!T from any T value, then copy all members to it\n    auto reverseStruct(T)(const T val)\n    {\n        ReverseStruct!T ret;\n        foreach(fieldname; FieldNameTuple!T)\n        {\n            __traits(getMember, ret, fieldname) = __traits(getMember, val, fieldname);\n        }\n        return ret;\n    }\n\nThis all works fine out-the-box for `pprint`, too.\n", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;&lt;code&gt;__traits(getMember, val, fieldname)&lt;/code&gt; evaluates to &lt;code&gt;val.fieldname&lt;/code&gt;, but allows &lt;code&gt;fieldname&lt;/code&gt; to be a string or a symbol rather than having to convert the string of the name back to code representing the name. So in &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;__traits(getMember, val, &amp;quot;i&amp;quot;)&lt;/code&gt; evaluates to &lt;code&gt;val.i&lt;/code&gt;, meaning that &lt;code&gt;typeof(__traits(getMember, val, &amp;quot;i&amp;quot;))&lt;/code&gt; is &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;Struct reversal is certainly possible - the easiest way I found was to use the &lt;code&gt;mixin(&amp;quot;valid codestring;&amp;quot;)&lt;/code&gt; feature:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;//Struct with member order reversed\nstruct ReverseStruct(T)\n{\n    //Immediately evaluating function to build the member list\n    mixin(()\n    {\n        string codegen = &amp;quot;&amp;quot;;\n        //AliasSeq (alias sequence) of types in T, reversed\n        alias types = Reverse!(Fields!T);\n\n        //AliasSeq of names of the fields reversed\n        foreach(i, fieldname; Reverse!(FieldNameTuple!T))\n        {\n            //e.g. codegen ~= &amp;quot;int&amp;quot; ~ &amp;quot; &amp;quot; ~ &amp;quot;first&amp;quot; ~&amp;quot;;&amp;quot; ; (== &amp;quot;int first;&amp;quot;)\n            codegen ~= types[i].stringof ~ &amp;quot; &amp;quot; ~ fieldname~&amp;quot;;&amp;quot; ;\n        }\n        return codegen;\n    }());\n}\n\n//Create a ReverseStruct!T from any T value, then copy all members to it\nauto reverseStruct(T)(const T val)\n{\n    ReverseStruct!T ret;\n    foreach(fieldname; FieldNameTuple!T)\n    {\n        __traits(getMember, ret, fieldname) = __traits(getMember, val, fieldname);\n    }\n    return ret;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This all works fine out-the-box for &lt;code&gt;pprint&lt;/code&gt;, too.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dgchp0h", "score_hidden": false, "stickied": false, "created": 1492401629.0, "created_utc": 1492372829.0, "depth": 6, "mod_reports": [], "subreddit_type": "public", "ups": 2}}], "after": null, "before": null}}, "user_reports": [], "id": "dgce50o", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "valenterry", "parent_id": "t1_dgccwd8", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "In advance: I'm not that familiar with low level programming, so please bear with me. :)\n\nThe most interesting part for me it the `static if`. If I understand correctly, your `pprint` receives something of type `T` and decides at compiletime how to handle the `T`, depending on what it is. This is really cool!\n\nI don't fully understand what `__traits(getMember, val, fieldname)` evaluates to. In `S` it would obviously be `int i` and then `long l` but what exactly is the type of that? It needs to contain the fieldname and its typed value so that `pprint` can write something like `{i: 42}`. Or how would the output look for `pprint(S(41, 42))`?\n\nAlso I wonder: when I have a `struct X{ int first; string second }` - can I somehow write a compile-time unction in the style of `pprint` that gives me a new struct (or some representation of a struct) where the order of the members is reversed? Like `struct XReversed{ string second; int first }`. And can I than feed this new struct somehow into `pprint`?\n\nSomething in the lines of\n\n    void pprint(T)( ... \n    void reverseStruct(T)( ...\n    struct X{ int first; string second }\n    \n    void main()\n    {\n        X xnormal = X(42, \"hi\");\n        pprint(reverseStruct(xnormal))\n    }\n     \nThis `reverseStruct` should then work for any kind of struct, no matter how it looks like. Is that possible at compiletime? I hope it is not, because of it is I will need to spent some valuable time to take a closer look at D!", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;In advance: I&amp;#39;m not that familiar with low level programming, so please bear with me. :)&lt;/p&gt;\n\n&lt;p&gt;The most interesting part for me it the &lt;code&gt;static if&lt;/code&gt;. If I understand correctly, your &lt;code&gt;pprint&lt;/code&gt; receives something of type &lt;code&gt;T&lt;/code&gt; and decides at compiletime how to handle the &lt;code&gt;T&lt;/code&gt;, depending on what it is. This is really cool!&lt;/p&gt;\n\n&lt;p&gt;I don&amp;#39;t fully understand what &lt;code&gt;__traits(getMember, val, fieldname)&lt;/code&gt; evaluates to. In &lt;code&gt;S&lt;/code&gt; it would obviously be &lt;code&gt;int i&lt;/code&gt; and then &lt;code&gt;long l&lt;/code&gt; but what exactly is the type of that? It needs to contain the fieldname and its typed value so that &lt;code&gt;pprint&lt;/code&gt; can write something like &lt;code&gt;{i: 42}&lt;/code&gt;. Or how would the output look for &lt;code&gt;pprint(S(41, 42))&lt;/code&gt;?&lt;/p&gt;\n\n&lt;p&gt;Also I wonder: when I have a &lt;code&gt;struct X{ int first; string second }&lt;/code&gt; - can I somehow write a compile-time unction in the style of &lt;code&gt;pprint&lt;/code&gt; that gives me a new struct (or some representation of a struct) where the order of the members is reversed? Like &lt;code&gt;struct XReversed{ string second; int first }&lt;/code&gt;. And can I than feed this new struct somehow into &lt;code&gt;pprint&lt;/code&gt;?&lt;/p&gt;\n\n&lt;p&gt;Something in the lines of&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;void pprint(T)( ... \nvoid reverseStruct(T)( ...\nstruct X{ int first; string second }\n\nvoid main()\n{\n    X xnormal = X(42, &amp;quot;hi&amp;quot;);\n    pprint(reverseStruct(xnormal))\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This &lt;code&gt;reverseStruct&lt;/code&gt; should then work for any kind of struct, no matter how it looks like. Is that possible at compiletime? I hope it is not, because of it is I will need to spent some valuable time to take a closer look at D!&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dgce50o", "score_hidden": false, "stickied": false, "created": 1492396942.0, "created_utc": 1492368142.0, "depth": 5, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dgccwd8", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "Tipaa", "parent_id": "t1_dgc29mz", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "Yep, that's an easy case for D to fulfil - I've used it to write a completely generic no-allocation JSON serialiser in 6 hours for a hackathon before. D also lets you go low-level enough to handle bytes manually, if you so wish.\n\nHere's an example I whipped up to show both low-level compile-time generic buffer read/writing using pointers and T.sizeof, and a higher-level pretty print function using traits.\n\n    import std.stdio, std.traits;\n\n    void writeVal(T)(ref byte[] buf, const T t)\n    {\n    \tbuf ~= (cast(ubyte*)&amp;t)[0..T.sizeof];\n    }\n\n    void readVal(T)(ref T val, ref byte[] buf)\n    {\n    \tval = *(cast(T*)buf.ptr);\n    \tbuf = buf[T.sizeof..$];\n    }\n\n    void pprint(T)(const T val)\n    {\n    \twrite(T.stringof, \": \");\n        //Compile-time if statement\n    \tstatic if(is(T==struct)||is(T==class))\n    \t{\n    \t\twrite(\"{\");\n    \t\t//FieldNameTuple from std.traits\n    \t\tforeach(fieldname; FieldNameTuple!T)\n    \t\t{\n    \t\t\t//__traits() for language-defined traits\n    \t\t\t//equivalent to mixin(\"val.\" ~ fieldname), but cleaner\n    \t\t\tpprint(__traits(getMember, val, fieldname));\n    \t\t\twrite(\", \");\t   \n    \t\t}\n    \t\twrite(\"}\");\n    \t}\n    \telse\n    \t{\n    \t\twrite(val);\n    \t}\n    }\n\n    struct S { int i; long l; }\n    struct S2 { S s1, s2; string name; }\n\n    void main()\n    {\n    \tS s1 = { 7, -193 }, s2;\n    \tbyte[] buf = [];\n        //Calls writeVal(buf, 4), inferring type arg T=int\n    \tbuf.writeVal(cast(int)4);\n    \tbuf.writeVal(s1);\n    \t\n    \tint four;\n        //Calls readVal(four, buf), inferring type arg T=int\n    \tfour.readVal(buf);\n    \ts2.readVal(buf);\n    \tassert(buf.length == 0);\n    \tassert(four == 4);\n    \tassert(s2 == s1);\n    \t\n    \tpprint(S2(s1, s2, \"pre and post serialization\"));\n    }", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Yep, that&amp;#39;s an easy case for D to fulfil - I&amp;#39;ve used it to write a completely generic no-allocation JSON serialiser in 6 hours for a hackathon before. D also lets you go low-level enough to handle bytes manually, if you so wish.&lt;/p&gt;\n\n&lt;p&gt;Here&amp;#39;s an example I whipped up to show both low-level compile-time generic buffer read/writing using pointers and T.sizeof, and a higher-level pretty print function using traits.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;import std.stdio, std.traits;\n\nvoid writeVal(T)(ref byte[] buf, const T t)\n{\n    buf ~= (cast(ubyte*)&amp;amp;t)[0..T.sizeof];\n}\n\nvoid readVal(T)(ref T val, ref byte[] buf)\n{\n    val = *(cast(T*)buf.ptr);\n    buf = buf[T.sizeof..$];\n}\n\nvoid pprint(T)(const T val)\n{\n    write(T.stringof, &amp;quot;: &amp;quot;);\n    //Compile-time if statement\n    static if(is(T==struct)||is(T==class))\n    {\n        write(&amp;quot;{&amp;quot;);\n        //FieldNameTuple from std.traits\n        foreach(fieldname; FieldNameTuple!T)\n        {\n            //__traits() for language-defined traits\n            //equivalent to mixin(&amp;quot;val.&amp;quot; ~ fieldname), but cleaner\n            pprint(__traits(getMember, val, fieldname));\n            write(&amp;quot;, &amp;quot;);       \n        }\n        write(&amp;quot;}&amp;quot;);\n    }\n    else\n    {\n        write(val);\n    }\n}\n\nstruct S { int i; long l; }\nstruct S2 { S s1, s2; string name; }\n\nvoid main()\n{\n    S s1 = { 7, -193 }, s2;\n    byte[] buf = [];\n    //Calls writeVal(buf, 4), inferring type arg T=int\n    buf.writeVal(cast(int)4);\n    buf.writeVal(s1);\n\n    int four;\n    //Calls readVal(four, buf), inferring type arg T=int\n    four.readVal(buf);\n    s2.readVal(buf);\n    assert(buf.length == 0);\n    assert(four == 4);\n    assert(s2 == s1);\n\n    pprint(S2(s1, s2, &amp;quot;pre and post serialization&amp;quot;));\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dgccwd8", "score_hidden": false, "stickied": false, "created": 1492395267.0, "created_utc": 1492366467.0, "depth": 4, "mod_reports": [], "subreddit_type": "public", "ups": 2}}], "after": null, "before": null}}, "user_reports": [], "id": "dgc29mz", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "valenterry", "parent_id": "t1_dgbuc8u", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "&gt; The templates are given some type T, so they can then iterate over all of its fields by name and type, generating the appropriate code for each field's serialisation. Here's some of the stuff the language can introspect during compilation.\n\nIs D able to represent classes in a generic and typesafe way so that I can implement a serialization function that expects to get some generic class type and makes it able to serialize it at compiletime? This is different to metaprogramming as it can be reused (while metaprogramming does not compose). Would be interesting to know if this is already possible with D, because I think it is much much better than runtime reflection. ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;blockquote&gt;\n&lt;p&gt;The templates are given some type T, so they can then iterate over all of its fields by name and type, generating the appropriate code for each field&amp;#39;s serialisation. Here&amp;#39;s some of the stuff the language can introspect during compilation.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Is D able to represent classes in a generic and typesafe way so that I can implement a serialization function that expects to get some generic class type and makes it able to serialize it at compiletime? This is different to metaprogramming as it can be reused (while metaprogramming does not compose). Would be interesting to know if this is already possible with D, because I think it is much much better than runtime reflection. &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dgc29mz", "score_hidden": false, "stickied": false, "created": 1492380604.0, "created_utc": 1492351804.0, "depth": 3, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dgbuc8u", "gilded": 0, "archived": false, "score": 6, "report_reasons": null, "author": "Tipaa", "parent_id": "t1_dgbtxkh", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "D has great compile-time introspection capabilities (possibly best in class), as well as expressive templates and clean code generation with CTFE. For example, there's the [cerealed](https://github.com/atilaneves/cerealed) library, which uses templates and compile-time introspection to generate code for automatic serialisation of any type you give it, giving zero-cost abstraction. The templates are given some type `T`, so they can then iterate over all of its fields by name and type, generating the appropriate code for each field's serialisation. [Here's](https://dlang.org/phobos/std_traits.html) some of the stuff the language can introspect during compilation.\n\nRuntime reflection in D is fairly simple too, although it isn't the main show. EDIT: I've just seen witchcraft and you're right, it's very similar to the Java/C# reflection. However, I don't think it's the most common type of reflection you'll find in D, as the compile-time stuff is just as good (if not better - first-class type lookups etc.) for most things.\n\nThis contrasts with the Java and C# style reflection, where all reflection is performed at runtime (requiring a VM and putting a large overhead in), and code generation (at least in Java) requires bytecode manipulation. I think D's model is closest to what C++ should be aiming for, as it doesn't need runtime support (all of my reflection code is compile-time) and gives the most power to the programmer (the closest alternative that I know is Rust, which has nice AST macros for its compile-time reflection/generation. Sadly, I think C++ may be too big AST-wise for AST macros now).", "edited": 1492330527.0, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;D has great compile-time introspection capabilities (possibly best in class), as well as expressive templates and clean code generation with CTFE. For example, there&amp;#39;s the &lt;a href=\"https://github.com/atilaneves/cerealed\"&gt;cerealed&lt;/a&gt; library, which uses templates and compile-time introspection to generate code for automatic serialisation of any type you give it, giving zero-cost abstraction. The templates are given some type &lt;code&gt;T&lt;/code&gt;, so they can then iterate over all of its fields by name and type, generating the appropriate code for each field&amp;#39;s serialisation. &lt;a href=\"https://dlang.org/phobos/std_traits.html\"&gt;Here&amp;#39;s&lt;/a&gt; some of the stuff the language can introspect during compilation.&lt;/p&gt;\n\n&lt;p&gt;Runtime reflection in D is fairly simple too, although it isn&amp;#39;t the main show. EDIT: I&amp;#39;ve just seen witchcraft and you&amp;#39;re right, it&amp;#39;s very similar to the Java/C# reflection. However, I don&amp;#39;t think it&amp;#39;s the most common type of reflection you&amp;#39;ll find in D, as the compile-time stuff is just as good (if not better - first-class type lookups etc.) for most things.&lt;/p&gt;\n\n&lt;p&gt;This contrasts with the Java and C# style reflection, where all reflection is performed at runtime (requiring a VM and putting a large overhead in), and code generation (at least in Java) requires bytecode manipulation. I think D&amp;#39;s model is closest to what C++ should be aiming for, as it doesn&amp;#39;t need runtime support (all of my reflection code is compile-time) and gives the most power to the programmer (the closest alternative that I know is Rust, which has nice AST macros for its compile-time reflection/generation. Sadly, I think C++ may be too big AST-wise for AST macros now).&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dgbuc8u", "score_hidden": false, "stickied": false, "created": 1492359103.0, "created_utc": 1492330303.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 6}}], "after": null, "before": null}}, "user_reports": [], "id": "dgbtxkh", "gilded": 0, "archived": false, "score": 5, "report_reasons": null, "author": "tuwtuwtuw", "parent_id": "t1_dgbl03h", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "I did a quick Google but mostly found recommendations for people to use 3rd party stuff such as \"witchcraft\" and that looked quite similar to what is built-in in C#.\n\nI'm sure I'm missing something. What?", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I did a quick Google but mostly found recommendations for people to use 3rd party stuff such as &amp;quot;witchcraft&amp;quot; and that looked quite similar to what is built-in in C#.&lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;m sure I&amp;#39;m missing something. What?&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dgbtxkh", "score_hidden": false, "stickied": false, "created": 1492357842.0, "created_utc": 1492329042.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 5}}], "after": null, "before": null}}, "user_reports": [], "id": "dgbl03h", "gilded": 0, "archived": false, "score": 6, "report_reasons": null, "author": "Tipaa", "parent_id": "t3_65mwqr", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "I'm surprised that this didn't mention the reflection/introspection/metaprogramming ability of D in its comparison with other languages. I think it's the pinnacle of reflection from the languages I've looked at or tried reflection in (I'm yet to play with Idris' `Elab` reflection though).\n\n", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;m surprised that this didn&amp;#39;t mention the reflection/introspection/metaprogramming ability of D in its comparison with other languages. I think it&amp;#39;s the pinnacle of reflection from the languages I&amp;#39;ve looked at or tried reflection in (I&amp;#39;m yet to play with Idris&amp;#39; &lt;code&gt;Elab&lt;/code&gt; reflection though).&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dgbl03h", "score_hidden": false, "stickied": false, "created": 1492340174.0, "created_utc": 1492311374.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 6}}, {"kind": "t1", "data": {"subreddit_id": "t5_2fwo", "removal_reason": null, "link_id": "t3_65mwqr", "likes": null, "replies": "", "user_reports": [], "id": "dgbxznq", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "irqlnotdispatchlevel", "parent_id": "t3_65mwqr", "subreddit_name_prefixed": "r/programming", "controversiality": 0, "body": "This was awesome. ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;This was awesome. &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "programming", "name": "t1_dgbxznq", "score_hidden": false, "stickied": false, "created": 1492371280.0, "created_utc": 1492342480.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}]