[{"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t3", "data": {"contest_mode": false, "banned_by": null, "media_embed": {}, "subreddit": "compsci", "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;What I mean is, if you try to memcopy a linked list (for example), is there a function which will follow all of the pointers, allocate the proper memory for what they point to, and copy those things? All in one &amp;quot;memcopy_r&amp;quot; kind of thing? If not, would anyone be interested in it if i developed a library to do so?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "selftext": "What I mean is, if you try to memcopy a linked list (for example), is there a function which will follow all of the pointers, allocate the proper memory for what they point to, and copy those things? All in one \"memcopy_r\" kind of thing? If not, would anyone be interested in it if i developed a library to do so?", "likes": null, "suggested_sort": null, "user_reports": [], "secure_media": null, "link_flair_text": null, "id": "655orz", "gilded": 0, "secure_media_embed": {}, "clicked": false, "score": 23, "report_reasons": null, "author": "Fizzlerr", "saved": false, "mod_reports": [], "name": "t3_655orz", "subreddit_name_prefixed": "r/compsci", "approved_by": null, "over_18": false, "domain": "self.compsci", "hidden": false, "thumbnail": "self", "subreddit_id": "t5_2qhmr", "edited": false, "link_flair_css_class": null, "author_flair_css_class": null, "downs": 0, "brand_safe": true, "archived": false, "removal_reason": null, "is_self": true, "hide_score": false, "spoiler": false, "permalink": "/r/compsci/comments/655orz/is_there_a_kind_of_recursive_memcopy_for_c_c_cuda/", "num_reports": null, "locked": false, "stickied": false, "created": 1492121313.0, "url": "https://www.reddit.com/r/compsci/comments/655orz/is_there_a_kind_of_recursive_memcopy_for_c_c_cuda/", "author_flair_text": null, "quarantine": false, "title": "Is there a kind of \"recursive\" memcopy for c/ c++ / cuda?", "created_utc": 1492092513.0, "distinguished": null, "media": null, "upvote_ratio": 0.73, "num_comments": 24, "visited": false, "subreddit_type": "public", "ups": 23}}], "after": null, "before": null}}, {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qhmr", "removal_reason": null, "link_id": "t3_655orz", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qhmr", "removal_reason": null, "link_id": "t3_655orz", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qhmr", "removal_reason": null, "link_id": "t3_655orz", "likes": null, "replies": "", "user_reports": [], "id": "dg7susc", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "lneutral", "parent_id": "t1_dg7qcuk", "subreddit_name_prefixed": "r/compsci", "controversiality": 0, "body": "Okay, fair point - there are copy constructors that alias shared memory, and so forth.\n\nPoint being: The general assumption with a copy constructor in many cases (arguably, most cases) is that a deep copy is performed - usually obviating the need for an explicit copy.\n\nMany, many libraries prefer aliasing - OpenCV comes to mind - but usually provide deep copies via some other member function, rather than expecting you to figure it out yourself.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Okay, fair point - there are copy constructors that alias shared memory, and so forth.&lt;/p&gt;\n\n&lt;p&gt;Point being: The general assumption with a copy constructor in many cases (arguably, most cases) is that a deep copy is performed - usually obviating the need for an explicit copy.&lt;/p&gt;\n\n&lt;p&gt;Many, many libraries prefer aliasing - OpenCV comes to mind - but usually provide deep copies via some other member function, rather than expecting you to figure it out yourself.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "compsci", "name": "t1_dg7susc", "score_hidden": false, "stickied": false, "created": 1492129765.0, "created_utc": 1492100965.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 3}}], "after": null, "before": null}}, "user_reports": [], "id": "dg7qcuk", "gilded": 0, "archived": false, "score": 26, "report_reasons": null, "author": "other_other_self", "parent_id": "t1_dg7owzs", "subreddit_name_prefixed": "r/compsci", "controversiality": 0, "body": "Copy constructors don't *always* do this; user-defined ones can have arbitrary custom behavior. The correct term is \"deep copy.\"", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Copy constructors don&amp;#39;t &lt;em&gt;always&lt;/em&gt; do this; user-defined ones can have arbitrary custom behavior. The correct term is &amp;quot;deep copy.&amp;quot;&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "compsci", "name": "t1_dg7qcuk", "score_hidden": false, "stickied": false, "created": 1492127113.0, "created_utc": 1492098313.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 26}}], "after": null, "before": null}}, "user_reports": [], "id": "dg7owzs", "gilded": 0, "archived": false, "score": 33, "report_reasons": null, "author": "lneutral", "parent_id": "t3_655orz", "subreddit_name_prefixed": "r/compsci", "controversiality": 0, "body": "What you're describing is a copy constructor, and nearly every STL container class has one. \n\nYou should definitely implement one if you've never done it before, but note that for a linear structure like a linked list, you should consider doing it in a loop instead of recursively.\n\n(Proof of that last point left as an exercise to the reader)", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;What you&amp;#39;re describing is a copy constructor, and nearly every STL container class has one. &lt;/p&gt;\n\n&lt;p&gt;You should definitely implement one if you&amp;#39;ve never done it before, but note that for a linear structure like a linked list, you should consider doing it in a loop instead of recursively.&lt;/p&gt;\n\n&lt;p&gt;(Proof of that last point left as an exercise to the reader)&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "compsci", "name": "t1_dg7owzs", "score_hidden": false, "stickied": false, "created": 1492125578.0, "created_utc": 1492096778.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 33}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qhmr", "removal_reason": null, "link_id": "t3_655orz", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qhmr", "removal_reason": null, "link_id": "t3_655orz", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qhmr", "removal_reason": null, "link_id": "t3_655orz", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qhmr", "removal_reason": null, "link_id": "t3_655orz", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qhmr", "removal_reason": null, "link_id": "t3_655orz", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qhmr", "removal_reason": null, "link_id": "t3_655orz", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qhmr", "removal_reason": null, "link_id": "t3_655orz", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qhmr", "removal_reason": null, "link_id": "t3_655orz", "likes": null, "replies": "", "user_reports": [], "id": "dg9j7ar", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "thehorrorfrog", "parent_id": "t1_dg8uzkj", "subreddit_name_prefixed": "r/compsci", "controversiality": 0, "body": "I don't think so, my thought is that recursive_memcpy recurses through the linked list, not the data structure. My idea is that recursive_memcpy is basically a library function takes a \"copy\" function pointer, a size (giving the size of the data in each node), and a pointer to the head of a linked list. recursive_memcpy would create a new linked list, recurse through the original linked list initializing new nodes and calling the user-defined \"copy\" function to copy data from the original node into the new node. So when the top-level call to recursive-memcpy returns you would have two linked lists each with the same data.\n\nYou could implement the copy function however you want though, and if the data in your linked list had recursive substructure like that it might make sense to have a bunch of nested calls to recursive memcpy, but this function wouldn't necessarily be recursive. ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I don&amp;#39;t think so, my thought is that recursive_memcpy recurses through the linked list, not the data structure. My idea is that recursive_memcpy is basically a library function takes a &amp;quot;copy&amp;quot; function pointer, a size (giving the size of the data in each node), and a pointer to the head of a linked list. recursive_memcpy would create a new linked list, recurse through the original linked list initializing new nodes and calling the user-defined &amp;quot;copy&amp;quot; function to copy data from the original node into the new node. So when the top-level call to recursive-memcpy returns you would have two linked lists each with the same data.&lt;/p&gt;\n\n&lt;p&gt;You could implement the copy function however you want though, and if the data in your linked list had recursive substructure like that it might make sense to have a bunch of nested calls to recursive memcpy, but this function wouldn&amp;#39;t necessarily be recursive. &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "compsci", "name": "t1_dg9j7ar", "score_hidden": false, "stickied": false, "created": 1492223198.0, "created_utc": 1492194398.0, "depth": 7, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg8uzkj", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "asljkdfhg", "parent_id": "t1_dg82vsh", "subreddit_name_prefixed": "r/compsci", "controversiality": 0, "body": "Hmm, I might be wrong, but this process is looking pretty similar to a pointer fold function right? Like you have a copy function pointer that you pass to the recursive memcpy that copies the first pointer layer and calls recursive memcpy with the copy function of the second pointer layer and so forth. I'm not sure what exactly recursive memcpy is doing in this situation, though. Is it supposedly collecting the pointers to this data from this copy function and initializing the pointers of the new data structure?", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Hmm, I might be wrong, but this process is looking pretty similar to a pointer fold function right? Like you have a copy function pointer that you pass to the recursive memcpy that copies the first pointer layer and calls recursive memcpy with the copy function of the second pointer layer and so forth. I&amp;#39;m not sure what exactly recursive memcpy is doing in this situation, though. Is it supposedly collecting the pointers to this data from this copy function and initializing the pointers of the new data structure?&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "compsci", "name": "t1_dg8uzkj", "score_hidden": false, "stickied": false, "created": 1492180431.0, "created_utc": 1492151631.0, "depth": 6, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg82vsh", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "thehorrorfrog", "parent_id": "t1_dg81u62", "subreddit_name_prefixed": "r/compsci", "controversiality": 0, "body": "I think at that point you might just be better off writing your own function, but it doesn't need to be *that* messy since there's no need for the copy function you pass to the top level recursive/iterative copy function to be generic. \n\nSay you have some abstract library function recursive_memcpy that recursively copies a linked list using some user defined function passed as a function pointer. You need to write a copy function that handles copying of whatever is in your linked list node to some new address. In writing that function you *can* call recursive_memcpy and pass other copy functions to it, or you can handle copying that data yourself. The key is that the user defined copy function doesn't need to be generic, since we know what needs to be copied when we write it. \n\nI can't think of a better way to do this in C, but it might be possible to do it with some sort of preprocessor macro black magic. ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I think at that point you might just be better off writing your own function, but it doesn&amp;#39;t need to be &lt;em&gt;that&lt;/em&gt; messy since there&amp;#39;s no need for the copy function you pass to the top level recursive/iterative copy function to be generic. &lt;/p&gt;\n\n&lt;p&gt;Say you have some abstract library function recursive_memcpy that recursively copies a linked list using some user defined function passed as a function pointer. You need to write a copy function that handles copying of whatever is in your linked list node to some new address. In writing that function you &lt;em&gt;can&lt;/em&gt; call recursive_memcpy and pass other copy functions to it, or you can handle copying that data yourself. The key is that the user defined copy function doesn&amp;#39;t need to be generic, since we know what needs to be copied when we write it. &lt;/p&gt;\n\n&lt;p&gt;I can&amp;#39;t think of a better way to do this in C, but it might be possible to do it with some sort of preprocessor macro black magic. &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "compsci", "name": "t1_dg82vsh", "score_hidden": false, "stickied": false, "created": 1492140489.0, "created_utc": 1492111689.0, "depth": 5, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg81u62", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "asljkdfhg", "parent_id": "t1_dg808vv", "subreddit_name_prefixed": "r/compsci", "controversiality": 0, "body": "Wait, if we're passing in a giant nested copy function, aren't we essentially passing in a pointer to a similar recursive memcpy function to begin with?", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Wait, if we&amp;#39;re passing in a giant nested copy function, aren&amp;#39;t we essentially passing in a pointer to a similar recursive memcpy function to begin with?&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "compsci", "name": "t1_dg81u62", "score_hidden": false, "stickied": false, "created": 1492139358.0, "created_utc": 1492110558.0, "depth": 4, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg808vv", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "thehorrorfrog", "parent_id": "t1_dg7ypfn", "subreddit_name_prefixed": "r/compsci", "controversiality": 0, "body": "Well in OP's example he talked about a linked list. So if our linked list node has a pointer to some data, say a structure stored on the heap with pointers to more structures, arrays, or whatever we want, we would pass a pointer to a function that copies whatever is in that data and its associated memory addresses, and that copy function could make use of other functions to handle copying of nested structures or arrays. \n\n", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Well in OP&amp;#39;s example he talked about a linked list. So if our linked list node has a pointer to some data, say a structure stored on the heap with pointers to more structures, arrays, or whatever we want, we would pass a pointer to a function that copies whatever is in that data and its associated memory addresses, and that copy function could make use of other functions to handle copying of nested structures or arrays. &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "compsci", "name": "t1_dg808vv", "score_hidden": false, "stickied": false, "created": 1492137634.0, "created_utc": 1492108834.0, "depth": 3, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg7ypfn", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "asljkdfhg", "parent_id": "t1_dg7xxft", "subreddit_name_prefixed": "r/compsci", "controversiality": 0, "body": "But then what about several pointers to various structure or primitive arrays?  The issue then quickly becomes that every single structure that you point to needs to have a reliable copy function which is impossible unless you only have nested pointers to your own structure types.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;But then what about several pointers to various structure or primitive arrays?  The issue then quickly becomes that every single structure that you point to needs to have a reliable copy function which is impossible unless you only have nested pointers to your own structure types.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "compsci", "name": "t1_dg7ypfn", "score_hidden": false, "stickied": false, "created": 1492135995.0, "created_utc": 1492107195.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg7xxft", "gilded": 0, "archived": false, "score": 0, "report_reasons": null, "author": "thehorrorfrog", "parent_id": "t1_dg7na2e", "subreddit_name_prefixed": "r/compsci", "controversiality": 0, "body": "You could pass a function pointer to a \"copy\" function for a given structure. That's probably how I'd handle it, I'm not sure if there's a better way. ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;You could pass a function pointer to a &amp;quot;copy&amp;quot; function for a given structure. That&amp;#39;s probably how I&amp;#39;d handle it, I&amp;#39;m not sure if there&amp;#39;s a better way. &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "compsci", "name": "t1_dg7xxft", "score_hidden": false, "stickied": false, "created": 1492135163.0, "created_utc": 1492106363.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 0}}], "after": null, "before": null}}, "user_reports": [], "id": "dg7na2e", "gilded": 0, "archived": false, "score": 6, "report_reasons": null, "author": "asljkdfhg", "parent_id": "t3_655orz", "subreddit_name_prefixed": "r/compsci", "controversiality": 0, "body": "How would you handle pointers to arrays? How would you know how far the structure's memory goes?", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;How would you handle pointers to arrays? How would you know how far the structure&amp;#39;s memory goes?&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "compsci", "name": "t1_dg7na2e", "score_hidden": false, "stickied": false, "created": 1492123764.0, "created_utc": 1492094964.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 6}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qhmr", "removal_reason": null, "link_id": "t3_655orz", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qhmr", "removal_reason": null, "link_id": "t3_655orz", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qhmr", "removal_reason": null, "link_id": "t3_655orz", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qhmr", "removal_reason": null, "link_id": "t3_655orz", "likes": null, "replies": "", "user_reports": [], "id": "dg7vxk7", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "IAMYourReason", "parent_id": "t1_dg7tt84", "subreddit_name_prefixed": "r/compsci", "controversiality": 0, "body": "Yeah I see it as being primarily useful for novice learners as a utility but little application in real-world scenarios.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Yeah I see it as being primarily useful for novice learners as a utility but little application in real-world scenarios.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "compsci", "name": "t1_dg7vxk7", "score_hidden": false, "stickied": false, "created": 1492133045.0, "created_utc": 1492104245.0, "depth": 3, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg7tt84", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "TomSwirly", "parent_id": "t1_dg7qzlf", "subreddit_name_prefixed": "r/compsci", "controversiality": 0, "body": "You lose little cognitive load, and you gain a lot of potential footguns. ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;You lose little cognitive load, and you gain a lot of potential footguns. &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "compsci", "name": "t1_dg7tt84", "score_hidden": false, "stickied": false, "created": 1492130798.0, "created_utc": 1492101998.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 2}}], "after": null, "before": null}}, "user_reports": [], "id": "dg7qzlf", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "IAMYourReason", "parent_id": "t1_dg7m2us", "subreddit_name_prefixed": "r/compsci", "controversiality": 0, "body": "I think the use-case is in lowering cognitive load on the programmer. You could probably write an algorithm that uses runtime type/size introspection in languages that have it (Java). Most languages in which you'd want to implement memory-level copy constructs aren't going to support this, though.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I think the use-case is in lowering cognitive load on the programmer. You could probably write an algorithm that uses runtime type/size introspection in languages that have it (Java). Most languages in which you&amp;#39;d want to implement memory-level copy constructs aren&amp;#39;t going to support this, though.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "compsci", "name": "t1_dg7qzlf", "score_hidden": false, "stickied": false, "created": 1492127784.0, "created_utc": 1492098984.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg7m2us", "gilded": 0, "archived": false, "score": 8, "report_reasons": null, "author": "NoTroop", "parent_id": "t3_655orz", "subreddit_name_prefixed": "r/compsci", "controversiality": 0, "body": "How would you know, when calling the function, how much memory to allocate beforehand if you have all of those extra pointers/objects? And, if you were unable to know, and just malloc'ed new memory for all of the new pointers, what would have been the point? Unless you guaranteed that all of the \"malloc'd\" (though you'd have to use something else) was contiguous from where you  were moving the data  to.\n\nAll in all, I'm just confused at the  use case of this.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;How would you know, when calling the function, how much memory to allocate beforehand if you have all of those extra pointers/objects? And, if you were unable to know, and just malloc&amp;#39;ed new memory for all of the new pointers, what would have been the point? Unless you guaranteed that all of the &amp;quot;malloc&amp;#39;d&amp;quot; (though you&amp;#39;d have to use something else) was contiguous from where you  were moving the data  to.&lt;/p&gt;\n\n&lt;p&gt;All in all, I&amp;#39;m just confused at the  use case of this.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "compsci", "name": "t1_dg7m2us", "score_hidden": false, "stickied": false, "created": 1492122367.0, "created_utc": 1492093567.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 8}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qhmr", "removal_reason": null, "link_id": "t3_655orz", "likes": null, "replies": "", "user_reports": [], "id": "dg7q86i", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "H_2", "parent_id": "t3_655orz", "subreddit_name_prefixed": "r/compsci", "controversiality": 0, "body": "C++ has copy constructors to handle memory duplication of structures and classes, while D has the \".dup\" method/trait and Rust has the \"clone\" trait. Regardless, it is a benign task to write a function to do the same thing with linked lists. \n\nCuda doesn't have anything like this, to my knowledge, and even the usual C++ copy constructor for class/structure duplication will only be able to duplicate host allocated memory. If you do plan to implement it in Cuda, just be warned that this type of operation will perform incredibly poorly according to the paradigms of GPU programming. There's a reason cudaMallocPitch() is used for 2D arrays, afterall.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;C++ has copy constructors to handle memory duplication of structures and classes, while D has the &amp;quot;.dup&amp;quot; method/trait and Rust has the &amp;quot;clone&amp;quot; trait. Regardless, it is a benign task to write a function to do the same thing with linked lists. &lt;/p&gt;\n\n&lt;p&gt;Cuda doesn&amp;#39;t have anything like this, to my knowledge, and even the usual C++ copy constructor for class/structure duplication will only be able to duplicate host allocated memory. If you do plan to implement it in Cuda, just be warned that this type of operation will perform incredibly poorly according to the paradigms of GPU programming. There&amp;#39;s a reason cudaMallocPitch() is used for 2D arrays, afterall.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "compsci", "name": "t1_dg7q86i", "score_hidden": false, "stickied": false, "created": 1492126973.0, "created_utc": 1492098173.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 3}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qhmr", "removal_reason": null, "link_id": "t3_655orz", "likes": null, "replies": "", "user_reports": [], "id": "dg84w1g", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "angererc", "parent_id": "t3_655orz", "subreddit_name_prefixed": "r/compsci", "controversiality": 0, "body": "For CUDA there is no direct \"deep copy\" operation. Which makes sense if you think about it: if you copy an item you need to first allocate memory on the host, which has a different address. Therefore you must patch all the pointers that point to this item (e.g. the previous and next items) and this can't be done automatically, because how would this routine know which bytes are pointers and which are numbers. The overall copy process is similar to how copy constructors work on the CPU, but allocating and patching the individual pointers is -- relatively speaking -- significantly more expensive on the GPU. \n\nSecond, deeply linked data structures are probably something you want to avoid on the GPU anyways. Flat memory accesses are much better for the performance. That's also true for the CPU but again, excessive pointer chasing is relatively more expensive on the GPU. Now of course there are legitimate reasons to have deep pointer structures (for maintenance reasons or maybe it's not performance relevant or just because), so this is only a rule of thumb that can be broken.\n\nOn newer GPUs (at least Kepler, but better Pascal with cuda &gt;= 8.0) you can use unified virtual memory (UVM). With unified memory (cudaMallocManaged) you can keep the pointers the same on the CPU and the GPU because the memory addresses stay the same (memory is paged in/out to/from CPU/GPU, both using the same address space). UVM doesn't really help with the copying process itself, but it's then the *exact* same copy code as on the cpu. And with UVM you don't need to create a copy just to get the list onto the GPU. ", "edited": 1492114153.0, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;For CUDA there is no direct &amp;quot;deep copy&amp;quot; operation. Which makes sense if you think about it: if you copy an item you need to first allocate memory on the host, which has a different address. Therefore you must patch all the pointers that point to this item (e.g. the previous and next items) and this can&amp;#39;t be done automatically, because how would this routine know which bytes are pointers and which are numbers. The overall copy process is similar to how copy constructors work on the CPU, but allocating and patching the individual pointers is -- relatively speaking -- significantly more expensive on the GPU. &lt;/p&gt;\n\n&lt;p&gt;Second, deeply linked data structures are probably something you want to avoid on the GPU anyways. Flat memory accesses are much better for the performance. That&amp;#39;s also true for the CPU but again, excessive pointer chasing is relatively more expensive on the GPU. Now of course there are legitimate reasons to have deep pointer structures (for maintenance reasons or maybe it&amp;#39;s not performance relevant or just because), so this is only a rule of thumb that can be broken.&lt;/p&gt;\n\n&lt;p&gt;On newer GPUs (at least Kepler, but better Pascal with cuda &amp;gt;= 8.0) you can use unified virtual memory (UVM). With unified memory (cudaMallocManaged) you can keep the pointers the same on the CPU and the GPU because the memory addresses stay the same (memory is paged in/out to/from CPU/GPU, both using the same address space). UVM doesn&amp;#39;t really help with the copying process itself, but it&amp;#39;s then the &lt;em&gt;exact&lt;/em&gt; same copy code as on the cpu. And with UVM you don&amp;#39;t need to create a copy just to get the list onto the GPU. &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "compsci", "name": "t1_dg84w1g", "score_hidden": false, "stickied": false, "created": 1492142674.0, "created_utc": 1492113874.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 3}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qhmr", "removal_reason": null, "link_id": "t3_655orz", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qhmr", "removal_reason": null, "link_id": "t3_655orz", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qhmr", "removal_reason": null, "link_id": "t3_655orz", "likes": null, "replies": "", "user_reports": [], "id": "dg8eed7", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "bumblebritches57", "parent_id": "t1_dg7n6l3", "subreddit_name_prefixed": "r/compsci", "controversiality": 0, "body": "I do C, not C++. we have to build our own implementations of stuff like that, and the upside is you can remove nonsense you don't need to slim it down, and ofc you own the copyright so you don't need to worry, unlike if you used someone else's library.\n\nIt sounds more complicated, but really it's not.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I do C, not C++. we have to build our own implementations of stuff like that, and the upside is you can remove nonsense you don&amp;#39;t need to slim it down, and ofc you own the copyright so you don&amp;#39;t need to worry, unlike if you used someone else&amp;#39;s library.&lt;/p&gt;\n\n&lt;p&gt;It sounds more complicated, but really it&amp;#39;s not.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "compsci", "name": "t1_dg8eed7", "score_hidden": false, "stickied": false, "created": 1492154359.0, "created_utc": 1492125559.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 2}}], "after": null, "before": null}}, "user_reports": [], "id": "dg7n6l3", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "agumonkey", "parent_id": "t1_dg7mcz0", "subreddit_name_prefixed": "r/compsci", "controversiality": 0, "body": "kinda like custom made clone ?", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;kinda like custom made clone ?&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "compsci", "name": "t1_dg7n6l3", "score_hidden": false, "stickied": false, "created": 1492123654.0, "created_utc": 1492094854.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg7mcz0", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "bumblebritches57", "parent_id": "t3_655orz", "subreddit_name_prefixed": "r/compsci", "controversiality": 0, "body": "No, you can easy make your own tho, just like you'd do for a Init function...\n\nI wouldn't, it would take an hour to do something like that, and I wouldn't have any dependencies...\n\nThat said, I have no use for linked lists, so fee free to ignore me.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;No, you can easy make your own tho, just like you&amp;#39;d do for a Init function...&lt;/p&gt;\n\n&lt;p&gt;I wouldn&amp;#39;t, it would take an hour to do something like that, and I wouldn&amp;#39;t have any dependencies...&lt;/p&gt;\n\n&lt;p&gt;That said, I have no use for linked lists, so fee free to ignore me.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "compsci", "name": "t1_dg7mcz0", "score_hidden": false, "stickied": false, "created": 1492122701.0, "created_utc": 1492093901.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 1}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qhmr", "removal_reason": null, "link_id": "t3_655orz", "likes": null, "replies": "", "user_reports": [], "id": "dg7v6ga", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "IJzerbaard", "parent_id": "t3_655orz", "subreddit_name_prefixed": "r/compsci", "controversiality": 0, "body": "I'm not convinced that there's a reasonable way to do it on CUDA. The naive way is certainly out of the question, it's arbitrarily serial, has a shit memory access pattern, and recursion is a Bad Thing to begin with. \n\nIf you can come up with a reasonable way, great, I'll read it. But I'll still probably never use it, just copying a whole buffer worth of nodes is a fine solution should it ever be necessary. And on that topic, usually explicit copies aren't necessary in the first place, typical pattern is building the result in a non-input buffer.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;m not convinced that there&amp;#39;s a reasonable way to do it on CUDA. The naive way is certainly out of the question, it&amp;#39;s arbitrarily serial, has a shit memory access pattern, and recursion is a Bad Thing to begin with. &lt;/p&gt;\n\n&lt;p&gt;If you can come up with a reasonable way, great, I&amp;#39;ll read it. But I&amp;#39;ll still probably never use it, just copying a whole buffer worth of nodes is a fine solution should it ever be necessary. And on that topic, usually explicit copies aren&amp;#39;t necessary in the first place, typical pattern is building the result in a non-input buffer.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "compsci", "name": "t1_dg7v6ga", "score_hidden": false, "stickied": false, "created": 1492132241.0, "created_utc": 1492103441.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 1}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qhmr", "removal_reason": null, "link_id": "t3_655orz", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qhmr", "removal_reason": null, "link_id": "t3_655orz", "likes": null, "replies": "", "user_reports": [], "id": "dg7qvfr", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "IAMYourReason", "parent_id": "t1_dg7ndcd", "subreddit_name_prefixed": "r/compsci", "controversiality": 0, "body": "True, but `Copy` can only be derived for structures that already implement `Clone`, which is to say that there isn't a generic algorithm for copying arbitrary structures with arbitrary references in them.\n\nIf you try to derive `Copy` on something with a `Box&lt;T&gt;` in it, where `T `does not implement `Clone`, it will fail.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;True, but &lt;code&gt;Copy&lt;/code&gt; can only be derived for structures that already implement &lt;code&gt;Clone&lt;/code&gt;, which is to say that there isn&amp;#39;t a generic algorithm for copying arbitrary structures with arbitrary references in them.&lt;/p&gt;\n\n&lt;p&gt;If you try to derive &lt;code&gt;Copy&lt;/code&gt; on something with a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; in it, where &lt;code&gt;T&lt;/code&gt;does not implement &lt;code&gt;Clone&lt;/code&gt;, it will fail.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "compsci", "name": "t1_dg7qvfr", "score_hidden": false, "stickied": false, "created": 1492127662.0, "created_utc": 1492098862.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg7ndcd", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "mjager", "parent_id": "t3_655orz", "subreddit_name_prefixed": "r/compsci", "controversiality": 0, "body": "well, none of the above, but Rust has a derivable [trait](https://doc.rust-lang.org/std/clone/trait.Clone.html) for that", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;well, none of the above, but Rust has a derivable &lt;a href=\"https://doc.rust-lang.org/std/clone/trait.Clone.html\"&gt;trait&lt;/a&gt; for that&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "compsci", "name": "t1_dg7ndcd", "score_hidden": false, "stickied": false, "created": 1492123869.0, "created_utc": 1492095069.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 1}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qhmr", "removal_reason": null, "link_id": "t3_655orz", "likes": null, "replies": "", "user_reports": [], "id": "dg7lhyg", "gilded": 0, "archived": false, "score": 0, "report_reasons": null, "author": "BobbyRaduloff", "parent_id": "t3_655orz", "subreddit_name_prefixed": "r/compsci", "controversiality": 0, "body": "Sure, if it supports a good number of data structures.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Sure, if it supports a good number of data structures.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "compsci", "name": "t1_dg7lhyg", "score_hidden": false, "stickied": false, "created": 1492121686.0, "created_utc": 1492092886.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 0}}], "after": null, "before": null}}]