[{"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t3", "data": {"contest_mode": false, "banned_by": null, "media_embed": {}, "subreddit": "javascript", "selftext_html": null, "selftext": "", "likes": null, "suggested_sort": null, "user_reports": [], "secure_media": null, "link_flair_text": null, "id": "64p5ew", "gilded": 0, "secure_media_embed": {}, "clicked": false, "score": 5, "report_reasons": null, "author": "dyslexiccoder", "saved": false, "mod_reports": [], "name": "t3_64p5ew", "subreddit_name_prefixed": "r/javascript", "approved_by": null, "over_18": false, "domain": "gist.github.com", "hidden": false, "thumbnail": "", "subreddit_id": "t5_2qh30", "edited": false, "link_flair_css_class": null, "author_flair_css_class": null, "downs": 0, "brand_safe": true, "archived": false, "removal_reason": null, "is_self": false, "hide_score": false, "spoiler": false, "permalink": "/r/javascript/comments/64p5ew/javascript_function_performance_testing_accurate/", "num_reports": null, "locked": false, "stickied": false, "created": 1491920065.0, "url": "https://gist.github.com/lukechilds/f2cfe9257da2b387acc31c7616b1dec4", "author_flair_text": null, "quarantine": false, "title": "JavaScript function performance testing accurate to 5 microseconds in 59 bytes", "created_utc": 1491891265.0, "distinguished": null, "media": null, "upvote_ratio": 0.63, "num_comments": 6, "visited": false, "subreddit_type": "public", "ups": 5}}], "after": null, "before": null}}, {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh30", "removal_reason": null, "link_id": "t3_64p5ew", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh30", "removal_reason": null, "link_id": "t3_64p5ew", "likes": null, "replies": "", "user_reports": [], "id": "dg4b2ql", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "redbluerat", "parent_id": "t1_dg3ynfl", "subreddit_name_prefixed": "r/javascript", "controversiality": 0, "body": "Haha, even the function looks weary with how terse it is.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Haha, even the function looks weary with how terse it is.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "javascript", "name": "t1_dg4b2ql", "score_hidden": false, "stickied": false, "created": 1491949000.0, "created_utc": 1491920200.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 3}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh30", "removal_reason": null, "link_id": "t3_64p5ew", "likes": null, "replies": "", "user_reports": [], "id": "dg5dpt8", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "dyslexiccoder", "parent_id": "t1_dg3ynfl", "subreddit_name_prefixed": "r/javascript", "controversiality": 0, "body": "This is awesome!\n\nI had no idea you could use parenthesis/commas in this way to get the return value of the last item: `(s=t(),f(),t()-s)`.\n\nAlso, allowing a timer function to be passed in while simultaneously removing the need for `let` is very cool.\n\n`=_=` is just plain evil though...", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;This is awesome!&lt;/p&gt;\n\n&lt;p&gt;I had no idea you could use parenthesis/commas in this way to get the return value of the last item: &lt;code&gt;(s=t(),f(),t()-s)&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;Also, allowing a timer function to be passed in while simultaneously removing the need for &lt;code&gt;let&lt;/code&gt; is very cool.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;=_=&lt;/code&gt; is just plain evil though...&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "javascript", "name": "t1_dg5dpt8", "score_hidden": false, "stickied": false, "created": 1491995063.0, "created_utc": 1491966263.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg3ynfl", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "busypenguin", "parent_id": "t3_64p5ew", "subreddit_name_prefixed": "r/javascript", "controversiality": 0, "body": "Here is the original\n\n    time = fn=&gt;{let t=()=&gt;performance.now(),s=t();fn();return t()-s}\n\nHere is an improved version saving a few very important bytes. It even lets you specify your own function for timing as the second argument and uses performance.now as a default.\n\n    time = (f,t=_=&gt;performance.now(),s)=&gt;(s=t(),f(),t()-s)\n\n=_=", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Here is the original&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;time = fn=&amp;gt;{let t=()=&amp;gt;performance.now(),s=t();fn();return t()-s}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here is an improved version saving a few very important bytes. It even lets you specify your own function for timing as the second argument and uses performance.now as a default.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;time = (f,t=_=&amp;gt;performance.now(),s)=&amp;gt;(s=t(),f(),t()-s)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;=_=&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "javascript", "name": "t1_dg3ynfl", "score_hidden": false, "stickied": false, "created": 1491921472.0, "created_utc": 1491892672.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 3}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh30", "removal_reason": null, "link_id": "t3_64p5ew", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh30", "removal_reason": null, "link_id": "t3_64p5ew", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh30", "removal_reason": null, "link_id": "t3_64p5ew", "likes": null, "replies": "", "user_reports": [], "id": "dg5vtaa", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "lhorie", "parent_id": "t1_dg5df8u", "subreddit_name_prefixed": "r/javascript", "controversiality": 0, "body": "&gt; are you sure performance.now() is slower\n\nWell, it's not that it's slower, the issue is that it doesn't account for overheads. In benchmarking you want to get the time after the \"start timer\" call and the time *before* the \"end timer\" call. Since performance.now() is used for both, then it's guaranteed that the time to call it is included in the measurement.\n\nIn addition, neither `performance.now` and `console.time` take into account overheads from loops and function calls wrapping the benchmark payload. Some people have gotten around this by measuring empty loops but that has the problem of not necessarily measuring the same thing (because JIT might compile away parts of the loops/function calls)\n\nThe other confounding factor is statistical outliers. Typically you get a bunch of results in the same ballpark, but you may also get results that are too high due to GC kicking in, or whatever. Those skew the average with the same weight as measurements near the middle of the group, and that's where benchmark.js' statistical normalization comes in handy.\n\nGenerally, if you're using your snippet and getting an order of magnitude difference, then you probably don't need to worry about the accuracy. But if results are very close to each other, that's when you should worry about measurement confounding factors.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;blockquote&gt;\n&lt;p&gt;are you sure performance.now() is slower&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Well, it&amp;#39;s not that it&amp;#39;s slower, the issue is that it doesn&amp;#39;t account for overheads. In benchmarking you want to get the time after the &amp;quot;start timer&amp;quot; call and the time &lt;em&gt;before&lt;/em&gt; the &amp;quot;end timer&amp;quot; call. Since performance.now() is used for both, then it&amp;#39;s guaranteed that the time to call it is included in the measurement.&lt;/p&gt;\n\n&lt;p&gt;In addition, neither &lt;code&gt;performance.now&lt;/code&gt; and &lt;code&gt;console.time&lt;/code&gt; take into account overheads from loops and function calls wrapping the benchmark payload. Some people have gotten around this by measuring empty loops but that has the problem of not necessarily measuring the same thing (because JIT might compile away parts of the loops/function calls)&lt;/p&gt;\n\n&lt;p&gt;The other confounding factor is statistical outliers. Typically you get a bunch of results in the same ballpark, but you may also get results that are too high due to GC kicking in, or whatever. Those skew the average with the same weight as measurements near the middle of the group, and that&amp;#39;s where benchmark.js&amp;#39; statistical normalization comes in handy.&lt;/p&gt;\n\n&lt;p&gt;Generally, if you&amp;#39;re using your snippet and getting an order of magnitude difference, then you probably don&amp;#39;t need to worry about the accuracy. But if results are very close to each other, that&amp;#39;s when you should worry about measurement confounding factors.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "javascript", "name": "t1_dg5vtaa", "score_hidden": false, "stickied": false, "created": 1492033939.0, "created_utc": 1492005139.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg5df8u", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "dyslexiccoder", "parent_id": "t1_dg4jc3e", "subreddit_name_prefixed": "r/javascript", "controversiality": 0, "body": "Thanks, very informative :)\n\nCan you explain further what you mean by:\n\n&gt; microsecond precision, but not necessarily microsecond accuracy\n\nAlso are you sure performance.now() is slower? I would be interested to read a source on this. I only found this myself: https://github.com/bahmutov/code-snippets/issues/9\n\n&gt; You can still get interference from things like GC and JIT\n\nYeah I noticed that when I tried to loop over the function 100x times and take an average, it's waaaay faster due to some sort of JIT optimisation for repeated function calls.\n\n&gt; you should try to measure high level functions with realistic inputs, rather than measure micro-optimizations\n\nYeah, I literally just wanted to test `document.querySelectorAll` vs `document.getElementsByTagName` and needed sub ms accuracy: \n\n    time = fn=&gt;{let t=()=&gt;performance.now(),s=t();fn();return t()-s}\n    time(() =&gt; document.querySelectorAll('span'))\n    // 0.18499999959021807\n    time(() =&gt; document.getElementsByTagName('span'))\n    // 0.04000000050291419\n\nThe code was so tiny I thought it might be a useful snippet to share. Obviously for serious use you would be better off with something like benchmark.js", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Thanks, very informative :)&lt;/p&gt;\n\n&lt;p&gt;Can you explain further what you mean by:&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;microsecond precision, but not necessarily microsecond accuracy&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Also are you sure performance.now() is slower? I would be interested to read a source on this. I only found this myself: &lt;a href=\"https://github.com/bahmutov/code-snippets/issues/9\"&gt;https://github.com/bahmutov/code-snippets/issues/9&lt;/a&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;You can still get interference from things like GC and JIT&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Yeah I noticed that when I tried to loop over the function 100x times and take an average, it&amp;#39;s waaaay faster due to some sort of JIT optimisation for repeated function calls.&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;you should try to measure high level functions with realistic inputs, rather than measure micro-optimizations&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Yeah, I literally just wanted to test &lt;code&gt;document.querySelectorAll&lt;/code&gt; vs &lt;code&gt;document.getElementsByTagName&lt;/code&gt; and needed sub ms accuracy: &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;time = fn=&amp;gt;{let t=()=&amp;gt;performance.now(),s=t();fn();return t()-s}\ntime(() =&amp;gt; document.querySelectorAll(&amp;#39;span&amp;#39;))\n// 0.18499999959021807\ntime(() =&amp;gt; document.getElementsByTagName(&amp;#39;span&amp;#39;))\n// 0.04000000050291419\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The code was so tiny I thought it might be a useful snippet to share. Obviously for serious use you would be better off with something like benchmark.js&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "javascript", "name": "t1_dg5df8u", "score_hidden": false, "stickied": false, "created": 1491994642.0, "created_utc": 1491965842.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg4jc3e", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "lhorie", "parent_id": "t3_64p5ew", "subreddit_name_prefixed": "r/javascript", "controversiality": 0, "body": "`performance.now` has microsecond precision, but not necessarily microsecond accuracy. For benchmarking purposes, this is an important difference.\n\nIn order of least accurate to most accurate:\n\n- new Date().getTime() - millisecond precision, accurate to approx. hundredth of a second\n- Date.now - slightly more accurate than 1) due to less calling overhead\n- performance.now() - microsecond precision\n- console.time / console.timeEnd (in Chrome) - better microsecond precision, but extremely sensitive to statistical errors\n- benchmark.js - microsecond precision, and statistically normalized\n\nYou can still get interference from things like GC and JIT, especially in microbenchmarks (i.e. the types that measure native calls or low level operations), so ideally, you should try to measure high level functions with realistic inputs, rather than measure micro-optimizations.", "edited": 1491954980.0, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;&lt;code&gt;performance.now&lt;/code&gt; has microsecond precision, but not necessarily microsecond accuracy. For benchmarking purposes, this is an important difference.&lt;/p&gt;\n\n&lt;p&gt;In order of least accurate to most accurate:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;new Date().getTime() - millisecond precision, accurate to approx. hundredth of a second&lt;/li&gt;\n&lt;li&gt;Date.now - slightly more accurate than 1) due to less calling overhead&lt;/li&gt;\n&lt;li&gt;performance.now() - microsecond precision&lt;/li&gt;\n&lt;li&gt;console.time / console.timeEnd (in Chrome) - better microsecond precision, but extremely sensitive to statistical errors&lt;/li&gt;\n&lt;li&gt;benchmark.js - microsecond precision, and statistically normalized&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;You can still get interference from things like GC and JIT, especially in microbenchmarks (i.e. the types that measure native calls or low level operations), so ideally, you should try to measure high level functions with realistic inputs, rather than measure micro-optimizations.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "javascript", "name": "t1_dg4jc3e", "score_hidden": false, "stickied": false, "created": 1491958287.0, "created_utc": 1491929487.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 3}}], "after": null, "before": null}}]