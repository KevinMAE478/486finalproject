[{"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t3", "data": {"contest_mode": false, "banned_by": null, "media_embed": {}, "subreddit": "javascript", "selftext_html": null, "selftext": "", "likes": null, "suggested_sort": null, "user_reports": [], "secure_media": null, "link_flair_text": null, "id": "64q2b7", "gilded": 0, "secure_media_embed": {}, "clicked": false, "score": 6, "report_reasons": null, "author": "amishyn", "saved": false, "mod_reports": [], "name": "t3_64q2b7", "subreddit_name_prefixed": "r/javascript", "approved_by": null, "over_18": false, "domain": "railsware.com", "hidden": false, "thumbnail": "", "subreddit_id": "t5_2qh30", "edited": false, "link_flair_css_class": null, "author_flair_css_class": null, "downs": 0, "brand_safe": true, "archived": false, "removal_reason": null, "is_self": false, "hide_score": false, "spoiler": false, "permalink": "/r/javascript/comments/64q2b7/managing_state_of_business_logic_in_angular/", "num_reports": null, "locked": false, "stickied": false, "created": 1491936118.0, "url": "http://railsware.com/blog/2017/04/10/managing-state-of-business-logic-in-angular/", "author_flair_text": null, "quarantine": false, "title": "Managing state of business logic in Angular", "created_utc": 1491907318.0, "distinguished": null, "media": null, "upvote_ratio": 0.62, "num_comments": 6, "visited": false, "subreddit_type": "public", "ups": 6}}], "after": null, "before": null}}, {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh30", "removal_reason": null, "link_id": "t3_64q2b7", "likes": null, "replies": "", "user_reports": [], "id": "dg442b3", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "u982744", "parent_id": "t3_64q2b7", "subreddit_name_prefixed": "r/javascript", "controversiality": 0, "body": "I like this as an alternative to redux which often times is not necessary. ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I like this as an alternative to redux which often times is not necessary. &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "javascript", "name": "t1_dg442b3", "score_hidden": false, "stickied": false, "created": 1491937240.0, "created_utc": 1491908440.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 1}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh30", "removal_reason": null, "link_id": "t3_64q2b7", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh30", "removal_reason": null, "link_id": "t3_64q2b7", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh30", "removal_reason": null, "link_id": "t3_64q2b7", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh30", "removal_reason": null, "link_id": "t3_64q2b7", "likes": null, "replies": "", "user_reports": [], "id": "dg6dsua", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "tme321", "parent_id": "t1_dg5s52i", "subreddit_name_prefixed": "r/javascript", "controversiality": 0, "body": "I don't, the repo is private.  But I can try to give you a small taste.\n\nSo I have very large data sets that are handled by an api.  It does sorting, filtering, etc on the data itself.  I don't do that locally.  I ended up creating a simple data table that basically just has events defined for the actions instead of implementing them internally.  So if a column header is clicked I just fire the event.  What I do handle locally is showing or hiding of individual columns of the data set; basically a columns filter.  So the data table itself just receives a model that looks like this:\n\n    export interface DataTable {\n    \tselectionMethod: string;\n    \tselection: any[];\n    \tcolumns: Column[];\n    \tcolumnsId: string;\n    }\n\t\nI'm not going to get too much into the table, but it's pretty simple and looks something like this (I've simplified it some for this example):\n\n    @Component({\n        selector: 'data-table',\n        template: `\n\t\t\t&lt;table&gt;\n\t\t\t\t&lt;thead class=\"table-header\"&gt;\n\t\t\t\t\t&lt;tr class=\"table-header-row\"&gt;\n\t\t\t\t\t\t&lt;th *ngFor=\"let column of model.columns\"\n\t\t\t\t\t\t\t(click)=\"onHeaderCellClicked($event,column)\"&gt;\n\t\t\t\t\t\t\t&lt;span&gt;{{column.header}}&lt;/span&gt;\n\t\t\t\t\t\t&lt;/th&gt;\n\t\t\t\t\t&lt;/tr&gt;\n\t\t\t\t&lt;/thead&gt;\n\t\t\t\t&lt;tbody class=\"table-body\"&gt;\n\t\t\t\t\t&lt;tr class=\"table-body-row\" *ngFor=\"let row of rows; let r=index\"\n\t\t\t\t\t\t(click)=\"onRowClicked($event,r)\"&gt;\n\t\t\t\t\t\t&lt;td *ngFor=\"let column of model.columns\"&gt;\n\t\t\t\t\t\t\t&lt;span&gt;{{getValueByPath(row,column)}}&lt;/span&gt;\n\t\t\t\t\t\t&lt;/td&gt;\n\t\t\t\t\t&lt;/tr&gt;\n\t\t\t\t&lt;/tbody&gt;\n\t\t\t&lt;/table&gt;\n\t\t`,\n        changeDetection: ChangeDetectionStrategy.OnPush\n    })\n    export class TableComponent {\n        @Input() model: DataTable;\n        @Input() rows: any[];\n        @Output() headerCellClicked = new EventEmitter&lt;Column&gt;();\n        @Output() selectionChanged = new EventEmitter&lt;any[]&gt;();\n    \n        private onHeaderCellClicked(e: MouseEvent, column: Column) {\n            this.headerCellClicked.emit(column);\n        }\n    \t\n        private onRowClicked(e: MouseEvent, r: number) {\n            this.modifySelection(e, r);\n            this.selectionChanged.emit(this.getSelectedData());\n        }\n    }\t\n\n\nNow, for reasons that are too complex to get deeply into I decided that I needed to split up the storing of the columns arrays themselves and the rest of the data table models inside my ngrx store.  The short version is the columns arrays are useful in other places as well so I didn't want to be retrieving a data table model when all I wanted was the column definitions in other locations.  \n\nBut I still wanted to deliver the entire data table model as one unit to the data table component.  So I created a service that takes care of retrieving this data for me but also allows me to hide and show the individual columns when they are filtered in and out by a completely different component.  So, again an abridged version, the service looks something like this:\n\n    @Injectable()\n    export class DataTableService {\n    \n        constructor(private store: Store&lt;AppStoreModel&gt;) {\n        }\n    \n        /**\n         * Get the observable of the data table from the store.\n         */\n        getDataTable$(id: string) {\n            return this.store.select(getTable(id));\n        }\n    \n        /**\n         * Get the observable of the entire columns array.\n         */\n        getColumns$(id:string){\n            return this.store.select(getAllColumns(id));\n        }\n    \n        /**\n         * Get the observable of the filtered columns array.\n         */\n        getFilteredColumns$(id:string){\n            return this.store.select(getFilteredColumns(id));\n        }\n    \n        /**\n         * Combine the table and filtered columns into a single new table model.\n         */\n        getFilteredTable$(tableId: string, columnId: string) {\n            return Observable.combineLatest(\n                this.getDataTable$(tableId),\n                this.getFilteredColumns$(columnId),\n                (table: DataTable, columns: Column[]) =&gt;{\n                    return Object.assign({},table, {columns: columns});;\n                }\n            );\n        }\n    \n        /**\n         * Filter a column out from the list of columns.\n         */\n        filterColumn(id: string, column: Column) {\n            this.store.dispatch(columnsActions.column.filterItem(id,column));\n        }\n    \n        /**\n         * Unfilter a column from the list of columns.\n         */\n        unfilterColumn(id: string, column: Column) {\n            this.store.dispatch(columnsActions.column.unfilterItem(id,column));\n        }\n\t\t\n\t\t/**\n\t\t * Set the table sorting to the specified column and set the\n\t\t * 'sort' key in the query parameters to the columns headerkey.\n\t\t * @param column the column to sort on\n\t\t */\n\t\tsortOnColumn(id:string, column: Column) {\n\t\t\tthis.store.dispatch(\n\t\t\t\ttablesActions.table.setTableSort({\n\t\t\t\tid: id,\n\t\t\t\tcolumn: column\n\t\t\t}));\n\t\t}\n\t\t\n    }\n\nAnd now when I want to use a specific implementation of a data table I just tie the service's methods and store slices to the data table component's inputs and outputs:\n\n    @Component({\n        template: `\n    \t\t&lt;data-table [model]=\"dtServ.table$ | async\"\n                       [rows]=\"dataServ.data$ | async\"                       \n(headerCellClicked)=\"dtServ.sortOnColumn($event)\"&gt;\n            &lt;/data-table&gt;\n    \t`,\n    })\n    export class ASpecificTableComponent {\n        constructor(\n    \t\tprivate dtServ: DataTableService, \n    \t\tprivate dataServ: DataService) {\n        }   \n    \n        ngOnInit() {\n    \t\t// initialize the data table service here by \n    \t\t// setting it up with the right ids to use \n    \t\t// for the store calls.  Not really interesting\n    \t\t// and too specific to my implementation to \n    \t\t// bother showing.\n        }\n    }\n\nI know a glossed over a decent amount there.  Sorry.  As I said, the actual code is closed.  But I hope that gives some kind of idea as to what I'm doing.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I don&amp;#39;t, the repo is private.  But I can try to give you a small taste.&lt;/p&gt;\n\n&lt;p&gt;So I have very large data sets that are handled by an api.  It does sorting, filtering, etc on the data itself.  I don&amp;#39;t do that locally.  I ended up creating a simple data table that basically just has events defined for the actions instead of implementing them internally.  So if a column header is clicked I just fire the event.  What I do handle locally is showing or hiding of individual columns of the data set; basically a columns filter.  So the data table itself just receives a model that looks like this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;export interface DataTable {\n    selectionMethod: string;\n    selection: any[];\n    columns: Column[];\n    columnsId: string;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I&amp;#39;m not going to get too much into the table, but it&amp;#39;s pretty simple and looks something like this (I&amp;#39;ve simplified it some for this example):&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;@Component({\n    selector: &amp;#39;data-table&amp;#39;,\n    template: `\n        &amp;lt;table&amp;gt;\n            &amp;lt;thead class=&amp;quot;table-header&amp;quot;&amp;gt;\n                &amp;lt;tr class=&amp;quot;table-header-row&amp;quot;&amp;gt;\n                    &amp;lt;th *ngFor=&amp;quot;let column of model.columns&amp;quot;\n                        (click)=&amp;quot;onHeaderCellClicked($event,column)&amp;quot;&amp;gt;\n                        &amp;lt;span&amp;gt;{{column.header}}&amp;lt;/span&amp;gt;\n                    &amp;lt;/th&amp;gt;\n                &amp;lt;/tr&amp;gt;\n            &amp;lt;/thead&amp;gt;\n            &amp;lt;tbody class=&amp;quot;table-body&amp;quot;&amp;gt;\n                &amp;lt;tr class=&amp;quot;table-body-row&amp;quot; *ngFor=&amp;quot;let row of rows; let r=index&amp;quot;\n                    (click)=&amp;quot;onRowClicked($event,r)&amp;quot;&amp;gt;\n                    &amp;lt;td *ngFor=&amp;quot;let column of model.columns&amp;quot;&amp;gt;\n                        &amp;lt;span&amp;gt;{{getValueByPath(row,column)}}&amp;lt;/span&amp;gt;\n                    &amp;lt;/td&amp;gt;\n                &amp;lt;/tr&amp;gt;\n            &amp;lt;/tbody&amp;gt;\n        &amp;lt;/table&amp;gt;\n    `,\n    changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class TableComponent {\n    @Input() model: DataTable;\n    @Input() rows: any[];\n    @Output() headerCellClicked = new EventEmitter&amp;lt;Column&amp;gt;();\n    @Output() selectionChanged = new EventEmitter&amp;lt;any[]&amp;gt;();\n\n    private onHeaderCellClicked(e: MouseEvent, column: Column) {\n        this.headerCellClicked.emit(column);\n    }\n\n    private onRowClicked(e: MouseEvent, r: number) {\n        this.modifySelection(e, r);\n        this.selectionChanged.emit(this.getSelectedData());\n    }\n}   \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now, for reasons that are too complex to get deeply into I decided that I needed to split up the storing of the columns arrays themselves and the rest of the data table models inside my ngrx store.  The short version is the columns arrays are useful in other places as well so I didn&amp;#39;t want to be retrieving a data table model when all I wanted was the column definitions in other locations.  &lt;/p&gt;\n\n&lt;p&gt;But I still wanted to deliver the entire data table model as one unit to the data table component.  So I created a service that takes care of retrieving this data for me but also allows me to hide and show the individual columns when they are filtered in and out by a completely different component.  So, again an abridged version, the service looks something like this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;@Injectable()\nexport class DataTableService {\n\n    constructor(private store: Store&amp;lt;AppStoreModel&amp;gt;) {\n    }\n\n    /**\n     * Get the observable of the data table from the store.\n     */\n    getDataTable$(id: string) {\n        return this.store.select(getTable(id));\n    }\n\n    /**\n     * Get the observable of the entire columns array.\n     */\n    getColumns$(id:string){\n        return this.store.select(getAllColumns(id));\n    }\n\n    /**\n     * Get the observable of the filtered columns array.\n     */\n    getFilteredColumns$(id:string){\n        return this.store.select(getFilteredColumns(id));\n    }\n\n    /**\n     * Combine the table and filtered columns into a single new table model.\n     */\n    getFilteredTable$(tableId: string, columnId: string) {\n        return Observable.combineLatest(\n            this.getDataTable$(tableId),\n            this.getFilteredColumns$(columnId),\n            (table: DataTable, columns: Column[]) =&amp;gt;{\n                return Object.assign({},table, {columns: columns});;\n            }\n        );\n    }\n\n    /**\n     * Filter a column out from the list of columns.\n     */\n    filterColumn(id: string, column: Column) {\n        this.store.dispatch(columnsActions.column.filterItem(id,column));\n    }\n\n    /**\n     * Unfilter a column from the list of columns.\n     */\n    unfilterColumn(id: string, column: Column) {\n        this.store.dispatch(columnsActions.column.unfilterItem(id,column));\n    }\n\n    /**\n     * Set the table sorting to the specified column and set the\n     * &amp;#39;sort&amp;#39; key in the query parameters to the columns headerkey.\n     * @param column the column to sort on\n     */\n    sortOnColumn(id:string, column: Column) {\n        this.store.dispatch(\n            tablesActions.table.setTableSort({\n            id: id,\n            column: column\n        }));\n    }\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And now when I want to use a specific implementation of a data table I just tie the service&amp;#39;s methods and store slices to the data table component&amp;#39;s inputs and outputs:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;@Component({\n    template: `\n        &amp;lt;data-table [model]=&amp;quot;dtServ.table$ | async&amp;quot;\n                   [rows]=&amp;quot;dataServ.data$ | async&amp;quot;                       \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;(headerCellClicked)=&amp;quot;dtServ.sortOnColumn($event)&amp;quot;&amp;gt;\n            &amp;lt;/data-table&amp;gt;\n        `,\n    })\n    export class ASpecificTableComponent {\n        constructor(\n            private dtServ: DataTableService, \n            private dataServ: DataService) {\n        }   &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;    ngOnInit() {\n        // initialize the data table service here by \n        // setting it up with the right ids to use \n        // for the store calls.  Not really interesting\n        // and too specific to my implementation to \n        // bother showing.\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I know a glossed over a decent amount there.  Sorry.  As I said, the actual code is closed.  But I hope that gives some kind of idea as to what I&amp;#39;m doing.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "javascript", "name": "t1_dg6dsua", "score_hidden": false, "stickied": false, "created": 1492053256.0, "created_utc": 1492024456.0, "depth": 3, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg5s52i", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "anotherjsframework", "parent_id": "t1_dg4pioo", "subreddit_name_prefixed": "r/javascript", "controversiality": 0, "body": "I've had a look at ngrx - it seems very interesting.\n\nDo you have any simple examples of code setup this way that I could look at? It sounds a lot like what I would like to achieve.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;ve had a look at ngrx - it seems very interesting.&lt;/p&gt;\n\n&lt;p&gt;Do you have any simple examples of code setup this way that I could look at? It sounds a lot like what I would like to achieve.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "javascript", "name": "t1_dg5s52i", "score_hidden": false, "stickied": false, "created": 1492028300.0, "created_utc": 1491999500.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg4pioo", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "tme321", "parent_id": "t1_dg4f1sv", "subreddit_name_prefixed": "r/javascript", "controversiality": 0, "body": "I've been using a hybrid approach lately that I've become quite enamoured with.  I use injected services that actually manage state by using ngrx, a redux style store.  To the components it looks like a completely standard service with plain function calls but the service itself maps these functions to store actions and provides the observables of the store slices as required.\n\nDoing this means my components stay dumb for the most part.  They are very reusable and very simple to understand and test.\n\nThe services themselves are also very easy to test as the majority of their code is just firing an action.\n\nI also like this approach because it allows me to create a very normalized store but still deliver data to my components in a format that makes sense for them.  I don't have to litter my components with code that combines various store slices I can just write the code once in the service to deliver the stores data in a easier to work with format.\n\nSo basically I write services as if they were controllers for the store itself.  Everything stays cleanly separated and also changes can easily be made to any layer with minimal impact to any other layer, usually only requiring minor updates in a single service or reducer.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;ve been using a hybrid approach lately that I&amp;#39;ve become quite enamoured with.  I use injected services that actually manage state by using ngrx, a redux style store.  To the components it looks like a completely standard service with plain function calls but the service itself maps these functions to store actions and provides the observables of the store slices as required.&lt;/p&gt;\n\n&lt;p&gt;Doing this means my components stay dumb for the most part.  They are very reusable and very simple to understand and test.&lt;/p&gt;\n\n&lt;p&gt;The services themselves are also very easy to test as the majority of their code is just firing an action.&lt;/p&gt;\n\n&lt;p&gt;I also like this approach because it allows me to create a very normalized store but still deliver data to my components in a format that makes sense for them.  I don&amp;#39;t have to litter my components with code that combines various store slices I can just write the code once in the service to deliver the stores data in a easier to work with format.&lt;/p&gt;\n\n&lt;p&gt;So basically I write services as if they were controllers for the store itself.  Everything stays cleanly separated and also changes can easily be made to any layer with minimal impact to any other layer, usually only requiring minor updates in a single service or reducer.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "javascript", "name": "t1_dg4pioo", "score_hidden": false, "stickied": false, "created": 1491965058.0, "created_utc": 1491936258.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg4f1sv", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "anotherjsframework", "parent_id": "t3_64q2b7", "subreddit_name_prefixed": "r/javascript", "controversiality": 0, "body": "I've never tried redux, this has always seemed like the default logic for angular to me so I've always implemented something very similar to this.\n\nI'm wondering what downsides this could have, or whether there are any improvements that could be made to this logic when handling large datasets.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;ve never tried redux, this has always seemed like the default logic for angular to me so I&amp;#39;ve always implemented something very similar to this.&lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;m wondering what downsides this could have, or whether there are any improvements that could be made to this logic when handling large datasets.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "javascript", "name": "t1_dg4f1sv", "score_hidden": false, "stickied": false, "created": 1491953586.0, "created_utc": 1491924786.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 1}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh30", "removal_reason": null, "link_id": "t3_64q2b7", "likes": null, "replies": "", "user_reports": [], "id": "dg4sq0b", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "maneesht18", "parent_id": "t3_64q2b7", "subreddit_name_prefixed": "r/javascript", "controversiality": 0, "body": "This is a good example, but rarely is business logic that simple that a simple service can satisfy it. I'm also not a huge fan of method bindings in the template. That's why I generally use ngrx/store", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;This is a good example, but rarely is business logic that simple that a simple service can satisfy it. I&amp;#39;m also not a huge fan of method bindings in the template. That&amp;#39;s why I generally use ngrx/store&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "javascript", "name": "t1_dg4sq0b", "score_hidden": false, "stickied": false, "created": 1491968467.0, "created_utc": 1491939667.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}]