[{"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t3", "data": {"contest_mode": false, "banned_by": null, "media_embed": {}, "subreddit": "math", "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Me and &lt;a href=\"/u/oslash\"&gt;/u/oslash&lt;/a&gt; were having a &lt;a href=\"https://np.reddit.com/r/programming/comments/64uwoq/how_spotify_shuffles_songs/dg7ci3h/\"&gt;discussion&lt;/a&gt; about the Fisher\u2013Yates shuffle. I asked why the python &lt;a href=\"https://hg.python.org/cpython/file/2e8b28dbc395/Lib/random.py#l276\"&gt;shuffle function&lt;/a&gt; reverses the index before doing the shuffle.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"/u/oslash\"&gt;/u/oslash&lt;/a&gt; had a good answer:&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;Because the algorithm starts with picking a random element from all the possibilities and progresses to choosing from fewer and fewer candidates. The range of eligible list indices decreases.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;I found that perfectly reasonable. However, I wasn&amp;#39;t able to reproduce this bias. I ran 10000 shuffle for the ordered values in [100, 120), and produced the following heatmap of the counts per index:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"http://i.imgur.com/M77px4u.png\"&gt;http://i.imgur.com/M77px4u.png&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;If the index order would make it have a bias I&amp;#39;d expect to see lower indices tend to have lower values. In the right heatmap this should show up as a gradient of darker colors in the bottom left to lighter colors toward the top right. I don&amp;#39;t see that. &lt;/p&gt;\n\n&lt;p&gt;To illustrate, a biased result might look more like this: &lt;a href=\"http://i.imgur.com/pAxvgcG.png\"&gt;http://i.imgur.com/pAxvgcG.png&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Here I set &lt;code&gt;j = int(random() * (i+1) * 0.9)&lt;/code&gt; such that the rng only produces values between [0.0, 0.9).&lt;/p&gt;\n\n&lt;h2&gt;What&amp;#39;s up here? Why does this seem to be just as random as the correct implementation?&lt;/h2&gt;\n\n&lt;p&gt;Anyway, here&amp;#39;s the original code without an intentionally introduced bias:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;%matplotlib inline\n\nimport pandas as pd\nimport numpy as np\nfrom random import random\nimport matplotlib.pyplot as plt\n\ndef shuffle(lst):\n    for i in reversed(range(1, len(lst))):\n        j = int(random() * (i+1))\n        lst[i], lst[j] = lst[j], lst[i]\n\ndef waxy_chocolate_shuffle(lst):\n    for i in range(1, len(lst)):\n        j = int(random() * (i+1))\n        lst[i], lst[j] = lst[j], lst[i]\n\ndef counts(df, vals, idxs):\n    count_df = pd.DataFrame(0, index=vals, columns=idxs)\n    for idx in idxs:\n        for val in vals:\n            count_df[idx][val] = df[idx][df[idx] == val].count()\n    return count_df\n\nn = 10000\norg_vals = [x for x in range(100, 120)]\norg_idxs = [i for i in range(len(org_vals))]\nvmin = 0.9 * n / len(org_vals)\nvmax = 1.1 * n / len(org_vals)\n\nshuffled = list()\nfor _ in range(n):\n    lst = org_vals.copy()\n    shuffle(lst)\n    shuffled.append(lst)\n\nshuffled_df = pd.DataFrame(shuffled, columns=org_idxs)\nshuffled_df = counts(shuffled_df, org_vals, org_idxs)\n\nwaxy_shuffled = list()\nfor _ in range(n):\n    lst = org_vals.copy()\n    waxy_chocolate_shuffle(lst)\n    waxy_shuffled.append(lst)\n\nwaxy_shuffled_df = pd.DataFrame(waxy_shuffled, columns=org_idxs)\nwaxy_shuffled_df = counts(waxy_shuffled_df, org_vals, org_idxs)\n\nplt.figure(figsize=(12,4))\n\nplt.subplot(1, 2, 1)\nplt.pcolor(shuffled_df, vmin=vmin, vmax=vmax)\nplt.yticks(np.arange(0.5, len(shuffled_df.index), 1), shuffled_df.index)\nplt.xticks(np.arange(0.5, len(shuffled_df.columns), 1), shuffled_df.columns)\nplt.title(&amp;#39;shuffle(lst)&amp;#39;)\n\nplt.subplot(1, 2, 2)\nplt.pcolor(waxy_shuffled_df, vmin=vmin, vmax=vmax)\nplt.yticks(np.arange(0.5, len(waxy_shuffled_df.index), 1), waxy_shuffled_df.index)\nplt.xticks(np.arange(0.5, len(waxy_shuffled_df.columns), 1), waxy_shuffled_df.columns)\nplt.title(&amp;#39;waxy_shuffled(lst)&amp;#39;)\nplt.show()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "selftext": "Me and /u/oslash were having a [discussion](https://np.reddit.com/r/programming/comments/64uwoq/how_spotify_shuffles_songs/dg7ci3h/) about the Fisher\u2013Yates shuffle. I asked why the python [shuffle function](https://hg.python.org/cpython/file/2e8b28dbc395/Lib/random.py#l276) reverses the index before doing the shuffle.\n\n/u/oslash had a good answer:\n\n&gt; Because the algorithm starts with picking a random element from all the possibilities and progresses to choosing from fewer and fewer candidates. The range of eligible list indices decreases.\n\nI found that perfectly reasonable. However, I wasn't able to reproduce this bias. I ran 10000 shuffle for the ordered values in [100, 120), and produced the following heatmap of the counts per index:\n\nhttp://i.imgur.com/M77px4u.png\n\nIf the index order would make it have a bias I'd expect to see lower indices tend to have lower values. In the right heatmap this should show up as a gradient of darker colors in the bottom left to lighter colors toward the top right. I don't see that. \n\nTo illustrate, a biased result might look more like this: http://i.imgur.com/pAxvgcG.png\n\nHere I set `j = int(random() * (i+1) * 0.9)` such that the rng only produces values between [0.0, 0.9).\n\nWhat's up here? Why does this seem to be just as random as the correct implementation?\n--------\n\nAnyway, here's the original code without an intentionally introduced bias:\n\n    %matplotlib inline\n\n    import pandas as pd\n    import numpy as np\n    from random import random\n    import matplotlib.pyplot as plt\n\n    def shuffle(lst):\n        for i in reversed(range(1, len(lst))):\n            j = int(random() * (i+1))\n            lst[i], lst[j] = lst[j], lst[i]\n\n    def waxy_chocolate_shuffle(lst):\n        for i in range(1, len(lst)):\n            j = int(random() * (i+1))\n            lst[i], lst[j] = lst[j], lst[i]\n            \n    def counts(df, vals, idxs):\n        count_df = pd.DataFrame(0, index=vals, columns=idxs)\n        for idx in idxs:\n            for val in vals:\n                count_df[idx][val] = df[idx][df[idx] == val].count()\n        return count_df\n\n    n = 10000\n    org_vals = [x for x in range(100, 120)]\n    org_idxs = [i for i in range(len(org_vals))]\n    vmin = 0.9 * n / len(org_vals)\n    vmax = 1.1 * n / len(org_vals)\n    \n    shuffled = list()\n    for _ in range(n):\n        lst = org_vals.copy()\n        shuffle(lst)\n        shuffled.append(lst)\n\n    shuffled_df = pd.DataFrame(shuffled, columns=org_idxs)\n    shuffled_df = counts(shuffled_df, org_vals, org_idxs)\n\n    waxy_shuffled = list()\n    for _ in range(n):\n        lst = org_vals.copy()\n        waxy_chocolate_shuffle(lst)\n        waxy_shuffled.append(lst)\n\n    waxy_shuffled_df = pd.DataFrame(waxy_shuffled, columns=org_idxs)\n    waxy_shuffled_df = counts(waxy_shuffled_df, org_vals, org_idxs)\n\n    plt.figure(figsize=(12,4))\n\n    plt.subplot(1, 2, 1)\n    plt.pcolor(shuffled_df, vmin=vmin, vmax=vmax)\n    plt.yticks(np.arange(0.5, len(shuffled_df.index), 1), shuffled_df.index)\n    plt.xticks(np.arange(0.5, len(shuffled_df.columns), 1), shuffled_df.columns)\n    plt.title('shuffle(lst)')\n    \n    plt.subplot(1, 2, 2)\n    plt.pcolor(waxy_shuffled_df, vmin=vmin, vmax=vmax)\n    plt.yticks(np.arange(0.5, len(waxy_shuffled_df.index), 1), waxy_shuffled_df.index)\n    plt.xticks(np.arange(0.5, len(waxy_shuffled_df.columns), 1), waxy_shuffled_df.columns)\n    plt.title('waxy_shuffled(lst)')\n    plt.show()", "likes": null, "suggested_sort": null, "user_reports": [], "secure_media": null, "link_flair_text": null, "id": "654kj4", "gilded": 0, "secure_media_embed": {}, "clicked": false, "score": 15, "report_reasons": null, "author": "WaxyChocolate", "saved": false, "mod_reports": [], "name": "t3_654kj4", "subreddit_name_prefixed": "r/math", "approved_by": null, "over_18": false, "domain": "self.math", "hidden": false, "thumbnail": "", "subreddit_id": "t5_2qh0n", "edited": 1492078298.0, "link_flair_css_class": null, "author_flair_css_class": null, "downs": 0, "brand_safe": true, "archived": false, "removal_reason": null, "is_self": true, "hide_score": false, "spoiler": false, "permalink": "/r/math/comments/654kj4/wrongly_implemented_fisheryates_shuffle_seems_to/", "num_reports": null, "locked": false, "stickied": false, "created": 1492106775.0, "url": "https://www.reddit.com/r/math/comments/654kj4/wrongly_implemented_fisheryates_shuffle_seems_to/", "author_flair_text": null, "quarantine": false, "title": "Wrongly implemented Fisher\u2013Yates shuffle seems to unexpectedly work. Starting with sampling from few entries, then more and more, seems to work just fine. Why?", "created_utc": 1492077975.0, "distinguished": null, "media": null, "upvote_ratio": 0.9, "num_comments": 5, "visited": false, "subreddit_type": "public", "ups": 15}}], "after": null, "before": null}}, {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0n", "removal_reason": null, "link_id": "t3_654kj4", "likes": null, "replies": "", "user_reports": [], "id": "dg7dilw", "gilded": 0, "archived": false, "score": 9, "report_reasons": null, "author": "convex_kraken", "parent_id": "t3_654kj4", "subreddit_name_prefixed": "r/math", "controversiality": 0, "body": "I think you can prove your method (is it the waxy chocolate one? edit: yes, I noticed OP's username) is fine by induction. Look at the nth prefix of the array after the nth iteration: it is a (uniformly) random permutation on n elements. After the n+1-th iteration, you've placed n+1 randomly into the array. I don't see an issue. Placing n+1 into the prefix by swapping also works fine (from uniform randomness of the previous prefix, it is the same distribution as if you had chosen a random position for n+1 and then squeezed every element starting from that position one place to the right, which is more obviously uniform).", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I think you can prove your method (is it the waxy chocolate one? edit: yes, I noticed OP&amp;#39;s username) is fine by induction. Look at the nth prefix of the array after the nth iteration: it is a (uniformly) random permutation on n elements. After the n+1-th iteration, you&amp;#39;ve placed n+1 randomly into the array. I don&amp;#39;t see an issue. Placing n+1 into the prefix by swapping also works fine (from uniform randomness of the previous prefix, it is the same distribution as if you had chosen a random position for n+1 and then squeezed every element starting from that position one place to the right, which is more obviously uniform).&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "math", "name": "t1_dg7dilw", "score_hidden": false, "stickied": false, "created": 1492107323.0, "created_utc": 1492078523.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 9}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0n", "removal_reason": null, "link_id": "t3_654kj4", "likes": null, "replies": "", "user_reports": [], "id": "dg7dcef", "gilded": 0, "archived": false, "score": 4, "report_reasons": null, "author": "mentionhelper", "parent_id": "t3_654kj4", "subreddit_name_prefixed": "r/math", "controversiality": 0, "body": "It looks like you're trying to mention another user, which only works if it's done in the comments like this (otherwise they don't receive a notification): \n\n- /u/oslash\n\n\n\n---\n\n ^I'm ^a ^bot. ^Bleep. ^Bloop. ^| ^Visit ^/r/mentionhelper ^for ^discussion/feedback ^| ^Want ^to ^be ^left ^alone? ^Reply ^to ^this ^message ^with ^\"stop\"", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;It looks like you&amp;#39;re trying to mention another user, which only works if it&amp;#39;s done in the comments like this (otherwise they don&amp;#39;t receive a notification): &lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"/u/oslash\"&gt;/u/oslash&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;&lt;sup&gt;I&amp;#39;m&lt;/sup&gt; &lt;sup&gt;a&lt;/sup&gt; &lt;sup&gt;bot.&lt;/sup&gt; &lt;sup&gt;Bleep.&lt;/sup&gt; &lt;sup&gt;Bloop.&lt;/sup&gt; &lt;sup&gt;|&lt;/sup&gt; &lt;sup&gt;Visit&lt;/sup&gt; &lt;sup&gt;&lt;a href=\"/r/mentionhelper\"&gt;/r/mentionhelper&lt;/a&gt;&lt;/sup&gt; &lt;sup&gt;for&lt;/sup&gt; &lt;sup&gt;discussion/feedback&lt;/sup&gt; &lt;sup&gt;|&lt;/sup&gt; &lt;sup&gt;Want&lt;/sup&gt; &lt;sup&gt;to&lt;/sup&gt; &lt;sup&gt;be&lt;/sup&gt; &lt;sup&gt;left&lt;/sup&gt; &lt;sup&gt;alone?&lt;/sup&gt; &lt;sup&gt;Reply&lt;/sup&gt; &lt;sup&gt;to&lt;/sup&gt; &lt;sup&gt;this&lt;/sup&gt; &lt;sup&gt;message&lt;/sup&gt; &lt;sup&gt;with&lt;/sup&gt; &lt;sup&gt;&amp;quot;stop&amp;quot;&lt;/sup&gt;&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "math", "name": "t1_dg7dcef", "score_hidden": false, "stickied": false, "created": 1492106813.0, "created_utc": 1492078013.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 4}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0n", "removal_reason": null, "link_id": "t3_654kj4", "likes": null, "replies": "", "user_reports": [], "id": "dg7znwz", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "Tordek", "parent_id": "t3_654kj4", "subreddit_name_prefixed": "r/math", "controversiality": 0, "body": "The order in which you do it should make no difference; in either case F-Y works by saying... \"You have an n-element array, 'input', an an empty n-element array 'output'. For each slot in \"output\" pick a random element from \"input\", place it there, and remove it from 'input'.\"\n\nThe reversed case does this clearly: You start with the i'th slot, and put a random element from [0,i]  in it.\n\nYour case is harder to reason about: You place the first element in any of the first 2 slots. Then, you place whatever is on the 2nd slot into a random place in the first 3 slots... and then repeat. It's actually easier to reason backwards: In the last step, you take the last element of the array and put it into a random position. In the previous step, you took the second-to-last element and put it into a random position (except for the last)... this ends up being identical so F-Y, just executed backwards.\n\nSo... as to \"why\" Python does it that way... I couldn't tell you, other than it being the first example in wikipedia, being slightly easier to explain, and maybe the possibility that it ends up giving better performance by having the last few swaps happen in a smaller portion of the array.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;The order in which you do it should make no difference; in either case F-Y works by saying... &amp;quot;You have an n-element array, &amp;#39;input&amp;#39;, an an empty n-element array &amp;#39;output&amp;#39;. For each slot in &amp;quot;output&amp;quot; pick a random element from &amp;quot;input&amp;quot;, place it there, and remove it from &amp;#39;input&amp;#39;.&amp;quot;&lt;/p&gt;\n\n&lt;p&gt;The reversed case does this clearly: You start with the i&amp;#39;th slot, and put a random element from [0,i]  in it.&lt;/p&gt;\n\n&lt;p&gt;Your case is harder to reason about: You place the first element in any of the first 2 slots. Then, you place whatever is on the 2nd slot into a random place in the first 3 slots... and then repeat. It&amp;#39;s actually easier to reason backwards: In the last step, you take the last element of the array and put it into a random position. In the previous step, you took the second-to-last element and put it into a random position (except for the last)... this ends up being identical so F-Y, just executed backwards.&lt;/p&gt;\n\n&lt;p&gt;So... as to &amp;quot;why&amp;quot; Python does it that way... I couldn&amp;#39;t tell you, other than it being the first example in wikipedia, being slightly easier to explain, and maybe the possibility that it ends up giving better performance by having the last few swaps happen in a smaller portion of the array.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "math", "name": "t1_dg7znwz", "score_hidden": false, "stickied": false, "created": 1492137005.0, "created_utc": 1492108205.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 1}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0n", "removal_reason": null, "link_id": "t3_654kj4", "likes": null, "replies": "", "user_reports": [], "id": "dg82x1b", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "frud", "parent_id": "t3_654kj4", "subreddit_name_prefixed": "r/math", "controversiality": 0, "body": "Both algorithms have `n!` equally likely swap patterns, and it looks to me like every permutation is possible for both algorithms.  From those two observations I conclude that your algorithm is a fair shuffle.\n\nThe F-Y shuffle is structured the way it is to make it simple to inductively prove its fairness.  It's not the only possible fair shuffle algorithm.\n\n*edit: For every sequence of swaps produced by your algorithm, there would be a possible execution of F-Y that would produce the exact reverse of that sequence.  So for every possible execution of your algorithm, there is a corresponding execution of the F-Y shuffle algorithm that produces the inverse permutation.   Divide permutations of n objects into those that are their own inverse, and pairs that are inverses of each other, and you'll see that the inverse of a fair shuffle is also a fair shuffle.", "edited": 1492112163.0, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Both algorithms have &lt;code&gt;n!&lt;/code&gt; equally likely swap patterns, and it looks to me like every permutation is possible for both algorithms.  From those two observations I conclude that your algorithm is a fair shuffle.&lt;/p&gt;\n\n&lt;p&gt;The F-Y shuffle is structured the way it is to make it simple to inductively prove its fairness.  It&amp;#39;s not the only possible fair shuffle algorithm.&lt;/p&gt;\n\n&lt;p&gt;*edit: For every sequence of swaps produced by your algorithm, there would be a possible execution of F-Y that would produce the exact reverse of that sequence.  So for every possible execution of your algorithm, there is a corresponding execution of the F-Y shuffle algorithm that produces the inverse permutation.   Divide permutations of n objects into those that are their own inverse, and pairs that are inverses of each other, and you&amp;#39;ll see that the inverse of a fair shuffle is also a fair shuffle.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "math", "name": "t1_dg82x1b", "score_hidden": false, "stickied": false, "created": 1492140526.0, "created_utc": 1492111726.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 1}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0n", "removal_reason": null, "link_id": "t3_654kj4", "likes": null, "replies": "", "user_reports": [], "id": "dg7qgb4", "gilded": 0, "archived": false, "score": -1, "report_reasons": null, "author": "xcombelle", "parent_id": "t3_654kj4", "subreddit_name_prefixed": "r/math", "controversiality": 0, "body": "The reason why there is a reversed is not because without reversed it would not work. the reasoning of /u you/vonvex_kraken is convincing that your method work.\n\nI believe that the fundamental reason why  there is a reversed in python code source, is that it is the textbook implementation and this textbook implementation is already proven to be correct and it is all but hard to do it.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;The reason why there is a reversed is not because without reversed it would not work. the reasoning of /u you/vonvex_kraken is convincing that your method work.&lt;/p&gt;\n\n&lt;p&gt;I believe that the fundamental reason why  there is a reversed in python code source, is that it is the textbook implementation and this textbook implementation is already proven to be correct and it is all but hard to do it.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "math", "name": "t1_dg7qgb4", "score_hidden": false, "stickied": false, "created": 1492127214.0, "created_utc": 1492098414.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": -1}}], "after": null, "before": null}}]