[{"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t3", "data": {"contest_mode": false, "banned_by": null, "media_embed": {}, "subreddit": "gamedev", "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hi guys, just a small dilemma I&amp;#39;m working through and I figured I&amp;#39;d ask more experienced people.&lt;/p&gt;\n\n&lt;p&gt;Unity 5.5 is the engine in question, though any experience applies.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;The setting&lt;/strong&gt;: It&amp;#39;s an RTS game where maps are expected to generally &lt;a href=\"https://bnetcmsus-a.akamaihd.net/cms/content_folder_media/RY2IKVZ8WCEN1366921019076.jpg\"&gt;look like they do in Starcraft&lt;/a&gt;: quantized heights, with ramps leading between those heights, and resources interspersed in strategically important pockets and chokepoints.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;The situation:&lt;/strong&gt; I have a heightmap generator, Perlin-based, that outputs a map that looks fairly similar to &lt;a href=\"http://i.imgur.com/qqZbOKB.jpg\"&gt;this&lt;/a&gt;.  Combine a few layers of this together and you get multiple altitudes, but the linked picture is the basic concept.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;I need to place ramps between each change in altitude at random locations.&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;What I have so far:&lt;/strong&gt; An edge-identifying algorithm that simply checks for stark differences in contrast, ensures the contrasting pixel hasn&amp;#39;t already been cached before, and then saves it to a texture &lt;em&gt;with the direction the contrasting pixel was found in&lt;/em&gt;.  (Like a normal map, sort of --the vector points from white to black, or high to low.)&lt;/p&gt;\n\n&lt;p&gt;I can pick random points from the edge reference to figure out &lt;em&gt;where&lt;/em&gt; to place the ramps.  I need to make sure my methodology is correct to make sure I&amp;#39;m not going down a dead end:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;The directional vector doesn&amp;#39;t seem to be working correctly, so I&amp;#39;m wondering if there&amp;#39;s a better method (what I do is check each cardinal direction, north, northeast, east, etc. and then average/normalize the results of what I find if there&amp;#39;s a contrast difference in that direction.  It seems to be skewed slightly because it&amp;#39;s finding both sides of the edge line).&lt;/li&gt;\n&lt;li&gt;Assuming the directional vectors get ironed out: once I have a start point and an end point, I can lerp between pixel coordinates and color values, going from startPoint&amp;#39;s color to endPoint&amp;#39;s color in order to create smooth, gradated height values between the two points.&lt;/li&gt;\n&lt;li&gt;I can spread out from the startPoint to nearby edge points and then perform the same startPoint to endPoint color lerp to have a ramp that follows the contour of the cliffside.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;Is this sane?  Is there a better way?  I&amp;#39;m completely opposed to making this game grid-based as it was always intended to have freeform terrains (significant refactoring involved if I switch to a grid), so I would very much like to stick to a heightmap for the time being, as there&amp;#39;s a lot you can do with those and lots of documentation on them.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "selftext": "Hi guys, just a small dilemma I'm working through and I figured I'd ask more experienced people.\n\nUnity 5.5 is the engine in question, though any experience applies.\n\n**The setting**: It's an RTS game where maps are expected to generally [look like they do in Starcraft](https://bnetcmsus-a.akamaihd.net/cms/content_folder_media/RY2IKVZ8WCEN1366921019076.jpg): quantized heights, with ramps leading between those heights, and resources interspersed in strategically important pockets and chokepoints.\n\n**The situation:** I have a heightmap generator, Perlin-based, that outputs a map that looks fairly similar to [this](http://i.imgur.com/qqZbOKB.jpg).  Combine a few layers of this together and you get multiple altitudes, but the linked picture is the basic concept.\n\n**I need to place ramps between each change in altitude at random locations.**\n\n**What I have so far:** An edge-identifying algorithm that simply checks for stark differences in contrast, ensures the contrasting pixel hasn't already been cached before, and then saves it to a texture *with the direction the contrasting pixel was found in*.  (Like a normal map, sort of --the vector points from white to black, or high to low.)\n\nI can pick random points from the edge reference to figure out *where* to place the ramps.  I need to make sure my methodology is correct to make sure I'm not going down a dead end:\n\n1. The directional vector doesn't seem to be working correctly, so I'm wondering if there's a better method (what I do is check each cardinal direction, north, northeast, east, etc. and then average/normalize the results of what I find if there's a contrast difference in that direction.  It seems to be skewed slightly because it's finding both sides of the edge line).\n2. Assuming the directional vectors get ironed out: once I have a start point and an end point, I can lerp between pixel coordinates and color values, going from startPoint's color to endPoint's color in order to create smooth, gradated height values between the two points.\n3. I can spread out from the startPoint to nearby edge points and then perform the same startPoint to endPoint color lerp to have a ramp that follows the contour of the cliffside.\n\nIs this sane?  Is there a better way?  I'm completely opposed to making this game grid-based as it was always intended to have freeform terrains (significant refactoring involved if I switch to a grid), so I would very much like to stick to a heightmap for the time being, as there's a lot you can do with those and lots of documentation on them.", "likes": null, "suggested_sort": null, "user_reports": [], "secure_media": null, "link_flair_text": "Question", "id": "64p652", "gilded": 0, "secure_media_embed": {}, "clicked": false, "score": 17, "report_reasons": null, "author": "loveinalderaanplaces", "saved": false, "mod_reports": [], "name": "t3_64p652", "subreddit_name_prefixed": "r/gamedev", "approved_by": null, "over_18": false, "domain": "self.gamedev", "hidden": false, "thumbnail": "", "subreddit_id": "t5_2qi0a", "edited": false, "link_flair_css_class": "question", "author_flair_css_class": null, "downs": 0, "brand_safe": true, "archived": false, "removal_reason": null, "is_self": true, "hide_score": false, "spoiler": false, "permalink": "/r/gamedev/comments/64p652/procedural_terrains_and_ramp_generation/", "num_reports": null, "locked": false, "stickied": false, "created": 1491920404.0, "url": "https://www.reddit.com/r/gamedev/comments/64p652/procedural_terrains_and_ramp_generation/", "author_flair_text": null, "quarantine": false, "title": "Procedural Terrains and Ramp Generation", "created_utc": 1491891604.0, "distinguished": null, "media": null, "upvote_ratio": 0.79, "num_comments": 5, "visited": false, "subreddit_type": "public", "ups": 17}}], "after": null, "before": null}}, {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qi0a", "removal_reason": null, "link_id": "t3_64p652", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qi0a", "removal_reason": null, "link_id": "t3_64p652", "likes": null, "replies": "", "user_reports": [], "id": "dg4bazz", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "loveinalderaanplaces", "parent_id": "t1_dg40om2", "subreddit_name_prefixed": "r/gamedev", "controversiality": 0, "body": "That... is interesting and batshit enough for me to try it.  I'll report results.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;That... is interesting and batshit enough for me to try it.  I&amp;#39;ll report results.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "gamedev", "name": "t1_dg4bazz", "score_hidden": false, "stickied": false, "created": 1491949284.0, "created_utc": 1491920484.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 2}}], "after": null, "before": null}}, "user_reports": [], "id": "dg40om2", "gilded": 0, "archived": false, "score": 7, "report_reasons": null, "author": "wheyisfood", "parent_id": "t3_64p652", "subreddit_name_prefixed": "r/gamedev", "controversiality": 0, "body": "Completely random idea that may not work...\n\nAfter you've picked the point, use a circular \"brush\" with feathered edges to blend in the original non-quantized Perlin function. It will create a smooth ramp, not a linear one, but will be facing the correct direction automatically. If you quantize at zero level you can simply multiply the original Perlin function to adjust the steepness of the ramp.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Completely random idea that may not work...&lt;/p&gt;\n\n&lt;p&gt;After you&amp;#39;ve picked the point, use a circular &amp;quot;brush&amp;quot; with feathered edges to blend in the original non-quantized Perlin function. It will create a smooth ramp, not a linear one, but will be facing the correct direction automatically. If you quantize at zero level you can simply multiply the original Perlin function to adjust the steepness of the ramp.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "gamedev", "name": "t1_dg40om2", "score_hidden": false, "stickied": false, "created": 1491927054.0, "created_utc": 1491898254.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 7}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qi0a", "removal_reason": null, "link_id": "t3_64p652", "likes": null, "replies": "", "user_reports": [], "id": "dg4gycl", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "gooses", "parent_id": "t3_64p652", "subreddit_name_prefixed": "r/gamedev", "controversiality": 0, "body": "Just an idea, have not tried it in code but this is what i would do. Create second texture by taking the contents of your first texture and applying a blur. \n\nSecond texture would look like this:\nhttp://i.imgur.com/P8milmJ.png\n\nThen, wherever you want a ramp you can sample the area from the ramp texture and put the pixels onto the main texture. \n\nEnd result is something like this:\nhttp://i.imgur.com/kT289Uu.png\n\nEdit: Looking at wheyisfood's answer, It's basically the same idea. Maybe you wouldn't need to blur, just take the non-quantized value. \n", "edited": 1491927095.0, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Just an idea, have not tried it in code but this is what i would do. Create second texture by taking the contents of your first texture and applying a blur. &lt;/p&gt;\n\n&lt;p&gt;Second texture would look like this:\n&lt;a href=\"http://i.imgur.com/P8milmJ.png\"&gt;http://i.imgur.com/P8milmJ.png&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Then, wherever you want a ramp you can sample the area from the ramp texture and put the pixels onto the main texture. &lt;/p&gt;\n\n&lt;p&gt;End result is something like this:\n&lt;a href=\"http://i.imgur.com/kT289Uu.png\"&gt;http://i.imgur.com/kT289Uu.png&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Edit: Looking at wheyisfood&amp;#39;s answer, It&amp;#39;s basically the same idea. Maybe you wouldn&amp;#39;t need to blur, just take the non-quantized value. &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "gamedev", "name": "t1_dg4gycl", "score_hidden": false, "stickied": false, "created": 1491955691.0, "created_utc": 1491926891.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 3}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qi0a", "removal_reason": null, "link_id": "t3_64p652", "likes": null, "replies": "", "user_reports": [], "id": "dg4hnbl", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "AMFV", "parent_id": "t3_64p652", "subreddit_name_prefixed": "r/gamedev", "controversiality": 0, "body": "The approach seems sane. Some thoughts on your points:\n\n1. You could use a [Prewitt operator](https://en.wikipedia.org/wiki/Prewitt_operator) to find the edges (ie. where gradient has large magnitude) and the direction. Then reorient your line to be parallel to that direction. If I were building a ramp in real life that's what I'd do, because it would take less work &amp; material.\n\n3. If each level really is flat, stop spreading out if you reach an edge, otherwise the ramp will have a discontinuity running down it. If each level isn't perfectly flat, I'd reconsider lerping multiple times; you don't want a ramp that looks like it's made out of many tiny logs which don't quite line up. Pick four points (two at the top, two at the bottom) and use bi-linear interpolation. Or, use your original idea but add noise to hide the lines.\n\nMy standard disclaimer: I've never done this :)", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;The approach seems sane. Some thoughts on your points:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;You could use a &lt;a href=\"https://en.wikipedia.org/wiki/Prewitt_operator\"&gt;Prewitt operator&lt;/a&gt; to find the edges (ie. where gradient has large magnitude) and the direction. Then reorient your line to be parallel to that direction. If I were building a ramp in real life that&amp;#39;s what I&amp;#39;d do, because it would take less work &amp;amp; material.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;If each level really is flat, stop spreading out if you reach an edge, otherwise the ramp will have a discontinuity running down it. If each level isn&amp;#39;t perfectly flat, I&amp;#39;d reconsider lerping multiple times; you don&amp;#39;t want a ramp that looks like it&amp;#39;s made out of many tiny logs which don&amp;#39;t quite line up. Pick four points (two at the top, two at the bottom) and use bi-linear interpolation. Or, use your original idea but add noise to hide the lines.&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;My standard disclaimer: I&amp;#39;ve never done this :)&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "gamedev", "name": "t1_dg4hnbl", "score_hidden": false, "stickied": false, "created": 1491956445.0, "created_utc": 1491927645.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 1}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qi0a", "removal_reason": null, "link_id": "t3_64p652", "likes": null, "replies": "", "user_reports": [], "id": "dg4jfly", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "ArdorDeosis", "parent_id": "t3_64p652", "subreddit_name_prefixed": "r/gamedev", "controversiality": 0, "body": "From a heightfield you can calculate the gradient at any point,  that is the partial derivatives in all dimensions, in your case 2. It is the mathematical way to get that vector you are looking for.  \nBut you should do that with a smooth heightfield, not the one with hard edges.\nEdit: [link to Wikipedia](https://en.m.wikipedia.org/wiki/Gradient)", "edited": 1491930050.0, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;From a heightfield you can calculate the gradient at any point,  that is the partial derivatives in all dimensions, in your case 2. It is the mathematical way to get that vector you are looking for.&lt;br/&gt;\nBut you should do that with a smooth heightfield, not the one with hard edges.\nEdit: &lt;a href=\"https://en.m.wikipedia.org/wiki/Gradient\"&gt;link to Wikipedia&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "gamedev", "name": "t1_dg4jfly", "score_hidden": false, "stickied": false, "created": 1491958391.0, "created_utc": 1491929591.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}]