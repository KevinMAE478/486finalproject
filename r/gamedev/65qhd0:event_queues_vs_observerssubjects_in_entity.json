[{"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t3", "data": {"contest_mode": false, "banned_by": null, "media_embed": {}, "subreddit": "gamedev", "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;ve been working with ECS for a while now and have come across some of the nuances associated with cross component/cross entity communication. I have it set up currently similar to unity, where each component holds a reference to it&amp;#39;s parent entity and it can access those components via calls like &amp;#39;getParent().getComponent(Transform.class)&amp;#39;. I&amp;#39;m not necessarily unhappy with having to do this, but the more features I add, the more hoops I&amp;#39;m seeming to have to jump through in order to get the information I need, and it makes me feel like I&amp;#39;m starting to couple the code that I spent so long working to decouple.&lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;ve read up on the Event Queue and Observer design patterns, but I am having a hard time figuring out which one would work best with an ECS. They both seem like they solve the same problem in slightly different ways, but I can only find them described outside of the scope of ECS. Could anyone explain to me why having one or the other would be advantageous/disadvantageous when combined with ECS, or just talk about their experience with either combination? &lt;/p&gt;\n\n&lt;p&gt;Many thanks in advance, and I wish everyone participating in the upcoming Ludum Dare good luck!&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "selftext": "I've been working with ECS for a while now and have come across some of the nuances associated with cross component/cross entity communication. I have it set up currently similar to unity, where each component holds a reference to it's parent entity and it can access those components via calls like 'getParent().getComponent(Transform.class)'. I'm not necessarily unhappy with having to do this, but the more features I add, the more hoops I'm seeming to have to jump through in order to get the information I need, and it makes me feel like I'm starting to couple the code that I spent so long working to decouple.\n\n I've read up on the Event Queue and Observer design patterns, but I am having a hard time figuring out which one would work best with an ECS. They both seem like they solve the same problem in slightly different ways, but I can only find them described outside of the scope of ECS. Could anyone explain to me why having one or the other would be advantageous/disadvantageous when combined with ECS, or just talk about their experience with either combination? \n\nMany thanks in advance, and I wish everyone participating in the upcoming Ludum Dare good luck!", "likes": null, "suggested_sort": null, "user_reports": [], "secure_media": null, "link_flair_text": "Discussion", "id": "65qhd0", "gilded": 0, "secure_media_embed": {}, "clicked": false, "score": 20, "report_reasons": null, "author": "kreinerjm", "saved": false, "mod_reports": [], "name": "t3_65qhd0", "subreddit_name_prefixed": "r/gamedev", "approved_by": null, "over_18": false, "domain": "self.gamedev", "hidden": false, "thumbnail": "", "subreddit_id": "t5_2qi0a", "edited": false, "link_flair_css_class": "discussion cat-talk", "author_flair_css_class": null, "downs": 0, "brand_safe": true, "archived": false, "removal_reason": null, "is_self": true, "hide_score": false, "spoiler": false, "permalink": "/r/gamedev/comments/65qhd0/event_queues_vs_observerssubjects_in_entity/", "num_reports": null, "locked": false, "stickied": false, "created": 1492394951.0, "url": "https://www.reddit.com/r/gamedev/comments/65qhd0/event_queues_vs_observerssubjects_in_entity/", "author_flair_text": null, "quarantine": false, "title": "Event Queues vs Observers/Subjects in Entity Component Systems", "created_utc": 1492366151.0, "distinguished": null, "media": null, "upvote_ratio": 0.81, "num_comments": 11, "visited": false, "subreddit_type": "public", "ups": 20}}], "after": null, "before": null}}, {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qi0a", "removal_reason": null, "link_id": "t3_65qhd0", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qi0a", "removal_reason": null, "link_id": "t3_65qhd0", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qi0a", "removal_reason": null, "link_id": "t3_65qhd0", "likes": null, "replies": "", "user_reports": [], "id": "dgdijro", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "Isogash", "parent_id": "t1_dgcyc0h", "subreddit_name_prefixed": "r/gamedev", "controversiality": 0, "body": "[Here you go](https://github.com/Isogash/ecs-target-game).", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;&lt;a href=\"https://github.com/Isogash/ecs-target-game\"&gt;Here you go&lt;/a&gt;.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "gamedev", "name": "t1_dgdijro", "score_hidden": false, "stickied": false, "created": 1492466755.0, "created_utc": 1492437955.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dgcyc0h", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "kreinerjm", "parent_id": "t1_dgcxtix", "subreddit_name_prefixed": "r/gamedev", "controversiality": 0, "body": "I would actually really enjoy taking a look at what you have, documented or not. I'm not necessarily worried about it being too complicated for the scope of a small project, just more or less looking for clever ways to solve problems, which it seems you have. I've found that there are a couple tricks to avoid type erasure problems and get interesting results, so I would definitely enjoy playing around with it. I typically use LibGDX so I'm pretty well versed in Java.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I would actually really enjoy taking a look at what you have, documented or not. I&amp;#39;m not necessarily worried about it being too complicated for the scope of a small project, just more or less looking for clever ways to solve problems, which it seems you have. I&amp;#39;ve found that there are a couple tricks to avoid type erasure problems and get interesting results, so I would definitely enjoy playing around with it. I typically use LibGDX so I&amp;#39;m pretty well versed in Java.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "gamedev", "name": "t1_dgcyc0h", "score_hidden": false, "stickied": false, "created": 1492423836.0, "created_utc": 1492395036.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 1}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qi0a", "removal_reason": null, "link_id": "t3_65qhd0", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qi0a", "removal_reason": null, "link_id": "t3_65qhd0", "likes": null, "replies": "", "user_reports": [], "id": "dgdj1ys", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "Isogash", "parent_id": "t1_dgdhuc9", "subreddit_name_prefixed": "r/gamedev", "controversiality": 0, "body": "Never really looked into Kotlin, but my main problems were generifying the linking of Event objects and their corresponding listening Systems. I wanted it to be so that a System would only need to declare it's intent to listen for a particular Object type, and then you could fire(Object event) and the world would take care of delivering it to matching listeners.\n\nThe problem with type erasure is that there is no easy way to check the type of a generic. I ended up with a rather ugly limitation of only one listening method per System, but I had previously had an annotation based system that would allow any number of Listeners and with less syntax.\n\nHowever, I'd much rather use a dynamically typed language at that point, especially something like Lua, which would make this kind of type indexing more friendly, as the function name would be an easy way to index based on event name.\n\nHowever, I believe the benefit of ECS as a full paradigm will only truly be realised with a language that fully embraces and enforces the decoupling patterns used. If Kotlin supports this partially declarative style of programming then I'd be interested, but right now I'm considering the possibility of approaching the problem by writing an entirely new language specifically to solve the problem.\n\n[You can read my code here](https://github.com/Isogash/ecs-target-game).", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Never really looked into Kotlin, but my main problems were generifying the linking of Event objects and their corresponding listening Systems. I wanted it to be so that a System would only need to declare it&amp;#39;s intent to listen for a particular Object type, and then you could fire(Object event) and the world would take care of delivering it to matching listeners.&lt;/p&gt;\n\n&lt;p&gt;The problem with type erasure is that there is no easy way to check the type of a generic. I ended up with a rather ugly limitation of only one listening method per System, but I had previously had an annotation based system that would allow any number of Listeners and with less syntax.&lt;/p&gt;\n\n&lt;p&gt;However, I&amp;#39;d much rather use a dynamically typed language at that point, especially something like Lua, which would make this kind of type indexing more friendly, as the function name would be an easy way to index based on event name.&lt;/p&gt;\n\n&lt;p&gt;However, I believe the benefit of ECS as a full paradigm will only truly be realised with a language that fully embraces and enforces the decoupling patterns used. If Kotlin supports this partially declarative style of programming then I&amp;#39;d be interested, but right now I&amp;#39;m considering the possibility of approaching the problem by writing an entirely new language specifically to solve the problem.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://github.com/Isogash/ecs-target-game\"&gt;You can read my code here&lt;/a&gt;.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "gamedev", "name": "t1_dgdj1ys", "score_hidden": false, "stickied": false, "created": 1492467452.0, "created_utc": 1492438652.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dgdhuc9", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "vidyjagamedoovoolope", "parent_id": "t1_dgcxtix", "subreddit_name_prefixed": "r/gamedev", "controversiality": 0, "body": "&gt; I don't personally encourage you to use a language with type erasure, like Java, for this though. I had no ends of problems trying to genericise everything, but it's possible to do nicely with annotations, or correctly but with some limitations.\n\nWondering\u200b what problems you had, and if kotlin could help address those", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;blockquote&gt;\n&lt;p&gt;I don&amp;#39;t personally encourage you to use a language with type erasure, like Java, for this though. I had no ends of problems trying to genericise everything, but it&amp;#39;s possible to do nicely with annotations, or correctly but with some limitations.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Wondering\u200b what problems you had, and if kotlin could help address those&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "gamedev", "name": "t1_dgdhuc9", "score_hidden": false, "stickied": false, "created": 1492465705.0, "created_utc": 1492436905.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dgcxtix", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "Isogash", "parent_id": "t3_65qhd0", "subreddit_name_prefixed": "r/gamedev", "controversiality": 0, "body": "I actually did something like this recently in Java and I could github it for you but it's not documented at all really.\n\nFirstly, I noticed that in ECS, you already kinda use events to activate systems, we just don't call them that. For example, when you do a frame update, all systems that need to process on a frame probably have an \"update(entity, delta)\" method.\n\nMy experiment was to generalise this, so that Systems declare arbritrary event types they are listening to, kinda like the observer pattern, but where the format of the method was \"onEvent(event, entity, world)\". This way I had FrameUpdateEvent for frame updates, DrawEvent for graphics events and many others. The Event objects held info like \"delta\" or in my Android version, the canvas object to draw on.\n\nI had two ways to fire events too. One where you could target a particular entity, and another general one where you could target all entities. As an example, my CollisionSystem would send a CollisionEvent to both entities involved in the collision, which could be handled by their own systems listening for collisions. I've not really had enough time to experiment further, but it's an interesting field of study.\n\nI don't personally encourage you to use a language with type erasure, like Java, for this though. I had no ends of problems trying to genericise everything, but it's possible to do nicely with annotations, or correctly but with some limitations.\n\nMy take away from the whole experiment was that ECS can be a fantastic way to really get thinking about composition, and absolutely amazing if you are dynamically creating new mixes of components, but really it's a lot of work that is completely unnecessary for a simple game, especially one with a limited development lifetime.\n\n", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I actually did something like this recently in Java and I could github it for you but it&amp;#39;s not documented at all really.&lt;/p&gt;\n\n&lt;p&gt;Firstly, I noticed that in ECS, you already kinda use events to activate systems, we just don&amp;#39;t call them that. For example, when you do a frame update, all systems that need to process on a frame probably have an &amp;quot;update(entity, delta)&amp;quot; method.&lt;/p&gt;\n\n&lt;p&gt;My experiment was to generalise this, so that Systems declare arbritrary event types they are listening to, kinda like the observer pattern, but where the format of the method was &amp;quot;onEvent(event, entity, world)&amp;quot;. This way I had FrameUpdateEvent for frame updates, DrawEvent for graphics events and many others. The Event objects held info like &amp;quot;delta&amp;quot; or in my Android version, the canvas object to draw on.&lt;/p&gt;\n\n&lt;p&gt;I had two ways to fire events too. One where you could target a particular entity, and another general one where you could target all entities. As an example, my CollisionSystem would send a CollisionEvent to both entities involved in the collision, which could be handled by their own systems listening for collisions. I&amp;#39;ve not really had enough time to experiment further, but it&amp;#39;s an interesting field of study.&lt;/p&gt;\n\n&lt;p&gt;I don&amp;#39;t personally encourage you to use a language with type erasure, like Java, for this though. I had no ends of problems trying to genericise everything, but it&amp;#39;s possible to do nicely with annotations, or correctly but with some limitations.&lt;/p&gt;\n\n&lt;p&gt;My take away from the whole experiment was that ECS can be a fantastic way to really get thinking about composition, and absolutely amazing if you are dynamically creating new mixes of components, but really it&amp;#39;s a lot of work that is completely unnecessary for a simple game, especially one with a limited development lifetime.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "gamedev", "name": "t1_dgcxtix", "score_hidden": false, "stickied": false, "created": 1492423118.0, "created_utc": 1492394318.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 3}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qi0a", "removal_reason": null, "link_id": "t3_65qhd0", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qi0a", "removal_reason": null, "link_id": "t3_65qhd0", "likes": null, "replies": "", "user_reports": [], "id": "dgdff1y", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "glacialthinker", "parent_id": "t1_dgcyjji", "subreddit_name_prefixed": "r/gamedev", "controversiality": 0, "body": "Where is our \"relevant xkcd\" for ECS? Stressing: component-major, not object-major -- most of the rest follows from this.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Where is our &amp;quot;relevant xkcd&amp;quot; for ECS? Stressing: component-major, not object-major -- most of the rest follows from this.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "gamedev", "name": "t1_dgdff1y", "score_hidden": false, "stickied": false, "created": 1492461627.0, "created_utc": 1492432827.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dgcyjji", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "tmachineorg", "parent_id": "t3_65qhd0", "subreddit_name_prefixed": "r/gamedev", "controversiality": 0, "body": "&gt; the more features I add, the more hoops I'm seeming to have to jump through in order to get the information I need, and it makes me feel like I'm starting to couple the code that I spent so long working to decouple.\n\nThis is why (almost) no-one uses Unity's approach. It's a poor design, it was a poor design 15 years ago when they started (albeit with relatively few people who had tried it), and it's merely coincidence that it's the design they got stuck with and can't change (without forcing everyone to learn a new approach for the new version of Unity).", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;blockquote&gt;\n&lt;p&gt;the more features I add, the more hoops I&amp;#39;m seeming to have to jump through in order to get the information I need, and it makes me feel like I&amp;#39;m starting to couple the code that I spent so long working to decouple.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;This is why (almost) no-one uses Unity&amp;#39;s approach. It&amp;#39;s a poor design, it was a poor design 15 years ago when they started (albeit with relatively few people who had tried it), and it&amp;#39;s merely coincidence that it&amp;#39;s the design they got stuck with and can&amp;#39;t change (without forcing everyone to learn a new approach for the new version of Unity).&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "gamedev", "name": "t1_dgcyjji", "score_hidden": false, "stickied": false, "created": 1492424128.0, "created_utc": 1492395328.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 3}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qi0a", "removal_reason": null, "link_id": "t3_65qhd0", "likes": null, "replies": "", "user_reports": [], "id": "dgck6oo", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "monkeedude1212", "parent_id": "t3_65qhd0", "subreddit_name_prefixed": "r/gamedev", "controversiality": 0, "body": "The reason why you only find them described outside the scope of ECS is because the designs aren't really related. They are also not exclusive, you can use both Event Queues and Observers where appropriate, you are not locked into one or the other. It's sort of like the For Loop and the While Loop. With a bit of 'break' trickery you can use either one for every looping scenario, but it'll be ugly code. Use a Queue where appropriate and use an Observer where appropriate. \n\nQueue's are great when multiple sources can input into the Queue. For instance, your keyboard treats every key as a separate source of input and when you press a key that key will fire off an event which is handled in your computer's hardware listening queue. In case your PC is capped at 100% CPU usage and it can't IMMEDIATELY handle the keypress, the keypress waits in a queue until it can be processed. This way not a single keypress will be missed, and your ability to input isn't delayed by your PC. For instance, if you had an observer system, and you pressed the space bar and it took 1 second for your system to handle all events observing the space bar, you get into a few messy scenarios. You must either send a callback to let the keyboard know you've received it's key and are capable of handling the next key; or if you go and thread it off then you run into potential race conditions where subsequent key presses on their own thread might be prioritised before the first thread, creating awful race conditions. A Queue guarantees First in First out for you, and makes it so that the keyboard doesn't need a callback, it can fire off events in a dumb manner.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;The reason why you only find them described outside the scope of ECS is because the designs aren&amp;#39;t really related. They are also not exclusive, you can use both Event Queues and Observers where appropriate, you are not locked into one or the other. It&amp;#39;s sort of like the For Loop and the While Loop. With a bit of &amp;#39;break&amp;#39; trickery you can use either one for every looping scenario, but it&amp;#39;ll be ugly code. Use a Queue where appropriate and use an Observer where appropriate. &lt;/p&gt;\n\n&lt;p&gt;Queue&amp;#39;s are great when multiple sources can input into the Queue. For instance, your keyboard treats every key as a separate source of input and when you press a key that key will fire off an event which is handled in your computer&amp;#39;s hardware listening queue. In case your PC is capped at 100% CPU usage and it can&amp;#39;t IMMEDIATELY handle the keypress, the keypress waits in a queue until it can be processed. This way not a single keypress will be missed, and your ability to input isn&amp;#39;t delayed by your PC. For instance, if you had an observer system, and you pressed the space bar and it took 1 second for your system to handle all events observing the space bar, you get into a few messy scenarios. You must either send a callback to let the keyboard know you&amp;#39;ve received it&amp;#39;s key and are capable of handling the next key; or if you go and thread it off then you run into potential race conditions where subsequent key presses on their own thread might be prioritised before the first thread, creating awful race conditions. A Queue guarantees First in First out for you, and makes it so that the keyboard doesn&amp;#39;t need a callback, it can fire off events in a dumb manner.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "gamedev", "name": "t1_dgck6oo", "score_hidden": false, "stickied": false, "created": 1492404829.0, "created_utc": 1492376029.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 2}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qi0a", "removal_reason": null, "link_id": "t3_65qhd0", "likes": null, "replies": "", "user_reports": [], "id": "dgcmreg", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "nerga", "parent_id": "t3_65qhd0", "subreddit_name_prefixed": "r/gamedev", "controversiality": 0, "body": "I would look into the visitor pattern. It should work fine with ecs, and should remove some of the parent checking.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I would look into the visitor pattern. It should work fine with ecs, and should remove some of the parent checking.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "gamedev", "name": "t1_dgcmreg", "score_hidden": false, "stickied": false, "created": 1492408222.0, "created_utc": 1492379422.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 1}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qi0a", "removal_reason": null, "link_id": "t3_65qhd0", "likes": null, "replies": "", "user_reports": [], "id": "dgcpogc", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "pakoito", "parent_id": "t3_65qhd0", "subreddit_name_prefixed": "r/gamedev", "controversiality": 0, "body": "You're thinking something more Reactive Programming, which is great and I've used it plenty for apps. Despite not having used it for game development, I saw that as the screens grew more and more complex, so did the system. The scope of a state on a GUI is a fraction of the complexity in a real-time system, and that's even before the performance requirements.\n\nECS with good system design will probably get you better bang for buck, both in modelling and performance. Cross-component communication seems like a recurring problem I see mentioned. If you consider a component as a way entities interact with each other, you can have an \"Inbox\" component where other entities can send messages to, which is process as the first system, and would modify the entity's components accordingly before the other systems kick in. It works exactly the same, it's just delayed by one frame.\n\nWhile that's one possible solution, it blows up the complexity because it forces you to create message semantics for what'd basically be a subset of possible mutations. Now, my question is, what kind of inter-component communication do you need to justify that?", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;You&amp;#39;re thinking something more Reactive Programming, which is great and I&amp;#39;ve used it plenty for apps. Despite not having used it for game development, I saw that as the screens grew more and more complex, so did the system. The scope of a state on a GUI is a fraction of the complexity in a real-time system, and that&amp;#39;s even before the performance requirements.&lt;/p&gt;\n\n&lt;p&gt;ECS with good system design will probably get you better bang for buck, both in modelling and performance. Cross-component communication seems like a recurring problem I see mentioned. If you consider a component as a way entities interact with each other, you can have an &amp;quot;Inbox&amp;quot; component where other entities can send messages to, which is process as the first system, and would modify the entity&amp;#39;s components accordingly before the other systems kick in. It works exactly the same, it&amp;#39;s just delayed by one frame.&lt;/p&gt;\n\n&lt;p&gt;While that&amp;#39;s one possible solution, it blows up the complexity because it forces you to create message semantics for what&amp;#39;d basically be a subset of possible mutations. Now, my question is, what kind of inter-component communication do you need to justify that?&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "gamedev", "name": "t1_dgcpogc", "score_hidden": false, "stickied": false, "created": 1492412159.0, "created_utc": 1492383359.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 1}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qi0a", "removal_reason": null, "link_id": "t3_65qhd0", "likes": null, "replies": "", "user_reports": [], "id": "dgde8i1", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "Merosi", "parent_id": "t3_65qhd0", "subreddit_name_prefixed": "r/gamedev", "controversiality": 0, "body": "i'm using artemis-odb, an ECS in java. they provide aspects, which match a certain query of components (it has and, or and exclude)\n\nduring the system's process(), it iterates over all entities matching those.\n\nso whenever i have a system that requires multiple components, i use the aspect to define which ones i need.   \nartemis-odb also provides injected component mappers, which let you do mapper.get(entityId) and it returns the component it maps for that entity.\n\nthis third option may be worth considering.  \nit's a very clean implementation of ECS, and it allows me to rip out the system and the components it uses, put it into any other game built with the same ECS and it will still make the state changes to it's components.  \nmaking the code not only reusable within my current project, but also future ones.\n\nit also solves your problem i think. the biggest thing is to keep your features in separate systems. the less each system has to individually do, the easier it becomes to manage and keep bugfree.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;i&amp;#39;m using artemis-odb, an ECS in java. they provide aspects, which match a certain query of components (it has and, or and exclude)&lt;/p&gt;\n\n&lt;p&gt;during the system&amp;#39;s process(), it iterates over all entities matching those.&lt;/p&gt;\n\n&lt;p&gt;so whenever i have a system that requires multiple components, i use the aspect to define which ones i need.&lt;br/&gt;\nartemis-odb also provides injected component mappers, which let you do mapper.get(entityId) and it returns the component it maps for that entity.&lt;/p&gt;\n\n&lt;p&gt;this third option may be worth considering.&lt;br/&gt;\nit&amp;#39;s a very clean implementation of ECS, and it allows me to rip out the system and the components it uses, put it into any other game built with the same ECS and it will still make the state changes to it&amp;#39;s components.&lt;br/&gt;\nmaking the code not only reusable within my current project, but also future ones.&lt;/p&gt;\n\n&lt;p&gt;it also solves your problem i think. the biggest thing is to keep your features in separate systems. the less each system has to individually do, the easier it becomes to manage and keep bugfree.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "gamedev", "name": "t1_dgde8i1", "score_hidden": false, "stickied": false, "created": 1492459171.0, "created_utc": 1492430371.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}]