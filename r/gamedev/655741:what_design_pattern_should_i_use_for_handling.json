[{"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t3", "data": {"contest_mode": false, "banned_by": null, "media_embed": {}, "subreddit": "gamedev", "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Picture a 2D game with a lot of UI interaction - something like starcraft. My game is not really like that but from a UI standpoint its similar. Meaning that there are tons of different things to click on, and they all do something different. &lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;m having a tough time with the code relating to the UI. Its not that the code is difficult to write, its just that there is SO much of it. Its very tedious to write and I dont have it structured very well so when I need to make a change, it takes me 5 minute to find the right spot in the code to make the change. Its well on it&amp;#39;s way to being spaghetti code.&lt;/p&gt;\n\n&lt;p&gt;Here are just a few examples of the type of thing I need to do:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;was the mouse clicked over this button?&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;if so, was it released over the button or off the button?&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;was the mouse clicked on this unit? &lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;was the mouse dragged after clicking on the unit?&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;was the mouse dragged after clicking next to the unit?&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;and if so does the box now contain the unit?&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;if a building was just placed (so the mouse is still down), do not select the building&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;however, during any other time if the mouse is down over a building, then DO select the building&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;if unit type C is clicked on, then display his stats in the side bar&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;however if building type A is already clicked on, then disallow clicking of unit type C&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;This is just a tiny sample. There are literally hundreds of different cases. I&amp;#39;m trying not to let all of this code be sprinkled all over the game code but its tough. My best attempt so far is to stick most of it into a big ugly class, so at least its centralized. However that big ugly class needs to be called from all over the game code, but I guess theres no avoiding that. &lt;/p&gt;\n\n&lt;p&gt;I think I need to re-evaluate how I&amp;#39;m doing this. There are tons of games with complicated UIs - how do they handle this? &lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "selftext": "Picture a 2D game with a lot of UI interaction - something like starcraft. My game is not really like that but from a UI standpoint its similar. Meaning that there are tons of different things to click on, and they all do something different. \n\nI'm having a tough time with the code relating to the UI. Its not that the code is difficult to write, its just that there is SO much of it. Its very tedious to write and I dont have it structured very well so when I need to make a change, it takes me 5 minute to find the right spot in the code to make the change. Its well on it's way to being spaghetti code.\n\nHere are just a few examples of the type of thing I need to do:\n\n* was the mouse clicked over this button?\n\n* if so, was it released over the button or off the button?\n* was the mouse clicked on this unit? \n* was the mouse dragged after clicking on the unit?\n* was the mouse dragged after clicking next to the unit?\n* and if so does the box now contain the unit?\n* if a building was just placed (so the mouse is still down), do not select the building\n* however, during any other time if the mouse is down over a building, then DO select the building\n* if unit type C is clicked on, then display his stats in the side bar\n* however if building type A is already clicked on, then disallow clicking of unit type C\n\nThis is just a tiny sample. There are literally hundreds of different cases. I'm trying not to let all of this code be sprinkled all over the game code but its tough. My best attempt so far is to stick most of it into a big ugly class, so at least its centralized. However that big ugly class needs to be called from all over the game code, but I guess theres no avoiding that. \n\nI think I need to re-evaluate how I'm doing this. There are tons of games with complicated UIs - how do they handle this? ", "likes": null, "suggested_sort": null, "user_reports": [], "secure_media": null, "link_flair_text": null, "id": "655741", "gilded": 0, "secure_media_embed": {}, "clicked": false, "score": 31, "report_reasons": null, "author": "beer0clock", "saved": false, "mod_reports": [], "name": "t3_655741", "subreddit_name_prefixed": "r/gamedev", "approved_by": null, "over_18": false, "domain": "self.gamedev", "hidden": false, "thumbnail": "", "subreddit_id": "t5_2qi0a", "edited": false, "link_flair_css_class": null, "author_flair_css_class": null, "downs": 0, "brand_safe": true, "archived": false, "removal_reason": null, "is_self": true, "hide_score": false, "spoiler": false, "permalink": "/r/gamedev/comments/655741/what_design_pattern_should_i_use_for_handling/", "num_reports": null, "locked": false, "stickied": false, "created": 1492115941.0, "url": "https://www.reddit.com/r/gamedev/comments/655741/what_design_pattern_should_i_use_for_handling/", "author_flair_text": null, "quarantine": false, "title": "What design pattern should I use for handling input for the UI?", "created_utc": 1492087141.0, "distinguished": null, "media": null, "upvote_ratio": 0.84, "num_comments": 9, "visited": false, "subreddit_type": "public", "ups": 31}}], "after": null, "before": null}}, {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qi0a", "removal_reason": null, "link_id": "t3_655741", "likes": null, "replies": "", "user_reports": [], "id": "dg7j2rz", "gilded": 0, "archived": false, "score": 14, "report_reasons": null, "author": "terryjsmith", "parent_id": "t3_655741", "subreddit_name_prefixed": "r/gamedev", "controversiality": 0, "body": "Most GUI frameworks are based around callbacks and/or the idea of hooks and slots (ie. Qt). So you would implement a base class (say GUIElement) with callbacks like onMouseDown, onMouseUp, onMouseMove, onDragStart, onDragEnd, etc. for mouse events. Your GUI system would then call these callbacks/fire events for affected objects and you can choose to bubble them up. So let's say you have a text label on top of your building and underneath that your Window. All of those (label, building, window) inherit from GUIElement. \n\nSo your GUI system polls for the mouse position and state and does the bulk of the work. Compared to the last poll, has the position changed? If so, has it entered the area of a new element? Fire the onMouseEnter event. Are we no longer positioned over an element we were last poll? Fire the onMouseLeave event. Did a button get pressed? If so, fire the onMouseDown event to any elements whose area the mouse inside of. Each of these events can return a boolean for whether the event was \"handled\" or should stop bubbling up. Your text label in my previous example likely doesn't have any of the functions overridden, so they return false (the default from GUIElement), so it bubbles it up to the next element in z-index order; in this case the building. The building then grabs that event and processes/stores whatever data it needs to (ie. in onMouseDown: was it just created? don't select it. otherwise, select it.). \n\nTaking this one step further, each GUIElement can also fire events that can be received. UnitSelected for example. Then your sidebar could handle that for units. BuildingSelected, etc. This reduces the need to throw code referencing other components all over the place. Your Building doesn't need to know the sidebar exists. It just needs to fire a BuildingSelected event and your Sidebar would capture and handle that event.\n\nIn my own engine, I take this one step further and say everything is inside of a Screen. My main menu is a Screen that contains GUI elements, but my gameplay HUD is also a Screen, it just contains a Scene as one of its elements. The Scene is therefore also a GUIElement and implements click handling for anything \"in game\" (ie. clicking a building or rendered object) and calls event handlers/throws new events as necessary.", "edited": 1492089952.0, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Most GUI frameworks are based around callbacks and/or the idea of hooks and slots (ie. Qt). So you would implement a base class (say GUIElement) with callbacks like onMouseDown, onMouseUp, onMouseMove, onDragStart, onDragEnd, etc. for mouse events. Your GUI system would then call these callbacks/fire events for affected objects and you can choose to bubble them up. So let&amp;#39;s say you have a text label on top of your building and underneath that your Window. All of those (label, building, window) inherit from GUIElement. &lt;/p&gt;\n\n&lt;p&gt;So your GUI system polls for the mouse position and state and does the bulk of the work. Compared to the last poll, has the position changed? If so, has it entered the area of a new element? Fire the onMouseEnter event. Are we no longer positioned over an element we were last poll? Fire the onMouseLeave event. Did a button get pressed? If so, fire the onMouseDown event to any elements whose area the mouse inside of. Each of these events can return a boolean for whether the event was &amp;quot;handled&amp;quot; or should stop bubbling up. Your text label in my previous example likely doesn&amp;#39;t have any of the functions overridden, so they return false (the default from GUIElement), so it bubbles it up to the next element in z-index order; in this case the building. The building then grabs that event and processes/stores whatever data it needs to (ie. in onMouseDown: was it just created? don&amp;#39;t select it. otherwise, select it.). &lt;/p&gt;\n\n&lt;p&gt;Taking this one step further, each GUIElement can also fire events that can be received. UnitSelected for example. Then your sidebar could handle that for units. BuildingSelected, etc. This reduces the need to throw code referencing other components all over the place. Your Building doesn&amp;#39;t need to know the sidebar exists. It just needs to fire a BuildingSelected event and your Sidebar would capture and handle that event.&lt;/p&gt;\n\n&lt;p&gt;In my own engine, I take this one step further and say everything is inside of a Screen. My main menu is a Screen that contains GUI elements, but my gameplay HUD is also a Screen, it just contains a Scene as one of its elements. The Scene is therefore also a GUIElement and implements click handling for anything &amp;quot;in game&amp;quot; (ie. clicking a building or rendered object) and calls event handlers/throws new events as necessary.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "gamedev", "name": "t1_dg7j2rz", "score_hidden": false, "stickied": false, "created": 1492118539.0, "created_utc": 1492089739.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 14}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qi0a", "removal_reason": null, "link_id": "t3_655741", "likes": null, "replies": "", "user_reports": [], "id": "dg7i5mi", "gilded": 0, "archived": false, "score": 11, "report_reasons": null, "author": "JetL33t", "parent_id": "t3_655741", "subreddit_name_prefixed": "r/gamedev", "controversiality": 0, "body": "Are you writing the whole UI framework from scratch?\n\nIf so, there are two patterns to look into: \n\n* [Observer Pattern](https://en.wikipedia.org/wiki/Observer_pattern)\n* [Composite Pattern](https://en.wikipedia.org/wiki/Composite_pattern)\n\nThose are patterns for traditional OOP UI frameworks.\n\nThat being said, you might want to look into html5 frameworks or write one yourself. Html5 is now dynamic enough to actually do alot of the heavy lifting for you, all you need to do is find a free browser backend like chromium and render that into a texture and route inputs to it and events from it, and you should be good to go.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Are you writing the whole UI framework from scratch?&lt;/p&gt;\n\n&lt;p&gt;If so, there are two patterns to look into: &lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"https://en.wikipedia.org/wiki/Observer_pattern\"&gt;Observer Pattern&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"https://en.wikipedia.org/wiki/Composite_pattern\"&gt;Composite Pattern&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Those are patterns for traditional OOP UI frameworks.&lt;/p&gt;\n\n&lt;p&gt;That being said, you might want to look into html5 frameworks or write one yourself. Html5 is now dynamic enough to actually do alot of the heavy lifting for you, all you need to do is find a free browser backend like chromium and render that into a texture and route inputs to it and events from it, and you should be good to go.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "gamedev", "name": "t1_dg7i5mi", "score_hidden": false, "stickied": false, "created": 1492117191.0, "created_utc": 1492088391.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 11}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qi0a", "removal_reason": null, "link_id": "t3_655741", "likes": null, "replies": "", "user_reports": [], "id": "dg7is7z", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "IggyZuk", "parent_id": "t3_655741", "subreddit_name_prefixed": "r/gamedev", "controversiality": 0, "body": "You should separate the concerns in different classes.\n\nThe UI should only be concerned with showing the elements for the currently selected unit. Each unit could, for example, have a function that returns a UIElements object contains all info about which buttons to create, and registers callbacks back to the unit.\n\nYou'd need a different system for selecting units, which can also contain the box selection code.\n\nHere is how I'd approach this with some pseudo code:\n\n    SelectionManager {\n    \tUIManager* ui;\n    \n    \tvoid Update() {\n    \t\t// if unit selected:\n    \t\t// ui.SetUIElements(unit.GetUIElements());\n    \t}\n    }\n    \n    UIManager {\n    \tvoid SetUIElements(UIElements elements) {\n    \t\t// for each button in elements create a new ui button\n    \t}\n    \tvoid PickPosition(Action&lt;Position&gt; callback) {\n    \t\t// allow use to pick position\n    \t\t// call the callback and pass in the position of the mouse\n    \t}\n    }\n    \n    UIElements {\n    \tButton[,] buttonGrid = new Button[3,3];\n    }\n    \n    Unit {\n    \tUIManager* ui;\n    \n    \tUIElements GetUIElements() {\n    \t\tUIElements elements = new Elements();\n    \t\telements.buttonGrid[0,0] = new Button(\"Move\", () =&gt; { ui.PickPosition(OnMove); }));\n    \t\telements.buttonGrid[1,0] = new Button(\"Attack\", () =&gt; { ui.PickPosition(OnAttack); });\n    \t}\n    \n    \tvoid OnMove(Position pos) {\n    \t\t// start movement of the unit to the position passed in args\n    \t}\n    \n    \tvoid OnAttack(Position pos) {\n    \t\t// go to position and attack the object near it\n    \t}\n    }", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;You should separate the concerns in different classes.&lt;/p&gt;\n\n&lt;p&gt;The UI should only be concerned with showing the elements for the currently selected unit. Each unit could, for example, have a function that returns a UIElements object contains all info about which buttons to create, and registers callbacks back to the unit.&lt;/p&gt;\n\n&lt;p&gt;You&amp;#39;d need a different system for selecting units, which can also contain the box selection code.&lt;/p&gt;\n\n&lt;p&gt;Here is how I&amp;#39;d approach this with some pseudo code:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;SelectionManager {\n    UIManager* ui;\n\n    void Update() {\n        // if unit selected:\n        // ui.SetUIElements(unit.GetUIElements());\n    }\n}\n\nUIManager {\n    void SetUIElements(UIElements elements) {\n        // for each button in elements create a new ui button\n    }\n    void PickPosition(Action&amp;lt;Position&amp;gt; callback) {\n        // allow use to pick position\n        // call the callback and pass in the position of the mouse\n    }\n}\n\nUIElements {\n    Button[,] buttonGrid = new Button[3,3];\n}\n\nUnit {\n    UIManager* ui;\n\n    UIElements GetUIElements() {\n        UIElements elements = new Elements();\n        elements.buttonGrid[0,0] = new Button(&amp;quot;Move&amp;quot;, () =&amp;gt; { ui.PickPosition(OnMove); }));\n        elements.buttonGrid[1,0] = new Button(&amp;quot;Attack&amp;quot;, () =&amp;gt; { ui.PickPosition(OnAttack); });\n    }\n\n    void OnMove(Position pos) {\n        // start movement of the unit to the position passed in args\n    }\n\n    void OnAttack(Position pos) {\n        // go to position and attack the object near it\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;", "subreddit": "gamedev", "name": "t1_dg7is7z", "score_hidden": false, "stickied": false, "created": 1492118122.0, "created_utc": 1492089322.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 3}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qi0a", "removal_reason": null, "link_id": "t3_655741", "likes": null, "replies": "", "user_reports": [], "id": "dg7n7g9", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "eightvo", "parent_id": "t3_655741", "subreddit_name_prefixed": "r/gamedev", "controversiality": 0, "body": "I use a tree of controls where each control contains a list of children controls. I have a Gui object that contains a list of all the \"top level\" controls. Each control also has a z-index (a z-index of 0 is behind a z-index of 1).\n\n&gt;was the mouse clicked over this button?\n\nTo determine this I would iterate the TopLevel controls in descending zorder checking if the mouse position at the time of the check was within the bounds of the control. If it was, then I iterate the children controls to find which child control the mouse was over. I do this until I find a control that has no subcontrols where the mouse is hovering... then this controls root is brought to the front (by increasing the z-index) and the control set as the \"focused\" control, all the controls between it and the root are marked as \"containing\" the focused control and the MouseDown event is fired for that control.\n\n&gt;if so, was it released over the button or off the button?\n\n I don't care about the if so... I just do the same operation to find the hovered control and fire the mouseUp event of the control. Each event type cares about where the mouse is differently. For example, the mouse down and mouse up should almost never occur on a control that the mouse wasn't actually hovering over when the event occured... but a mouse wheel event? A mouse wheel event might make more sense to apply to the focused control if it exists before even checking which control the mouse is hovering over. A key down/key up event only fires on the focused control even if the mouse is hovering over a control at the time. \n\n&gt;was the mouse clicked on this unit? \n\n If the mouse isn't hovered over a GUI control, use a similar process to find the hovered \"unit\"/\"game entity\"\n\n&gt;was the mouse dragged after clicking on the unit?\n\n This is too complex to worry about, instead... worry about was the unit \"picked up\" if so, set it as the draged object. Was the mouse moved while a dragged object existed? If so move the dragged object. Was the mouse released while a dragged object exists? If so find the control/object it was dropped onto and fire the object dropped event.\n\n&gt;was the mouse dragged after clicking next to the unit?\n\n  Again, a bit more complex then you want to think about... just check the start and end points. Basically for dragging, you want to break it into three distinct segments... what to do when the mouse is pressed on the object, what to do when the mouse is moved while this is the selected object and what to do when the mouse is released on the object.\n\n&gt;If so does the box now contain the unit?\n \n If you fire a ObjectDropped event then this question never should come up... the box will only fire the event when it contains the unit.\n\n&gt;If a build was just placed, do not select the building\n\n Select objects on MouseDown, build the building on mouseup... this way when the click the mouse down nothing gets selected because is isn't there yet.\n\n&gt;however, during any other time if the mouse is down over a building, then DO select the building\n\n Same solution as before, select on mousedown, build on mouseup\n\n&gt;if unit type C is clicked on, then display his stats in the side bar\n\n An object should handle it's own logic on what to do when an event happens... in a sense, the GUI is only there to alert the object that the event occurred.\n\n&gt;however if building type A is already clicked on, then disallow clicking of unit type C\n\n  This is handled through the focused control and the selection method... the object that you are attempting to pick up should be able to determine if the focused object prevents it from being selectable or not.\n", "edited": 1492095069.0, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I use a tree of controls where each control contains a list of children controls. I have a Gui object that contains a list of all the &amp;quot;top level&amp;quot; controls. Each control also has a z-index (a z-index of 0 is behind a z-index of 1).&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;was the mouse clicked over this button?&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;To determine this I would iterate the TopLevel controls in descending zorder checking if the mouse position at the time of the check was within the bounds of the control. If it was, then I iterate the children controls to find which child control the mouse was over. I do this until I find a control that has no subcontrols where the mouse is hovering... then this controls root is brought to the front (by increasing the z-index) and the control set as the &amp;quot;focused&amp;quot; control, all the controls between it and the root are marked as &amp;quot;containing&amp;quot; the focused control and the MouseDown event is fired for that control.&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;if so, was it released over the button or off the button?&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;I don&amp;#39;t care about the if so... I just do the same operation to find the hovered control and fire the mouseUp event of the control. Each event type cares about where the mouse is differently. For example, the mouse down and mouse up should almost never occur on a control that the mouse wasn&amp;#39;t actually hovering over when the event occured... but a mouse wheel event? A mouse wheel event might make more sense to apply to the focused control if it exists before even checking which control the mouse is hovering over. A key down/key up event only fires on the focused control even if the mouse is hovering over a control at the time. &lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;was the mouse clicked on this unit? &lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;If the mouse isn&amp;#39;t hovered over a GUI control, use a similar process to find the hovered &amp;quot;unit&amp;quot;/&amp;quot;game entity&amp;quot;&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;was the mouse dragged after clicking on the unit?&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;This is too complex to worry about, instead... worry about was the unit &amp;quot;picked up&amp;quot; if so, set it as the draged object. Was the mouse moved while a dragged object existed? If so move the dragged object. Was the mouse released while a dragged object exists? If so find the control/object it was dropped onto and fire the object dropped event.&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;was the mouse dragged after clicking next to the unit?&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Again, a bit more complex then you want to think about... just check the start and end points. Basically for dragging, you want to break it into three distinct segments... what to do when the mouse is pressed on the object, what to do when the mouse is moved while this is the selected object and what to do when the mouse is released on the object.&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;If so does the box now contain the unit?&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;If you fire a ObjectDropped event then this question never should come up... the box will only fire the event when it contains the unit.&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;If a build was just placed, do not select the building&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Select objects on MouseDown, build the building on mouseup... this way when the click the mouse down nothing gets selected because is isn&amp;#39;t there yet.&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;however, during any other time if the mouse is down over a building, then DO select the building&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Same solution as before, select on mousedown, build on mouseup&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;if unit type C is clicked on, then display his stats in the side bar&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;An object should handle it&amp;#39;s own logic on what to do when an event happens... in a sense, the GUI is only there to alert the object that the event occurred.&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;however if building type A is already clicked on, then disallow clicking of unit type C&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;This is handled through the focused control and the selection method... the object that you are attempting to pick up should be able to determine if the focused object prevents it from being selectable or not.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "gamedev", "name": "t1_dg7n7g9", "score_hidden": false, "stickied": false, "created": 1492123680.0, "created_utc": 1492094880.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 2}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qi0a", "removal_reason": null, "link_id": "t3_655741", "likes": null, "replies": "", "user_reports": [], "id": "dg7nfbn", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "RemyArmstro", "parent_id": "t3_655741", "subreddit_name_prefixed": "r/gamedev", "controversiality": 0, "body": "I just finished implementing input processing in my game, so I can tell you what I did.  So far, it seems to be working for me, and keeps all my input logic contained to one location.\n\nMy game has a input queue, and as the users does things, it queues up their inputs.  I then have a InputSystem that dequeues these inputs during each game loop. I have a player object that keeps track of \"down\" inputs (through a button HashSet).  If the InputSystem sees the button as a down, it processes the input, but also adds the button to the HashSet.  If it is an up event, it just removes it from the HashSet. Held buttons are actually sent as down events again at the beginning of each loop. The input also has coordinates for where the pointer was when the event happened.  This allows me to process all kinds of input events, including selections, drags, etc. - and in the order they were sent.\n\nThe input system doesn't have any of the individual entity behavior logic.  Instead it does one of two things as it processes each individual event... \n\n- If it is a default pointer (like a left mouse click - depending on key mapping), it gets entities that are colliding with the pointer location, and the first one (top down) that is listening for that input will swallow it.\n- If it is any other event, it first sees if a selected entity can handle the input. If not, it sees if the character can handle the input.  The first one that can, swallows it.\n\nThe swallowed inputs are processed when the applicable system runs.  For example, if a select input was swallowed, then my selectComponent would have that captured input... when the SelectSystem runs, it will process that input update the component state appropriately.\n\nEdit: FYI - I am using Phaser.io to actually capture the browser inputs and send them to the server.  The server input processing is the part I was describing above.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I just finished implementing input processing in my game, so I can tell you what I did.  So far, it seems to be working for me, and keeps all my input logic contained to one location.&lt;/p&gt;\n\n&lt;p&gt;My game has a input queue, and as the users does things, it queues up their inputs.  I then have a InputSystem that dequeues these inputs during each game loop. I have a player object that keeps track of &amp;quot;down&amp;quot; inputs (through a button HashSet).  If the InputSystem sees the button as a down, it processes the input, but also adds the button to the HashSet.  If it is an up event, it just removes it from the HashSet. Held buttons are actually sent as down events again at the beginning of each loop. The input also has coordinates for where the pointer was when the event happened.  This allows me to process all kinds of input events, including selections, drags, etc. - and in the order they were sent.&lt;/p&gt;\n\n&lt;p&gt;The input system doesn&amp;#39;t have any of the individual entity behavior logic.  Instead it does one of two things as it processes each individual event... &lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;If it is a default pointer (like a left mouse click - depending on key mapping), it gets entities that are colliding with the pointer location, and the first one (top down) that is listening for that input will swallow it.&lt;/li&gt;\n&lt;li&gt;If it is any other event, it first sees if a selected entity can handle the input. If not, it sees if the character can handle the input.  The first one that can, swallows it.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;The swallowed inputs are processed when the applicable system runs.  For example, if a select input was swallowed, then my selectComponent would have that captured input... when the SelectSystem runs, it will process that input update the component state appropriately.&lt;/p&gt;\n\n&lt;p&gt;Edit: FYI - I am using Phaser.io to actually capture the browser inputs and send them to the server.  The server input processing is the part I was describing above.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "gamedev", "name": "t1_dg7nfbn", "score_hidden": false, "stickied": false, "created": 1492123931.0, "created_utc": 1492095131.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 2}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qi0a", "removal_reason": null, "link_id": "t3_655741", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qi0a", "removal_reason": null, "link_id": "t3_655741", "likes": null, "replies": "", "user_reports": [], "id": "dg8ap3t", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "mduffor", "parent_id": "t1_dg7jr1e", "subreddit_name_prefixed": "r/gamedev", "controversiality": 0, "body": "I used to be a fan of Immediate Mode Graphical User Interfaces (IMGUI), and they are great for some games where things are redrawn every frame.  But when you start getting into more complex controls that have animations associated with them or are expensive to build or batch in 3D, IMGUI breaks down and you have to look at more retained-mode approaches.  It is definitely worth knowing about them and how they work though.\n", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I used to be a fan of Immediate Mode Graphical User Interfaces (IMGUI), and they are great for some games where things are redrawn every frame.  But when you start getting into more complex controls that have animations associated with them or are expensive to build or batch in 3D, IMGUI breaks down and you have to look at more retained-mode approaches.  It is definitely worth knowing about them and how they work though.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "gamedev", "name": "t1_dg8ap3t", "score_hidden": false, "stickied": false, "created": 1492149475.0, "created_utc": 1492120675.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 2}}], "after": null, "before": null}}, "user_reports": [], "id": "dg7jr1e", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "eliscmj", "parent_id": "t3_655741", "subreddit_name_prefixed": "r/gamedev", "controversiality": 1, "body": "I don't have the time to read through your post so this might not be of interest to you. \n\n[(YouTube) Immediate-Mode Graphical User Interfaces](https://www.youtube.com/watch?v=Z1qyvQsjK5Y)", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I don&amp;#39;t have the time to read through your post so this might not be of interest to you. &lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://www.youtube.com/watch?v=Z1qyvQsjK5Y\"&gt;(YouTube) Immediate-Mode Graphical User Interfaces&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "gamedev", "name": "t1_dg7jr1e", "score_hidden": false, "stickied": false, "created": 1492119451.0, "created_utc": 1492090651.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 1}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qi0a", "removal_reason": null, "link_id": "t3_655741", "likes": null, "replies": "", "user_reports": [], "id": "dg86nou", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "3fox", "parent_id": "t3_655741", "subreddit_name_prefixed": "r/gamedev", "controversiality": 0, "body": "The secret is that nobody is actually happy with their UI code and they're always looking for a silver bullet. It's expensive to develop a UI. Most experienced people in games will suggest using the [\"immediate mode\"](https://github.com/ocornut/imgui) pattern, which follows down the path of taking the raw mouse input and converting it into state changes and visuals, and organizing that into a library of \"immediate\" function calls that give you full control over execution flow and parameters. Folks drawing on \"traditional\" forms-and-documents interfaces will instead suggest a retained mode system where you create a hierarchy of prefab nodes(widgets and layout), attach properties and event listeners to them, call a single \"update\" or \"render\" function, and then do all the custom programming in callbacks.\n\nRetained GUI exaggerates the difficulty of custom widgets and layout of dynamic quantities of items, as it tends to deny fine control over how things are computed. You still end up with event spaghetti, because making all the event callbacks do the things you want in the order you want them is non-obvious, especially if the GUI also has dynamic elements that get attached and detached, animations, or other such concepts that play together poorly with events. But it also greatly eases basic situations, and being within one generalized system, there are opportunities for automatic optimization. So working with a retained framework can be faster, at least at first, and then become painful only later. This has led to a variety of GUI abstraction patterns to help separate concerns(e.g. [MVVM](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel)). But in truth, I think the reason why it became popular in the first place was because early GUI systems were heavily bottlenecked on drawing pixels, and in this kind of system, you get very good control over minimizing how many pixels you have to paint. That's no longer a real issue for any modern graphics device, so we're in a world coasting on a paradigm that might have gone obsolete.\n\nIMGUI makes it easier to do weird custom things, and most substantial UIs will need at least one weird thing. I now employ it wherever I'm not compelled to do otherwise by platform/ecosystem considerations. IMGUI puts all the burden of state management on you, and that's always a good recipe for making a mess. The basic trick to doing immediate mode without having painful spaghetti logic is to allow elements to be rendered more than once in a frame for different purposes. To do automatic layout, for example, you may have to render interior widgets to compute their size. To do mouse hover types of things, you may have to render the collision of the involved rectangles before you go to draw them. The gameplay logic may also be compelled to generate \"report data\" during events so that the GUI can rely on the reports instead of trying to reconstruct what an event did. The resulting code is initially lengthy and repetitive, but you can gradually turn the repeating elements into data, and even cache parts of the data, to get a \"retained-immediate\" kind of scenario where the UI is \"data-driven, except for the parts that aren't.\" This also creates a separation of concerns similar to, while still being different from, the retained-mode abstractions I alluded to earlier.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;The secret is that nobody is actually happy with their UI code and they&amp;#39;re always looking for a silver bullet. It&amp;#39;s expensive to develop a UI. Most experienced people in games will suggest using the &lt;a href=\"https://github.com/ocornut/imgui\"&gt;&amp;quot;immediate mode&amp;quot;&lt;/a&gt; pattern, which follows down the path of taking the raw mouse input and converting it into state changes and visuals, and organizing that into a library of &amp;quot;immediate&amp;quot; function calls that give you full control over execution flow and parameters. Folks drawing on &amp;quot;traditional&amp;quot; forms-and-documents interfaces will instead suggest a retained mode system where you create a hierarchy of prefab nodes(widgets and layout), attach properties and event listeners to them, call a single &amp;quot;update&amp;quot; or &amp;quot;render&amp;quot; function, and then do all the custom programming in callbacks.&lt;/p&gt;\n\n&lt;p&gt;Retained GUI exaggerates the difficulty of custom widgets and layout of dynamic quantities of items, as it tends to deny fine control over how things are computed. You still end up with event spaghetti, because making all the event callbacks do the things you want in the order you want them is non-obvious, especially if the GUI also has dynamic elements that get attached and detached, animations, or other such concepts that play together poorly with events. But it also greatly eases basic situations, and being within one generalized system, there are opportunities for automatic optimization. So working with a retained framework can be faster, at least at first, and then become painful only later. This has led to a variety of GUI abstraction patterns to help separate concerns(e.g. &lt;a href=\"https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel\"&gt;MVVM&lt;/a&gt;). But in truth, I think the reason why it became popular in the first place was because early GUI systems were heavily bottlenecked on drawing pixels, and in this kind of system, you get very good control over minimizing how many pixels you have to paint. That&amp;#39;s no longer a real issue for any modern graphics device, so we&amp;#39;re in a world coasting on a paradigm that might have gone obsolete.&lt;/p&gt;\n\n&lt;p&gt;IMGUI makes it easier to do weird custom things, and most substantial UIs will need at least one weird thing. I now employ it wherever I&amp;#39;m not compelled to do otherwise by platform/ecosystem considerations. IMGUI puts all the burden of state management on you, and that&amp;#39;s always a good recipe for making a mess. The basic trick to doing immediate mode without having painful spaghetti logic is to allow elements to be rendered more than once in a frame for different purposes. To do automatic layout, for example, you may have to render interior widgets to compute their size. To do mouse hover types of things, you may have to render the collision of the involved rectangles before you go to draw them. The gameplay logic may also be compelled to generate &amp;quot;report data&amp;quot; during events so that the GUI can rely on the reports instead of trying to reconstruct what an event did. The resulting code is initially lengthy and repetitive, but you can gradually turn the repeating elements into data, and even cache parts of the data, to get a &amp;quot;retained-immediate&amp;quot; kind of scenario where the UI is &amp;quot;data-driven, except for the parts that aren&amp;#39;t.&amp;quot; This also creates a separation of concerns similar to, while still being different from, the retained-mode abstractions I alluded to earlier.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "gamedev", "name": "t1_dg86nou", "score_hidden": false, "stickied": false, "created": 1492144638.0, "created_utc": 1492115838.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 1}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qi0a", "removal_reason": null, "link_id": "t3_655741", "likes": null, "replies": "", "user_reports": [], "id": "dg8ntuu", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "JJagaimo", "parent_id": "t3_655741", "subreddit_name_prefixed": "r/gamedev", "controversiality": 0, "body": "If you are still planning on rolling your own UI, then you may be interested in this. I am by no means a professional, and my methods may be offensive to some.\n\nI was making a game a while ago in C# that was heavily UI based. In order to do this, I had a base UIControl class which the others (UIButton, slider, textbox, etc.) were derived from. This carried the brunt of the mouse handling. I used a UI handler that contained all of the UI controls. The UI is separate from the input handler. \n\n    INPUT\n\nFirstly, how to tell if it was clicked on: I used an input handler with three functions: isNewPress, isCurPress, and isOldPress. There are two recorded states of the keyboard/mouse (oldState, newState), and this allows it to check whether we have a new keypress (pressed only in the newState), a currently pressed/held key (pressed in both old and new States), or an old press / released key (pressed only in the oldState). This may conflict with the event driven way many others deal with input.\n\n    CHECKING FOR MOUSE PRESS\n\nI could tell if I had just clicked on it by checking if the mouse press was within its bounds. I could check if it was being long clicked with an internal flag set in the initial click (isNewPress) and the isCurPress function. I could also tell if it was being dragged by storing the location of the mouse in the initial click. The stored position could be compared to the mouse position on release (isOldPress). Double clicks could be done by passing the timer to the UIControl and then saving the time, checking to see how much it had changed by since the last press. If the time was under a certain amount, say 250ms, then it is considered a double click.\n\n    EVENTS\n\nIt also made use of **Events** to signal anyone/anything listening that it was clicked. Instead of one button per needed function, you can create a button class, then bind a function to the event in the button class. That is to say, the button has no idea what it's going to be calling, but it will call any function you want to attach to it (with the proper arguments). \n\n    HOW IT ALL WORKS TOGETHER\n\nNow, I could tell the UIHandler to create a button at {x,y} (the button being a class derived from UIControl), and then bind a function to the click event of that button. Then I could update the UIHandler, passing in the inputHandler, which allows the UIHandler to poll which keys/mouse buttons are pressed. Then, the UIHandler updates each of it's UIControls, which will send an event if it is pressed.\n\n    BENEFITS\n\nHere are some of your issues my method could help solve:\n\n* \"if a building was just placed (so the mouse is still down), do not select the building\" - use isNewPress / check against the previous state\n\n* \"if unit type C is clicked on, then display his stats in the side bar\" - Events solve this. Have units with similar code (inherit or include or something) and then either bind to the event to show the stats/set the variables to show the stats\n\n* \"was the mouse dragged after clicking on the unit?\"\n\n* \"was the mouse clicked over this button?\" - Check the mouse position (passed w/ input handler) against the bounds of the button\n\n* \"if so, was it released over the button or off the button?\" - Check the mouse position (passed w/ input handler) against the saved position", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;If you are still planning on rolling your own UI, then you may be interested in this. I am by no means a professional, and my methods may be offensive to some.&lt;/p&gt;\n\n&lt;p&gt;I was making a game a while ago in C# that was heavily UI based. In order to do this, I had a base UIControl class which the others (UIButton, slider, textbox, etc.) were derived from. This carried the brunt of the mouse handling. I used a UI handler that contained all of the UI controls. The UI is separate from the input handler. &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;INPUT\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Firstly, how to tell if it was clicked on: I used an input handler with three functions: isNewPress, isCurPress, and isOldPress. There are two recorded states of the keyboard/mouse (oldState, newState), and this allows it to check whether we have a new keypress (pressed only in the newState), a currently pressed/held key (pressed in both old and new States), or an old press / released key (pressed only in the oldState). This may conflict with the event driven way many others deal with input.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;CHECKING FOR MOUSE PRESS\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I could tell if I had just clicked on it by checking if the mouse press was within its bounds. I could check if it was being long clicked with an internal flag set in the initial click (isNewPress) and the isCurPress function. I could also tell if it was being dragged by storing the location of the mouse in the initial click. The stored position could be compared to the mouse position on release (isOldPress). Double clicks could be done by passing the timer to the UIControl and then saving the time, checking to see how much it had changed by since the last press. If the time was under a certain amount, say 250ms, then it is considered a double click.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;EVENTS\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It also made use of &lt;strong&gt;Events&lt;/strong&gt; to signal anyone/anything listening that it was clicked. Instead of one button per needed function, you can create a button class, then bind a function to the event in the button class. That is to say, the button has no idea what it&amp;#39;s going to be calling, but it will call any function you want to attach to it (with the proper arguments). &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;HOW IT ALL WORKS TOGETHER\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now, I could tell the UIHandler to create a button at {x,y} (the button being a class derived from UIControl), and then bind a function to the click event of that button. Then I could update the UIHandler, passing in the inputHandler, which allows the UIHandler to poll which keys/mouse buttons are pressed. Then, the UIHandler updates each of it&amp;#39;s UIControls, which will send an event if it is pressed.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;BENEFITS\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here are some of your issues my method could help solve:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;&amp;quot;if a building was just placed (so the mouse is still down), do not select the building&amp;quot; - use isNewPress / check against the previous state&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&amp;quot;if unit type C is clicked on, then display his stats in the side bar&amp;quot; - Events solve this. Have units with similar code (inherit or include or something) and then either bind to the event to show the stats/set the variables to show the stats&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&amp;quot;was the mouse dragged after clicking on the unit?&amp;quot;&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&amp;quot;was the mouse clicked over this button?&amp;quot; - Check the mouse position (passed w/ input handler) against the bounds of the button&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&amp;quot;if so, was it released over the button or off the button?&amp;quot; - Check the mouse position (passed w/ input handler) against the saved position&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/div&gt;", "subreddit": "gamedev", "name": "t1_dg8ntuu", "score_hidden": false, "stickied": false, "created": 1492167404.0, "created_utc": 1492138604.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}]