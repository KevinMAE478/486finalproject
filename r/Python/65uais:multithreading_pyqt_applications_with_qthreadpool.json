[{"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t3", "data": {"contest_mode": false, "banned_by": null, "media_embed": {}, "subreddit": "Python", "selftext_html": null, "selftext": "", "likes": null, "suggested_sort": null, "user_reports": [], "secure_media": null, "link_flair_text": null, "id": "65uais", "gilded": 0, "secure_media_embed": {}, "clicked": false, "score": 134, "report_reasons": null, "author": "mfitzp", "saved": false, "mod_reports": [], "name": "t3_65uais", "subreddit_name_prefixed": "r/Python", "approved_by": null, "over_18": false, "domain": "mfitzp.io", "hidden": false, "thumbnail": "", "subreddit_id": "t5_2qh0y", "edited": false, "link_flair_css_class": null, "author_flair_css_class": "", "downs": 0, "brand_safe": true, "archived": false, "removal_reason": null, "is_self": false, "hide_score": false, "spoiler": false, "permalink": "/r/Python/comments/65uais/multithreading_pyqt_applications_with_qthreadpool/", "num_reports": null, "locked": false, "stickied": false, "created": 1492444761.0, "url": "https://mfitzp.io/article/multithreading-pyqt-applications-with-qthreadpool/", "author_flair_text": "mfitzp.io", "quarantine": false, "title": "Multithreading PyQt applications with QThreadPool", "created_utc": 1492415961.0, "distinguished": null, "media": null, "upvote_ratio": 0.92, "num_comments": 11, "visited": false, "subreddit_type": "public", "ups": 134}}], "after": null, "before": null}}, {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65uais", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65uais", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65uais", "likes": null, "replies": "", "user_reports": [], "id": "dgdfkn9", "gilded": 0, "archived": false, "score": 18, "report_reasons": null, "author": "BlinkingZeroes", "parent_id": "t1_dgdfhnx", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "*bleeds out of his eyeballs*", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;&lt;em&gt;bleeds out of his eyeballs&lt;/em&gt;&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dgdfkn9", "score_hidden": false, "stickied": false, "created": 1492461924.0, "created_utc": 1492433124.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 18}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65uais", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65uais", "likes": null, "replies": "", "user_reports": [], "id": "dgdv46u", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "lazypenguin18", "parent_id": "t1_dgdkj68", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "https://woboq.com/blog/qthread-you-were-not-doing-so-wrong.html", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;&lt;a href=\"https://woboq.com/blog/qthread-you-were-not-doing-so-wrong.html\"&gt;https://woboq.com/blog/qthread-you-were-not-doing-so-wrong.html&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dgdv46u", "score_hidden": false, "stickied": false, "created": 1492481455.0, "created_utc": 1492452655.0, "depth": 3, "mod_reports": [], "subreddit_type": "public", "ups": 2}}], "after": null, "before": null}}, "user_reports": [], "id": "dgdkj68", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "whereswalden90", "parent_id": "t1_dgdfhnx", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "Link?", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Link?&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dgdkj68", "score_hidden": false, "stickied": false, "created": 1492469422.0, "created_utc": 1492440622.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 3}}], "after": null, "before": null}}, "user_reports": [], "id": "dgdfhnx", "gilded": 0, "archived": false, "score": 6, "report_reasons": null, "author": "lazypenguin18", "parent_id": "t1_dgdexyh", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "FWIW there is a second blog post from another Qt dev that counters that post somewhat. \n\nEdit: https://woboq.com/blog/qthread-you-were-not-doing-so-wrong.html", "edited": 1492452733.0, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;FWIW there is a second blog post from another Qt dev that counters that post somewhat. &lt;/p&gt;\n\n&lt;p&gt;Edit: &lt;a href=\"https://woboq.com/blog/qthread-you-were-not-doing-so-wrong.html\"&gt;https://woboq.com/blog/qthread-you-were-not-doing-so-wrong.html&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dgdfhnx", "score_hidden": false, "stickied": false, "created": 1492461763.0, "created_utc": 1492432963.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 6}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65uais", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65uais", "likes": null, "replies": "", "user_reports": [], "id": "dgdqcmr", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "BlinkingZeroes", "parent_id": "t1_dgdn73t", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "&gt;On the PyQt5 front, you're in luck. This should work as-is with PyQt4 (just change the imports).\n\nBrilliant! Thanks again!", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;blockquote&gt;\n&lt;p&gt;On the PyQt5 front, you&amp;#39;re in luck. This should work as-is with PyQt4 (just change the imports).&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Brilliant! Thanks again!&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dgdqcmr", "score_hidden": false, "stickied": false, "created": 1492476183.0, "created_utc": 1492447383.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dgdn73t", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "mfitzp", "parent_id": "t1_dgdexyh", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "I had exactly the same experience, only finding the right way to do it after finding (and spending a lot of time on) the wrong way. Hopefully posting this increases the odds for the next person.\n\nOn the PyQt5 front, you're in luck. This should work as-is with PyQt4 (just change the imports).", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I had exactly the same experience, only finding the right way to do it after finding (and spending a lot of time on) the wrong way. Hopefully posting this increases the odds for the next person.&lt;/p&gt;\n\n&lt;p&gt;On the PyQt5 front, you&amp;#39;re in luck. This should work as-is with PyQt4 (just change the imports).&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dgdn73t", "score_hidden": false, "stickied": false, "created": 1492472624.0, "created_utc": 1492443824.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 2}}], "after": null, "before": null}}, "user_reports": [], "id": "dgdexyh", "gilded": 0, "archived": false, "score": 19, "report_reasons": null, "author": "BlinkingZeroes", "parent_id": "t3_65uais", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "Honestly, I needed this so badly. \n\nI'm very new to PyQT and I'd only just gotten around interface freezing using QThread, then I discover a blog post by one of the creators that tells me this is the wrong way to use QThread... I followed the documentation!\n\nAm bookmarking this and will give it a bash tomorrow. We're currently using PyQT4, though this might push me to 5.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Honestly, I needed this so badly. &lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;m very new to PyQT and I&amp;#39;d only just gotten around interface freezing using QThread, then I discover a blog post by one of the creators that tells me this is the wrong way to use QThread... I followed the documentation!&lt;/p&gt;\n\n&lt;p&gt;Am bookmarking this and will give it a bash tomorrow. We&amp;#39;re currently using PyQT4, though this might push me to 5.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dgdexyh", "score_hidden": false, "stickied": false, "created": 1492460696.0, "created_utc": 1492431896.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 19}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65uais", "likes": null, "replies": "", "user_reports": [], "id": "dgdinjv", "gilded": 0, "archived": false, "score": 4, "report_reasons": null, "author": "epage", "parent_id": "t3_65uais", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "Back when I was still doing PyQt applications, I ended up creating an async/await-like approach to manage this to simplify my callback handling\n\nCalling the async/await function\nhttps://github.com/epage/DialCentral/blob/master/dialcentral/session.py#L283\n\nAsync/await function\nhttps://github.com/epage/DialCentral/blob/master/dialcentral/session.py#L444\n\nEverything in the function body runs on the UI thread while everything that yields is run on a background thread.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Back when I was still doing PyQt applications, I ended up creating an async/await-like approach to manage this to simplify my callback handling&lt;/p&gt;\n\n&lt;p&gt;Calling the async/await function\n&lt;a href=\"https://github.com/epage/DialCentral/blob/master/dialcentral/session.py#L283\"&gt;https://github.com/epage/DialCentral/blob/master/dialcentral/session.py#L283&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Async/await function\n&lt;a href=\"https://github.com/epage/DialCentral/blob/master/dialcentral/session.py#L444\"&gt;https://github.com/epage/DialCentral/blob/master/dialcentral/session.py#L444&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Everything in the function body runs on the UI thread while everything that yields is run on a background thread.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dgdinjv", "score_hidden": false, "stickied": false, "created": 1492466903.0, "created_utc": 1492438103.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 4}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65uais", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65uais", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65uais", "likes": null, "replies": "", "user_reports": [], "id": "dgdtnzr", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "bheklilr", "parent_id": "t1_dgdoc7n", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "&gt; That said, if you're using Python 3 and have access to concurrent.futures then you already get this too.\n\nPython 2 has a thread pool through `multiprocessing.dummy.Pool`, but it's not quite as nice of an interface as `concurrent.futures`.  There is a backport of `concurrent.futures` is available for Python 2 too.\n\nOne thing that I'd really like to know is how these threads perform against Python threads (and maybe other alternatives, too).  If you're firing off enough threads to be worried about using a pool, this would be pretty important information.  I also am hesitant to tie my background work so closely with what my frontend is doing.  If I want to make my tool have a CLI as well as a GUI (something that isn't uncommon in my line of work) then it's best to have those concerns separated as much as possible.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;blockquote&gt;\n&lt;p&gt;That said, if you&amp;#39;re using Python 3 and have access to concurrent.futures then you already get this too.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Python 2 has a thread pool through &lt;code&gt;multiprocessing.dummy.Pool&lt;/code&gt;, but it&amp;#39;s not quite as nice of an interface as &lt;code&gt;concurrent.futures&lt;/code&gt;.  There is a backport of &lt;code&gt;concurrent.futures&lt;/code&gt; is available for Python 2 too.&lt;/p&gt;\n\n&lt;p&gt;One thing that I&amp;#39;d really like to know is how these threads perform against Python threads (and maybe other alternatives, too).  If you&amp;#39;re firing off enough threads to be worried about using a pool, this would be pretty important information.  I also am hesitant to tie my background work so closely with what my frontend is doing.  If I want to make my tool have a CLI as well as a GUI (something that isn&amp;#39;t uncommon in my line of work) then it&amp;#39;s best to have those concerns separated as much as possible.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dgdtnzr", "score_hidden": false, "stickied": false, "created": 1492479856.0, "created_utc": 1492451056.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 2}}], "after": null, "before": null}}, "user_reports": [], "id": "dgdoc7n", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "mfitzp", "parent_id": "t1_dgdjscs", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "Well, sort of.\n\nUsing a thread pool gives you more control/stability when using multiple threads since you don't need to keep track or manage the number of threads you are running. That may seem overkill if you're only expecting to use threads for simple one off tasks, but there is something nice about being able \"fire and forget\".\n\nThat said, if you're using Python 3 and have access to concurrent.futures then you already get this too.\n\nIn that case, the only real benefit of going the Qt way is being able to keep your application control unified around Qt signals (which you'll be using anyway) and benefit from using them for cross-thread communication.\n\nI may have oversold the downsides to honest, for 90% of cases it's more than good enough. But, if you are comfortable with Python threads and aren't bother about using Qt signals then this is probably not for you.\n\nI plan to cover using concurrent.futures (and async use-cases) with PyQt next.  ", "edited": 1492445774.0, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Well, sort of.&lt;/p&gt;\n\n&lt;p&gt;Using a thread pool gives you more control/stability when using multiple threads since you don&amp;#39;t need to keep track or manage the number of threads you are running. That may seem overkill if you&amp;#39;re only expecting to use threads for simple one off tasks, but there is something nice about being able &amp;quot;fire and forget&amp;quot;.&lt;/p&gt;\n\n&lt;p&gt;That said, if you&amp;#39;re using Python 3 and have access to concurrent.futures then you already get this too.&lt;/p&gt;\n\n&lt;p&gt;In that case, the only real benefit of going the Qt way is being able to keep your application control unified around Qt signals (which you&amp;#39;ll be using anyway) and benefit from using them for cross-thread communication.&lt;/p&gt;\n\n&lt;p&gt;I may have oversold the downsides to honest, for 90% of cases it&amp;#39;s more than good enough. But, if you are comfortable with Python threads and aren&amp;#39;t bother about using Qt signals then this is probably not for you.&lt;/p&gt;\n\n&lt;p&gt;I plan to cover using concurrent.futures (and async use-cases) with PyQt next.  &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dgdoc7n", "score_hidden": false, "stickied": false, "created": 1492473931.0, "created_utc": 1492445131.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dgdjscs", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "bheklilr", "parent_id": "t3_65uais", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "&gt; This isn\u2019t a problem when we\u2019re simply tracking progress, completion or returning metadata. However, if you have workers which return large amounts of data \u2014 e.g. loading large files, performing complex analysis and need (large) results, or querying databases \u2014 passing this data back through the GUI thread may cause performance problems and is best avoided.\n&gt;\n&gt; Similarly, if your application makes use of a large number of threads and Python result handlers, you may come up against the limitations of the GIL. As mentioned previously, when using threads execution of Python is limited to a single thread at one time. The Python code that handles signals from your threads can be blocked by your workers and vice versa. Since blocking your slot functions blocks the event loop, this can directly impact GUI responsiveness.\n&gt;\n&gt; In these cases it is often better to investigate using a pure-Python thread pool (e.g. concurrent futures) implementation to keep your processing and thread-event handling further isolated from your GUI.\n\nSo if there are problems with using `QRunnable`, why wouldn't I just use `threading` and co?  It's a handy interface, but it doesn't seem any more powerful than just using `threading.Thread` (which already lets you do `threading.Thread(target=myfunc, args=args, kwargs=kwargs)`).", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;blockquote&gt;\n&lt;p&gt;This isn\u2019t a problem when we\u2019re simply tracking progress, completion or returning metadata. However, if you have workers which return large amounts of data \u2014 e.g. loading large files, performing complex analysis and need (large) results, or querying databases \u2014 passing this data back through the GUI thread may cause performance problems and is best avoided.&lt;/p&gt;\n\n&lt;p&gt;Similarly, if your application makes use of a large number of threads and Python result handlers, you may come up against the limitations of the GIL. As mentioned previously, when using threads execution of Python is limited to a single thread at one time. The Python code that handles signals from your threads can be blocked by your workers and vice versa. Since blocking your slot functions blocks the event loop, this can directly impact GUI responsiveness.&lt;/p&gt;\n\n&lt;p&gt;In these cases it is often better to investigate using a pure-Python thread pool (e.g. concurrent futures) implementation to keep your processing and thread-event handling further isolated from your GUI.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;So if there are problems with using &lt;code&gt;QRunnable&lt;/code&gt;, why wouldn&amp;#39;t I just use &lt;code&gt;threading&lt;/code&gt; and co?  It&amp;#39;s a handy interface, but it doesn&amp;#39;t seem any more powerful than just using &lt;code&gt;threading.Thread&lt;/code&gt; (which already lets you do &lt;code&gt;threading.Thread(target=myfunc, args=args, kwargs=kwargs)&lt;/code&gt;).&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dgdjscs", "score_hidden": false, "stickied": false, "created": 1492468455.0, "created_utc": 1492439655.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 2}}], "after": null, "before": null}}]