[{"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t3", "data": {"contest_mode": false, "banned_by": null, "media_embed": {}, "subreddit": "Python", "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;So I recently finished building out a Risk simulation game in python and pygame. For the next step, I want to build out an AI for players to play against, since right now it only supports PvP. &lt;/p&gt;\n\n&lt;p&gt;I was thinking I&amp;#39;d have a bunch of directives for it, like try to take a continent, try to break up an enemy continent, try to knock out a weak player, or just conquer one territory to get a Risk card. I figure I&amp;#39;d have to find some way to calculate a score for each option, weight them based on their importance, and pick the best one. Like if an opponent holds North America but has a bunch of units on the borders vs Australia is practically wide open, it would take move to take Australia. &lt;/p&gt;\n\n&lt;p&gt;I&amp;#39;m also interested in ML stuff, though I haven&amp;#39;t really delved into it much, and was wondering if that would be a good way to go about doing this.&lt;/p&gt;\n\n&lt;p&gt;Any ideas, tips, pointers, or resources are greatly appreciated! &lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "selftext": "So I recently finished building out a Risk simulation game in python and pygame. For the next step, I want to build out an AI for players to play against, since right now it only supports PvP. \n\nI was thinking I'd have a bunch of directives for it, like try to take a continent, try to break up an enemy continent, try to knock out a weak player, or just conquer one territory to get a Risk card. I figure I'd have to find some way to calculate a score for each option, weight them based on their importance, and pick the best one. Like if an opponent holds North America but has a bunch of units on the borders vs Australia is practically wide open, it would take move to take Australia. \n\nI'm also interested in ML stuff, though I haven't really delved into it much, and was wondering if that would be a good way to go about doing this.\n\nAny ideas, tips, pointers, or resources are greatly appreciated! ", "likes": null, "suggested_sort": null, "user_reports": [], "secure_media": null, "link_flair_text": null, "id": "650hu8", "gilded": 0, "secure_media_embed": {}, "clicked": false, "score": 7, "report_reasons": null, "author": "thewallris", "saved": false, "mod_reports": [], "name": "t3_650hu8", "subreddit_name_prefixed": "r/Python", "approved_by": null, "over_18": false, "domain": "self.Python", "hidden": false, "thumbnail": "", "subreddit_id": "t5_2qh0y", "edited": false, "link_flair_css_class": null, "author_flair_css_class": null, "downs": 0, "brand_safe": true, "archived": false, "removal_reason": null, "is_self": true, "hide_score": false, "spoiler": false, "permalink": "/r/Python/comments/650hu8/building_a_risk_ai/", "num_reports": null, "locked": false, "stickied": false, "created": 1492055107.0, "url": "https://www.reddit.com/r/Python/comments/650hu8/building_a_risk_ai/", "author_flair_text": null, "quarantine": false, "title": "Building a Risk AI", "created_utc": 1492026307.0, "distinguished": null, "media": null, "upvote_ratio": 0.78, "num_comments": 16, "visited": false, "subreddit_type": "public", "ups": 7}}], "after": null, "before": null}}, {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_650hu8", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_650hu8", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_650hu8", "likes": null, "replies": "", "user_reports": [], "id": "dg6mnma", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "reostra", "parent_id": "t1_dg6m0or", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "Thanks!  I learned it a while back when I made a 'pirates vs zombies' game for a code jam and found it more entertaining to watch the game play itself :)", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Thanks!  I learned it a while back when I made a &amp;#39;pirates vs zombies&amp;#39; game for a code jam and found it more entertaining to watch the game play itself :)&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg6mnma", "score_hidden": false, "stickied": false, "created": 1492062803.0, "created_utc": 1492034003.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 3}}], "after": null, "before": null}}, "user_reports": [], "id": "dg6m0or", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "cocorebop", "parent_id": "t1_dg6hs57", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "I'm not OP but this is very cool and well thought out advice, thanks for the post.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;m not OP but this is very cool and well thought out advice, thanks for the post.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg6m0or", "score_hidden": false, "stickied": false, "created": 1492062036.0, "created_utc": 1492033236.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 3}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_650hu8", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_650hu8", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_650hu8", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_650hu8", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_650hu8", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_650hu8", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_650hu8", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_650hu8", "likes": null, "replies": "", "user_reports": [], "id": "dg7jdo0", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "reostra", "parent_id": "t1_dg75nn7", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "To add on to what SethGecko said, Monte Carlo isn't Machine Learning.  Sorry if I accidentally conflated ML and Artificial Intelligence in general, I was mostly describing the technique as a stepping stone to more involved machine learning, and because once you've made a random AI in the first place it's not too hard to use it :)\n\nMachine Learning, as the name implies, involves actual learning.  A relatively easy to understand technique is 'markov models', which I go over in more detail in [this comment about how SubredditSimulator works](https://www.reddit.com/r/Python/comments/2ife6d/pykov_a_tiny_python_module_on_finite_regular/cl3bybj/).  While the example I show there uses words, there's no reason you couldn't use game states and feed your AI a bunch of winning games.  The markov model falls into the 'learning' category because it learns from the training data, but it can also be updated on the fly fairly easily.\n\nOther ML applications are things like Neural Nets and (arguably) Genetic Algorithms.  NN has seen a pretty big resurgence lately, so you're likely to find a lot of interesting things there.  My experience in that particular area isn't up to date so I can't help much :)", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;To add on to what SethGecko said, Monte Carlo isn&amp;#39;t Machine Learning.  Sorry if I accidentally conflated ML and Artificial Intelligence in general, I was mostly describing the technique as a stepping stone to more involved machine learning, and because once you&amp;#39;ve made a random AI in the first place it&amp;#39;s not too hard to use it :)&lt;/p&gt;\n\n&lt;p&gt;Machine Learning, as the name implies, involves actual learning.  A relatively easy to understand technique is &amp;#39;markov models&amp;#39;, which I go over in more detail in &lt;a href=\"https://www.reddit.com/r/Python/comments/2ife6d/pykov_a_tiny_python_module_on_finite_regular/cl3bybj/\"&gt;this comment about how SubredditSimulator works&lt;/a&gt;.  While the example I show there uses words, there&amp;#39;s no reason you couldn&amp;#39;t use game states and feed your AI a bunch of winning games.  The markov model falls into the &amp;#39;learning&amp;#39; category because it learns from the training data, but it can also be updated on the fly fairly easily.&lt;/p&gt;\n\n&lt;p&gt;Other ML applications are things like Neural Nets and (arguably) Genetic Algorithms.  NN has seen a pretty big resurgence lately, so you&amp;#39;re likely to find a lot of interesting things there.  My experience in that particular area isn&amp;#39;t up to date so I can&amp;#39;t help much :)&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg7jdo0", "score_hidden": false, "stickied": false, "created": 1492118953.0, "created_utc": 1492090153.0, "depth": 8, "mod_reports": [], "subreddit_type": "public", "ups": 2}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_650hu8", "likes": null, "replies": "", "user_reports": [], "id": "dg7f9oo", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "SethGecko11", "parent_id": "t1_dg75nn7", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "No, that's just one technique called Monte Carlo Simulation. You typically use it when you cannot come up with an analytical solution.\n\nFor example you want to calculate the price of a complicated financial derivative based on a stock and you cannot solve the price equation. What you can do is simulate the path of the stock thousands of times, calculate the derivative price each time and take the average.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;No, that&amp;#39;s just one technique called Monte Carlo Simulation. You typically use it when you cannot come up with an analytical solution.&lt;/p&gt;\n\n&lt;p&gt;For example you want to calculate the price of a complicated financial derivative based on a stock and you cannot solve the price equation. What you can do is simulate the path of the stock thousands of times, calculate the derivative price each time and take the average.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg7f9oo", "score_hidden": false, "stickied": false, "created": 1492111952.0, "created_utc": 1492083152.0, "depth": 8, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg75nn7", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "thewallris", "parent_id": "t1_dg6zflh", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "You hear \"machine learning\" get thrown around as a buzz word all the time, but is that all it really is? Just running a ton of simulations, tweaking things, and eventually knowing what to do in every situation? ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;You hear &amp;quot;machine learning&amp;quot; get thrown around as a buzz word all the time, but is that all it really is? Just running a ton of simulations, tweaking things, and eventually knowing what to do in every situation? &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg75nn7", "score_hidden": false, "stickied": false, "created": 1492087345.0, "created_utc": 1492058545.0, "depth": 7, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg6zflh", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "reostra", "parent_id": "t1_dg6n93k", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "&gt; pick out trends over time (like taking Australia early on)\n\nExactly - it almost comes back to one of the earlier bullet points I'd mentioned:  Balance testing.  You can make sure two teams with differing abilities are balanced by having them play random games against each other and seeing if the win/loss is 50/50.  Well, this is like that, only we're essentially looking at ways to *un*balance things.  If we start in Australia, does that unbalance the game in our favor?\n\n&gt; the AI would win making some random but stupid move at a certain point and think that said move was the best move it could have made in the situation.\n\nAnd this is the reason why you play many, *many* random games.  I wasn't joking when I said 'thousands', and in many cases you want more.  It's so that the flukes like you describe get buried under the rest of the data.\n\nIt also makes tuning AI difficulty a snap:  Just give the computer fewer random games to sample from, and it's not as good.  Give it more, and it gets better :)", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;blockquote&gt;\n&lt;p&gt;pick out trends over time (like taking Australia early on)&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Exactly - it almost comes back to one of the earlier bullet points I&amp;#39;d mentioned:  Balance testing.  You can make sure two teams with differing abilities are balanced by having them play random games against each other and seeing if the win/loss is 50/50.  Well, this is like that, only we&amp;#39;re essentially looking at ways to &lt;em&gt;un&lt;/em&gt;balance things.  If we start in Australia, does that unbalance the game in our favor?&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;the AI would win making some random but stupid move at a certain point and think that said move was the best move it could have made in the situation.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;And this is the reason why you play many, &lt;em&gt;many&lt;/em&gt; random games.  I wasn&amp;#39;t joking when I said &amp;#39;thousands&amp;#39;, and in many cases you want more.  It&amp;#39;s so that the flukes like you describe get buried under the rest of the data.&lt;/p&gt;\n\n&lt;p&gt;It also makes tuning AI difficulty a snap:  Just give the computer fewer random games to sample from, and it&amp;#39;s not as good.  Give it more, and it gets better :)&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg6zflh", "score_hidden": false, "stickied": false, "created": 1492078538.0, "created_utc": 1492049738.0, "depth": 6, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg6n93k", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "thewallris", "parent_id": "t1_dg6mitk", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "So is the idea to pick out trends over time (like taking Australia early on) or specific move sets to make given a game board the AI has seen before? If it's the latter, I'd be concerned that the AI would win making some random but stupid move at a certain point and think that said move was the best move it could have made in the situation. \n\nAlso how would I go about setting all of this up?", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;So is the idea to pick out trends over time (like taking Australia early on) or specific move sets to make given a game board the AI has seen before? If it&amp;#39;s the latter, I&amp;#39;d be concerned that the AI would win making some random but stupid move at a certain point and think that said move was the best move it could have made in the situation. &lt;/p&gt;\n\n&lt;p&gt;Also how would I go about setting all of this up?&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg6n93k", "score_hidden": false, "stickied": false, "created": 1492063526.0, "created_utc": 1492034726.0, "depth": 5, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg6mitk", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "reostra", "parent_id": "t1_dg6lqdb", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "&gt; it seems like this approach is like giving millions of monkeys typewriters and hoping that eventually they'll write a Shakespearean sonnet.\n\nYou're not that far off, really.  Imagine it like every time you want to write a word of the sonnet, you give what you have so far to the monkeys and let each one write the rest.  Whichever one got the closest to something a sonnet would look like, that's the word you pick next.  Repeat for the word after that.\n\nFortunately, games tend to have a smaller state space than full-fledged languages, or at least an easier way to determine what state is 'closest' to winning :)\n\nFor multiple phases like Risk, you essentially treat each phase as a separate 'turn'.  So, you look at all the places you could place your troops (it's been a while since I played, but I think you've already earned the troops by the time you get to this step, so there's no question as to the number you'll have), and then you split off the gamestate, attack and fortifying randomly, and assuming your opponent does the same.\n\nOnce you get an answer from that, you then look at attacking.  Again, you look at all possible attacks for that phase, then play randomly from that point (the randomness of the dice in this stage doesn't matter; it'll essentially be normalized by the fact that you're playing so *many* random games).  \n\nFinally, when you see which attacks are most likely to lead to a winning state, you do the same thing with fortifying.  See which fortifications lead to winning games, and pick those.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;blockquote&gt;\n&lt;p&gt;it seems like this approach is like giving millions of monkeys typewriters and hoping that eventually they&amp;#39;ll write a Shakespearean sonnet.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;You&amp;#39;re not that far off, really.  Imagine it like every time you want to write a word of the sonnet, you give what you have so far to the monkeys and let each one write the rest.  Whichever one got the closest to something a sonnet would look like, that&amp;#39;s the word you pick next.  Repeat for the word after that.&lt;/p&gt;\n\n&lt;p&gt;Fortunately, games tend to have a smaller state space than full-fledged languages, or at least an easier way to determine what state is &amp;#39;closest&amp;#39; to winning :)&lt;/p&gt;\n\n&lt;p&gt;For multiple phases like Risk, you essentially treat each phase as a separate &amp;#39;turn&amp;#39;.  So, you look at all the places you could place your troops (it&amp;#39;s been a while since I played, but I think you&amp;#39;ve already earned the troops by the time you get to this step, so there&amp;#39;s no question as to the number you&amp;#39;ll have), and then you split off the gamestate, attack and fortifying randomly, and assuming your opponent does the same.&lt;/p&gt;\n\n&lt;p&gt;Once you get an answer from that, you then look at attacking.  Again, you look at all possible attacks for that phase, then play randomly from that point (the randomness of the dice in this stage doesn&amp;#39;t matter; it&amp;#39;ll essentially be normalized by the fact that you&amp;#39;re playing so &lt;em&gt;many&lt;/em&gt; random games).  &lt;/p&gt;\n\n&lt;p&gt;Finally, when you see which attacks are most likely to lead to a winning state, you do the same thing with fortifying.  See which fortifications lead to winning games, and pick those.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg6mitk", "score_hidden": false, "stickied": false, "created": 1492062640.0, "created_utc": 1492033840.0, "depth": 4, "mod_reports": [], "subreddit_type": "public", "ups": 2}}], "after": null, "before": null}}, "user_reports": [], "id": "dg6lqdb", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "thewallris", "parent_id": "t1_dg6ke72", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "I think I get it for your simple game, but I think I'm struggling to see how it can apply to Risk, where one move has multiple steps (placing troops, attacking, fortifying), where the initial move affects the next one (can't attack if the units aren't there), and where the attacking itself is randomized with dice. \n\nThere isn't necessarily one \"right\" move to make, but there are definitely better/worse moves one could make at any given game state. Maybe I'm still not fully understanding the concept, but it seems like this approach is like giving millions of monkeys typewriters and hoping that eventually they'll write a Shakespearean sonnet. ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I think I get it for your simple game, but I think I&amp;#39;m struggling to see how it can apply to Risk, where one move has multiple steps (placing troops, attacking, fortifying), where the initial move affects the next one (can&amp;#39;t attack if the units aren&amp;#39;t there), and where the attacking itself is randomized with dice. &lt;/p&gt;\n\n&lt;p&gt;There isn&amp;#39;t necessarily one &amp;quot;right&amp;quot; move to make, but there are definitely better/worse moves one could make at any given game state. Maybe I&amp;#39;m still not fully understanding the concept, but it seems like this approach is like giving millions of monkeys typewriters and hoping that eventually they&amp;#39;ll write a Shakespearean sonnet. &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg6lqdb", "score_hidden": false, "stickied": false, "created": 1492061692.0, "created_utc": 1492032892.0, "depth": 3, "mod_reports": [], "subreddit_type": "public", "ups": 2}}], "after": null, "before": null}}, "user_reports": [], "id": "dg6ke72", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "reostra", "parent_id": "t1_dg6jhs1", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "&gt; Would I be checking every possible move for each randomized set up?\n\nYou'd check every possible move for the *current* game state.  So the only time the startup matters is for the very first turn.\n\n&gt; And then the second move from each of the spawned situations?\n\nImportantly, no.  This is where Monte Carlo differs from something like a simple depth-first search.  In a DFS, you'd then expand all of the spawned situations and go further down the tree.  For Monte Carlo, you just continue to randomly play the game until you hit a winning game state.\n\nAs an example, I'll demonstrate a \"Guess a number between 1 and 10\" game.  It's not really a game that lends itself to something like a DFS, but it should get the idea across.\n\nIn a full-blown DFS or Minimax, your AI thinks as follows:\n\n* Assume I choose 1.\n\n    * Assume my opponent chooses 2\n\n        * Asssume I choose 3...\n\n        * Assume I choose 4...\n\n        * ...\n\n    * Assume my opponent chooses 3...\n\n    * ...\n\n* Assume I choose 2...\n\n* ...\n\nIn short, expanding the entire game tree.  Whereas, the Monte carlo approach is:\n\n* Assume I pick 1\n\n    * Assume my opponent picks some random number, I don't care\n\n    * Assume I then pick some other random number\n\n    * Assume my opponent then picks a different random number\n\n    * Repeat until someone wins.\n\n    * Repeat a number of times so we can record a win/loss record.\n\n* Assume I pick 2\n\n    * (Do the same thing I just did above)\n\n* ...\n\nMonte Carlo doesn't expand the search tree so much as randomly pick branches along the tree as it goes, and then hopes that they're representative of the game as a whole :)", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;blockquote&gt;\n&lt;p&gt;Would I be checking every possible move for each randomized set up?&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;You&amp;#39;d check every possible move for the &lt;em&gt;current&lt;/em&gt; game state.  So the only time the startup matters is for the very first turn.&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;And then the second move from each of the spawned situations?&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Importantly, no.  This is where Monte Carlo differs from something like a simple depth-first search.  In a DFS, you&amp;#39;d then expand all of the spawned situations and go further down the tree.  For Monte Carlo, you just continue to randomly play the game until you hit a winning game state.&lt;/p&gt;\n\n&lt;p&gt;As an example, I&amp;#39;ll demonstrate a &amp;quot;Guess a number between 1 and 10&amp;quot; game.  It&amp;#39;s not really a game that lends itself to something like a DFS, but it should get the idea across.&lt;/p&gt;\n\n&lt;p&gt;In a full-blown DFS or Minimax, your AI thinks as follows:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;Assume I choose 1.&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;Assume my opponent chooses 2&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Asssume I choose 3...&lt;/li&gt;\n&lt;li&gt;Assume I choose 4...&lt;/li&gt;\n&lt;li&gt;...&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Assume my opponent chooses 3...&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;...&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Assume I choose 2...&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;...&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;In short, expanding the entire game tree.  Whereas, the Monte carlo approach is:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;Assume I pick 1&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Assume my opponent picks some random number, I don&amp;#39;t care&lt;/li&gt;\n&lt;li&gt;Assume I then pick some other random number&lt;/li&gt;\n&lt;li&gt;Assume my opponent then picks a different random number&lt;/li&gt;\n&lt;li&gt;Repeat until someone wins.&lt;/li&gt;\n&lt;li&gt;Repeat a number of times so we can record a win/loss record.&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Assume I pick 2&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;(Do the same thing I just did above)&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;...&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Monte Carlo doesn&amp;#39;t expand the search tree so much as randomly pick branches along the tree as it goes, and then hopes that they&amp;#39;re representative of the game as a whole :)&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg6ke72", "score_hidden": false, "stickied": false, "created": 1492060137.0, "created_utc": 1492031337.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 3}}], "after": null, "before": null}}, "user_reports": [], "id": "dg6jhs1", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "thewallris", "parent_id": "t1_dg6hs57", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "I totally get separating the model and view, that makes a lot of sense. However, I'm not sure I understand the bit about the Monte Carlo technique. I have the game set up so the territory/troop placement is randomized. Would I be checking every possible move for each randomized set up? And then the second move from each of the spawned situations? I feel like it gets out of hand very quickly, but maybe that's the point?", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I totally get separating the model and view, that makes a lot of sense. However, I&amp;#39;m not sure I understand the bit about the Monte Carlo technique. I have the game set up so the territory/troop placement is randomized. Would I be checking every possible move for each randomized set up? And then the second move from each of the spawned situations? I feel like it gets out of hand very quickly, but maybe that&amp;#39;s the point?&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg6jhs1", "score_hidden": false, "stickied": false, "created": 1492059128.0, "created_utc": 1492030328.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 1}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_650hu8", "likes": null, "replies": "", "user_reports": [], "id": "dg75t7z", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "azobe", "parent_id": "t1_dg6hs57", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "Thank you so much!\nI'm planning on doing a sort of game ai after I finished some pygame tutorials.\n\nYour thoughts were clearly lay out and very helpfull.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Thank you so much!\nI&amp;#39;m planning on doing a sort of game ai after I finished some pygame tutorials.&lt;/p&gt;\n\n&lt;p&gt;Your thoughts were clearly lay out and very helpfull.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg75t7z", "score_hidden": false, "stickied": false, "created": 1492087606.0, "created_utc": 1492058806.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg6hs57", "gilded": 0, "archived": false, "score": 26, "report_reasons": null, "author": "reostra", "parent_id": "t3_650hu8", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "So, my suggestion is:  Make an AI that acts randomly.\n\nThis serves a number of purposes:\n\n* It makes you separate the 'model' (the game itself) from the 'view' (the pygame stuff that shows it):  If you're anything like I was when I did pygame, that stuff is completely tied together.  You'll want an implementation where you could play the entire game, AI vs. AI, without a display at all.  I'll get back to why you'd want to do that in a bit.\n\n* It gives you a baseline:  If your ML algorithm or the heuristics you create later can't outperform it, then you know to move on to others.\n \n* It gives you a smoketest:  If your AI can play itself, you can have it play a number of random games.  They'll make moves your players (or, if it's just you testing this, you) are unlikely to make.  In short, they'll hit code paths that are unlikely to have been tested before.\n\n    * Here's where decoupling the display of the game from the game itself starts to pay off:  A random game of AI vs AI will go a *lot* faster if it doesn't have to draw every move to the screen.  So you can run that many more tests.\n\n* This doesn't apply to you because you're using a pre-existing game, but if you're creating a game of your own:  This lets you test its balance.  Run a few hundred thousand AI vs AI games, and record who wins.  If one player wins more than the other by a significant amount, there's an imbalance somewhere, and you can tweak the numbers.  As above, this is a lot faster without a display.\n\nAnd finally, this segues nicely into the ML stuff you mentioned, because you can then implement a somewhat *competent* AI using the \"monte carlo\" technique:\n\n1. When it's your AI's turn, make a list of every possible move they can make in that turn.\n\n2. For each of those moves:\n\n    1. Create a 'game' with a gamestate identical to the one that would result if your AI made that move.\n\n    1. Play a thousand or so random games, starting at that gamestate.\n\n    1. Record the win/loss record for that move.\n\n3. Whichever move had the best win/loss record, that's the one your AI chooses!\n\nHope this helps!", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;So, my suggestion is:  Make an AI that acts randomly.&lt;/p&gt;\n\n&lt;p&gt;This serves a number of purposes:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;It makes you separate the &amp;#39;model&amp;#39; (the game itself) from the &amp;#39;view&amp;#39; (the pygame stuff that shows it):  If you&amp;#39;re anything like I was when I did pygame, that stuff is completely tied together.  You&amp;#39;ll want an implementation where you could play the entire game, AI vs. AI, without a display at all.  I&amp;#39;ll get back to why you&amp;#39;d want to do that in a bit.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;It gives you a baseline:  If your ML algorithm or the heuristics you create later can&amp;#39;t outperform it, then you know to move on to others.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;It gives you a smoketest:  If your AI can play itself, you can have it play a number of random games.  They&amp;#39;ll make moves your players (or, if it&amp;#39;s just you testing this, you) are unlikely to make.  In short, they&amp;#39;ll hit code paths that are unlikely to have been tested before.&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Here&amp;#39;s where decoupling the display of the game from the game itself starts to pay off:  A random game of AI vs AI will go a &lt;em&gt;lot&lt;/em&gt; faster if it doesn&amp;#39;t have to draw every move to the screen.  So you can run that many more tests.&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;This doesn&amp;#39;t apply to you because you&amp;#39;re using a pre-existing game, but if you&amp;#39;re creating a game of your own:  This lets you test its balance.  Run a few hundred thousand AI vs AI games, and record who wins.  If one player wins more than the other by a significant amount, there&amp;#39;s an imbalance somewhere, and you can tweak the numbers.  As above, this is a lot faster without a display.&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;And finally, this segues nicely into the ML stuff you mentioned, because you can then implement a somewhat &lt;em&gt;competent&lt;/em&gt; AI using the &amp;quot;monte carlo&amp;quot; technique:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;When it&amp;#39;s your AI&amp;#39;s turn, make a list of every possible move they can make in that turn.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;For each of those moves:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Create a &amp;#39;game&amp;#39; with a gamestate identical to the one that would result if your AI made that move.&lt;/li&gt;\n&lt;li&gt;Play a thousand or so random games, starting at that gamestate.&lt;/li&gt;\n&lt;li&gt;Record the win/loss record for that move.&lt;/li&gt;\n&lt;/ol&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Whichever move had the best win/loss record, that&amp;#39;s the one your AI chooses!&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;Hope this helps!&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg6hs57", "score_hidden": false, "stickied": false, "created": 1492057338.0, "created_utc": 1492028538.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 26}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_650hu8", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_650hu8", "likes": null, "replies": "", "user_reports": [], "id": "dg78l9c", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "thewallris", "parent_id": "t1_dg783hz", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "Interesting, I'll check it out", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Interesting, I&amp;#39;ll check it out&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg78l9c", "score_hidden": false, "stickied": false, "created": 1492093179.0, "created_utc": 1492064379.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg783hz", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "pvkooten", "parent_id": "t3_650hu8", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "You should have a look at warlight AI competitions... Very related. ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;You should have a look at warlight AI competitions... Very related. &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg783hz", "score_hidden": false, "stickied": false, "created": 1492092038.0, "created_utc": 1492063238.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 1}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_650hu8", "likes": null, "replies": "", "user_reports": [], "id": "dgak13w", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "randy_heydon", "parent_id": "t3_650hu8", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "You might find [EasyAI](https://github.com/Zulko/easyAI) to be a helpful package.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;You might find &lt;a href=\"https://github.com/Zulko/easyAI\"&gt;EasyAI&lt;/a&gt; to be a helpful package.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dgak13w", "score_hidden": false, "stickied": false, "created": 1492284813.0, "created_utc": 1492256013.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}]