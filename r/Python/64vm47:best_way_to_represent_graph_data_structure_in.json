[{"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t3", "data": {"contest_mode": false, "banned_by": null, "media_embed": {}, "subreddit": "Python", "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Graph can belong to one of the following categories -&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Directed weighted&lt;/li&gt;\n&lt;li&gt;Directed unweighted&lt;/li&gt;\n&lt;li&gt;Undirected weighted&lt;/li&gt;\n&lt;li&gt;Undirected unweighted&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;How do you represent &lt;em&gt;your&lt;/em&gt; graph? I know we have tonnes of good graph libraries in Python; such as Networkx, py-graph, etc. However, one cannot use it in &lt;em&gt;competitive programming&lt;/em&gt;. What is the way you implement it while appearing for interviews?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "selftext": "Graph can belong to one of the following categories -\n\n* Directed weighted\n* Directed unweighted\n* Undirected weighted\n* Undirected unweighted\n\nHow do you represent *your* graph? I know we have tonnes of good graph libraries in Python; such as Networkx, py-graph, etc. However, one cannot use it in *competitive programming*. What is the way you implement it while appearing for interviews?", "likes": null, "suggested_sort": null, "user_reports": [], "secure_media": null, "link_flair_text": null, "id": "64vm47", "gilded": 0, "secure_media_embed": {}, "clicked": false, "score": 6, "report_reasons": null, "author": "malhaar3148", "saved": false, "mod_reports": [], "name": "t3_64vm47", "subreddit_name_prefixed": "r/Python", "approved_by": null, "over_18": false, "domain": "self.Python", "hidden": false, "thumbnail": "", "subreddit_id": "t5_2qh0y", "edited": 1491965819.0, "link_flair_css_class": null, "author_flair_css_class": null, "downs": 0, "brand_safe": true, "archived": false, "removal_reason": null, "is_self": true, "hide_score": false, "spoiler": false, "permalink": "/r/Python/comments/64vm47/best_way_to_represent_graph_data_structure_in/", "num_reports": null, "locked": false, "stickied": false, "created": 1491994389.0, "url": "https://www.reddit.com/r/Python/comments/64vm47/best_way_to_represent_graph_data_structure_in/", "author_flair_text": null, "quarantine": false, "title": "Best way to represent Graph data structure in Python", "created_utc": 1491965589.0, "distinguished": null, "media": null, "upvote_ratio": 0.75, "num_comments": 16, "visited": false, "subreddit_type": "public", "ups": 6}}], "after": null, "before": null}}, {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_64vm47", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_64vm47", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_64vm47", "likes": null, "replies": "", "user_reports": [], "id": "dg6dyfo", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "rcfox", "parent_id": "t1_dg6bmc5", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "I think OOP would be easier to document and generalize, but if you have to build everything from scratch for a one-off project, that seems a bit overkill.\n\nIn an interview, you'd probably just want to use the classes directly without providing an implementation, since that's a waste of time when you want to describe a graph algorithm.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I think OOP would be easier to document and generalize, but if you have to build everything from scratch for a one-off project, that seems a bit overkill.&lt;/p&gt;\n\n&lt;p&gt;In an interview, you&amp;#39;d probably just want to use the classes directly without providing an implementation, since that&amp;#39;s a waste of time when you want to describe a graph algorithm.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg6dyfo", "score_hidden": false, "stickied": false, "created": 1492053414.0, "created_utc": 1492024614.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg6bmc5", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "malhaar3148", "parent_id": "t1_dg5koiy", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "Thanks for your input! \nTo take the discussion ahead - let's say we are using adj. list.\n1. Should we use OOP way ('class Vertex', 'class Graph' etc)? Is it better than using just dictionaries(without classes)? Particularly when you are appearing for the interview.\n2. If it is so, how do you use it ? ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Thanks for your input! \nTo take the discussion ahead - let&amp;#39;s say we are using adj. list.\n1. Should we use OOP way (&amp;#39;class Vertex&amp;#39;, &amp;#39;class Graph&amp;#39; etc)? Is it better than using just dictionaries(without classes)? Particularly when you are appearing for the interview.\n2. If it is so, how do you use it ? &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg6bmc5", "score_hidden": false, "stickied": false, "created": 1492051001.0, "created_utc": 1492022201.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg5koiy", "gilded": 0, "archived": false, "score": 4, "report_reasons": null, "author": "rcfox", "parent_id": "t3_64vm47", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "All of those cases can be most-generally represented by a weighted, directed graph.\n\nFor the unweighted case, all weights would be 1. For the undirected case, you maintain a directed edge in both directions. (`x -&gt; y` and `y -&gt; x`)\n\nFor most applications, you'll want to use adjacency lists to track edges. Each node would have a list of `(weight, other_node)`.\n\nHowever, if you're dealing with a mostly-connected graph (ie: each node is connected to most of the rest of the nodes), you can reduce the complexity of some algorithms by using an adjacency matrix. In that case, you'd have a 2D array, num_nodes * num_nodes in size: \n\n\n | A | B | C | D | E\n---|---|---|----|----|----\nA | 0 | 1 | 0 | 0| 1\nB | 1 | 1 | 1 | 1 | 1\nC | 0 | 0 | 0| 1 | 1\nD | 1 | 1 |1 | 0 | 1\nE | 1 | 1 | 1| 0 | 0\n\nThis shows `A -&gt; B, A -&gt; E, B -&gt; A, B -&gt; B, B -&gt; C, B -&gt; D, B -&gt; E`, etc.\n\nIt uses a lot more memory, but if most nodes are connected to each other, you're probably on the same order of magnitude with adjacency lists.\nAn adjacency matrix is useful for quickly checking if an edge exists, or adding/removing edges. It's pretty terrible if you're dynamically adding new nodes.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;All of those cases can be most-generally represented by a weighted, directed graph.&lt;/p&gt;\n\n&lt;p&gt;For the unweighted case, all weights would be 1. For the undirected case, you maintain a directed edge in both directions. (&lt;code&gt;x -&amp;gt; y&lt;/code&gt; and &lt;code&gt;y -&amp;gt; x&lt;/code&gt;)&lt;/p&gt;\n\n&lt;p&gt;For most applications, you&amp;#39;ll want to use adjacency lists to track edges. Each node would have a list of &lt;code&gt;(weight, other_node)&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;However, if you&amp;#39;re dealing with a mostly-connected graph (ie: each node is connected to most of the rest of the nodes), you can reduce the complexity of some algorithms by using an adjacency matrix. In that case, you&amp;#39;d have a 2D array, num_nodes * num_nodes in size: &lt;/p&gt;\n\n&lt;table&gt;&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;&lt;/th&gt;\n&lt;th&gt;A&lt;/th&gt;\n&lt;th&gt;B&lt;/th&gt;\n&lt;th&gt;C&lt;/th&gt;\n&lt;th&gt;D&lt;/th&gt;\n&lt;th&gt;E&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;A&lt;/td&gt;\n&lt;td&gt;0&lt;/td&gt;\n&lt;td&gt;1&lt;/td&gt;\n&lt;td&gt;0&lt;/td&gt;\n&lt;td&gt;0&lt;/td&gt;\n&lt;td&gt;1&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;B&lt;/td&gt;\n&lt;td&gt;1&lt;/td&gt;\n&lt;td&gt;1&lt;/td&gt;\n&lt;td&gt;1&lt;/td&gt;\n&lt;td&gt;1&lt;/td&gt;\n&lt;td&gt;1&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;C&lt;/td&gt;\n&lt;td&gt;0&lt;/td&gt;\n&lt;td&gt;0&lt;/td&gt;\n&lt;td&gt;0&lt;/td&gt;\n&lt;td&gt;1&lt;/td&gt;\n&lt;td&gt;1&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;D&lt;/td&gt;\n&lt;td&gt;1&lt;/td&gt;\n&lt;td&gt;1&lt;/td&gt;\n&lt;td&gt;1&lt;/td&gt;\n&lt;td&gt;0&lt;/td&gt;\n&lt;td&gt;1&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;E&lt;/td&gt;\n&lt;td&gt;1&lt;/td&gt;\n&lt;td&gt;1&lt;/td&gt;\n&lt;td&gt;1&lt;/td&gt;\n&lt;td&gt;0&lt;/td&gt;\n&lt;td&gt;0&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n\n&lt;p&gt;This shows &lt;code&gt;A -&amp;gt; B, A -&amp;gt; E, B -&amp;gt; A, B -&amp;gt; B, B -&amp;gt; C, B -&amp;gt; D, B -&amp;gt; E&lt;/code&gt;, etc.&lt;/p&gt;\n\n&lt;p&gt;It uses a lot more memory, but if most nodes are connected to each other, you&amp;#39;re probably on the same order of magnitude with adjacency lists.\nAn adjacency matrix is useful for quickly checking if an edge exists, or adding/removing edges. It&amp;#39;s pretty terrible if you&amp;#39;re dynamically adding new nodes.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg5koiy", "score_hidden": false, "stickied": false, "created": 1492007898.0, "created_utc": 1491979098.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 4}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_64vm47", "likes": null, "replies": "", "user_reports": [], "id": "dg5j1km", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "moazim1993", "parent_id": "t3_64vm47", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "Just commenting to find this post later, curious as well.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Just commenting to find this post later, curious as well.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg5j1km", "score_hidden": false, "stickied": false, "created": 1492004142.0, "created_utc": 1491975342.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 3}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_64vm47", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_64vm47", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_64vm47", "likes": null, "replies": "", "user_reports": [], "id": "dg6dosb", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "rcfox", "parent_id": "t1_dg6b4dd", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "&gt;  # visited = True/False\n\n&gt;   # neighbours = {Vertex : Edge weight}\n\nI don't know about these.\n\nIn my opinion, it's better to let the algorithm track which vertices have been visited. That way at the end, you can throw away the visited set and be able to run it again. Otherwise, you have to revisit the entire graph to reset the visited flag.\n\nAnd in some cases, you want to be able to have multiple edges between vertices. Using a dictionary prevents that (and requires either hashable vertex objects, or giving each vertex a unique ID.)", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;blockquote&gt;\n&lt;p&gt;# visited = True/False&lt;/p&gt;\n\n&lt;p&gt;# neighbours = {Vertex : Edge weight}&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;I don&amp;#39;t know about these.&lt;/p&gt;\n\n&lt;p&gt;In my opinion, it&amp;#39;s better to let the algorithm track which vertices have been visited. That way at the end, you can throw away the visited set and be able to run it again. Otherwise, you have to revisit the entire graph to reset the visited flag.&lt;/p&gt;\n\n&lt;p&gt;And in some cases, you want to be able to have multiple edges between vertices. Using a dictionary prevents that (and requires either hashable vertex objects, or giving each vertex a unique ID.)&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg6dosb", "score_hidden": false, "stickied": false, "created": 1492053141.0, "created_utc": 1492024341.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 3}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_64vm47", "likes": null, "replies": "", "user_reports": [], "id": "dg6cle0", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "Wolfspaw", "parent_id": "t1_dg6b4dd", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "I think it's better indeed, more robust and less error-prone!\n\nThe Dictionary as a vertex is more fragile/hacky. But in competitive programming, it might be faster.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I think it&amp;#39;s better indeed, more robust and less error-prone!&lt;/p&gt;\n\n&lt;p&gt;The Dictionary as a vertex is more fragile/hacky. But in competitive programming, it might be faster.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg6cle0", "score_hidden": false, "stickied": false, "created": 1492052003.0, "created_utc": 1492023203.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg6b4dd", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "malhaar3148", "parent_id": "t1_dg5me9j", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "Yes. I get it. But, sometimes it looks very fragile. What if you are adding something random as node? IMO, checking if you are actually adding a node is important as well. So making classes for Vertex, and Graph makes a lot of sense, IMO. I usually do it this way -\n\n    class Vertex(object):\n    \t# Contains variables as follows - \n    \t# visited = True/False\n    \t# neighbours = {Vertex : Edge weight}\n    \t# example -\n    \t# self.neighbours = {a : 2, b : -2}\n         # if undirected and unweighted, just do it accordingly.\n\n    class Graph(object):\n    \t# self.vertex = set()\n    \t# no data structure for edges as I am already covering it in class Vertex.\n\nWhat do you think about it?", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Yes. I get it. But, sometimes it looks very fragile. What if you are adding something random as node? IMO, checking if you are actually adding a node is important as well. So making classes for Vertex, and Graph makes a lot of sense, IMO. I usually do it this way -&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;class Vertex(object):\n    # Contains variables as follows - \n    # visited = True/False\n    # neighbours = {Vertex : Edge weight}\n    # example -\n    # self.neighbours = {a : 2, b : -2}\n     # if undirected and unweighted, just do it accordingly.\n\nclass Graph(object):\n    # self.vertex = set()\n    # no data structure for edges as I am already covering it in class Vertex.\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;What do you think about it?&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg6b4dd", "score_hidden": false, "stickied": false, "created": 1492050493.0, "created_utc": 1492021693.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 2}}], "after": null, "before": null}}, "user_reports": [], "id": "dg5me9j", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "Wolfspaw", "parent_id": "t3_64vm47", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "For me, a *Default Dictionary* of Adjacency list is the most convenient way, even if it's less performant than the alternatives... You can have the vertices key be anything, like Strings: \"New York\" -&gt; \"Washington\". \n\nIt's very easy to read a Graph in such manner:\n\n    def readGraph():\n\t    G = defaultdict(list)\n\t    for line in f:\n\t\t    fr, to = line.split()\n\t\t    G[fr].append(to)\n\t\t    G[to].append(fr)\n\t    return G\n\n\n\n", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;For me, a &lt;em&gt;Default Dictionary&lt;/em&gt; of Adjacency list is the most convenient way, even if it&amp;#39;s less performant than the alternatives... You can have the vertices key be anything, like Strings: &amp;quot;New York&amp;quot; -&amp;gt; &amp;quot;Washington&amp;quot;. &lt;/p&gt;\n\n&lt;p&gt;It&amp;#39;s very easy to read a Graph in such manner:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;def readGraph():\n    G = defaultdict(list)\n    for line in f:\n        fr, to = line.split()\n        G[fr].append(to)\n        G[to].append(fr)\n    return G\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg5me9j", "score_hidden": false, "stickied": false, "created": 1492012581.0, "created_utc": 1491983781.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 3}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_64vm47", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_64vm47", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_64vm47", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_64vm47", "likes": null, "replies": "", "user_reports": [], "id": "dg6ck6s", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "lookatmetype", "parent_id": "t1_dg6b9tp", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "How would making it a class ensure that youre \"really\" adding a vertex?", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;How would making it a class ensure that youre &amp;quot;really&amp;quot; adding a vertex?&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg6ck6s", "score_hidden": false, "stickied": false, "created": 1492051968.0, "created_utc": 1492023168.0, "depth": 3, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg6b9tp", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "malhaar3148", "parent_id": "t1_dg5u3nx", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "How about making it as a class? in terms of class vertex and class Graph?\nWhy I get a bit apprehensive about using direct dictionary ds is because there is absolutely no check if we are really adding the vertex or not.\nI am just trying to look for a way which would be more accurate, and  _generally_ accepted in the interviews.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;How about making it as a class? in terms of class vertex and class Graph?\nWhy I get a bit apprehensive about using direct dictionary ds is because there is absolutely no check if we are really adding the vertex or not.\nI am just trying to look for a way which would be more accurate, and  &lt;em&gt;generally&lt;/em&gt; accepted in the interviews.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg6b9tp", "score_hidden": false, "stickied": false, "created": 1492050645.0, "created_utc": 1492021845.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg5u3nx", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "Zweedeend", "parent_id": "t1_dg5qc9g", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "I often use a dictionary like this:\n\n    graph = {'A': ['B', 'C'],\n             'B': ['C', 'D'],\n             'C': ['D'],\n             'D': ['C'],\n             'E': ['F'],\n             'F': ['C']}\n\nAs described in this classic essay: https://www.python.org/doc/essays/graphs/", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I often use a dictionary like this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;graph = {&amp;#39;A&amp;#39;: [&amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;],\n         &amp;#39;B&amp;#39;: [&amp;#39;C&amp;#39;, &amp;#39;D&amp;#39;],\n         &amp;#39;C&amp;#39;: [&amp;#39;D&amp;#39;],\n         &amp;#39;D&amp;#39;: [&amp;#39;C&amp;#39;],\n         &amp;#39;E&amp;#39;: [&amp;#39;F&amp;#39;],\n         &amp;#39;F&amp;#39;: [&amp;#39;C&amp;#39;]}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;As described in this classic essay: &lt;a href=\"https://www.python.org/doc/essays/graphs/\"&gt;https://www.python.org/doc/essays/graphs/&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg5u3nx", "score_hidden": false, "stickied": false, "created": 1492031551.0, "created_utc": 1492002751.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 3}}], "after": null, "before": null}}, "user_reports": [], "id": "dg5qc9g", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "lookatmetype", "parent_id": "t3_64vm47", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "Dictionaries are highly optimized in Python and dictionary lookups are constant time. \n\nHowever, adjacency matrix representation works well for graph algorithms and is a more natural representation for dense graphs. Keep these tradeoffs in mind. \n\nIf you're allowed to use numpy then you can get access to a highly optimized and easy to work with matrices as well. ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Dictionaries are highly optimized in Python and dictionary lookups are constant time. &lt;/p&gt;\n\n&lt;p&gt;However, adjacency matrix representation works well for graph algorithms and is a more natural representation for dense graphs. Keep these tradeoffs in mind. &lt;/p&gt;\n\n&lt;p&gt;If you&amp;#39;re allowed to use numpy then you can get access to a highly optimized and easy to work with matrices as well. &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg5qc9g", "score_hidden": false, "stickied": false, "created": 1492024463.0, "created_utc": 1491995663.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 3}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_64vm47", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_64vm47", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_64vm47", "likes": null, "replies": "", "user_reports": [], "id": "dg7ctg2", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "dozzinale", "parent_id": "t1_dg6bebc", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "Woa, actually I don't think that's a good idea (but I could be wrong). As doing that, you need to have `n` variables in order to unpack `range`. Moreover, if you're using python3, you're effectively consuming the generator.\n\nI could see that as `s = [e for e in range(n)]`.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Woa, actually I don&amp;#39;t think that&amp;#39;s a good idea (but I could be wrong). As doing that, you need to have &lt;code&gt;n&lt;/code&gt; variables in order to unpack &lt;code&gt;range&lt;/code&gt;. Moreover, if you&amp;#39;re using python3, you&amp;#39;re effectively consuming the generator.&lt;/p&gt;\n\n&lt;p&gt;I could see that as &lt;code&gt;s = [e for e in range(n)]&lt;/code&gt;.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg7ctg2", "score_hidden": false, "stickied": false, "created": 1492105220.0, "created_utc": 1492076420.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg6bebc", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "malhaar3148", "parent_id": "t1_dg5opes", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "Yup, using vertices as follows is very easy in Python!\n\n      a, b, c, .... = range(n)\nIt gets very handy! ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Yup, using vertices as follows is very easy in Python!&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;  a, b, c, .... = range(n)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It gets very handy! &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg6bebc", "score_hidden": false, "stickied": false, "created": 1492050772.0, "created_utc": 1492021972.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg5opes", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "dozzinale", "parent_id": "t3_64vm47", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "It depends on which you want to do with your graph. If you're allowing an intensive numbers of insertion/deletion of new nodes, so maybe an [adjacency list](https://en.wikipedia.org/wiki/Adjacency_list) representation is better than an [adjacency matrix](https://en.wikipedia.org/wiki/Adjacency_matrix) representation. Otherwise, the matrix one is the way to go.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;It depends on which you want to do with your graph. If you&amp;#39;re allowing an intensive numbers of insertion/deletion of new nodes, so maybe an &lt;a href=\"https://en.wikipedia.org/wiki/Adjacency_list\"&gt;adjacency list&lt;/a&gt; representation is better than an &lt;a href=\"https://en.wikipedia.org/wiki/Adjacency_matrix\"&gt;adjacency matrix&lt;/a&gt; representation. Otherwise, the matrix one is the way to go.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg5opes", "score_hidden": false, "stickied": false, "created": 1492019801.0, "created_utc": 1491991001.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 2}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_64vm47", "likes": null, "replies": "", "user_reports": [], "id": "dg6pvde", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "gunthercult28", "parent_id": "t3_64vm47", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "Honestly, for quick and dirty, from collections import namedtuple to define the relation by name. In graph DBs, you have some named relation you're querying for, and then you can store objects in those coordinates of the tuples. A graph then is just a set of relational tuples.\n\nThe problem becomes storing arrays of this cleanly, in which case I would honestly just implement it as a 3-field data frame, 4 if you want weight.\n\n(Relation; Left; Right; Weight)\n\nYou would need the tuples to represent one way relations and you can create symmetry by just creating a duplicate symmetric tuple.\n\nNot sure how memory looks for this implementation, but for readability and extensibility to databases at least, namedtuples provide tht extra set of named relational functionality that could be managed by a simple factory, and storing it in a table structure would give you some added query functionality and freedom to export the structure elsewhere for querying. \n\nThe draw back of the data frames is that row by row comparisons would suck, but you gain the relational join operator without needing to implement it yourself. But that's less a data structures question and more of a use case question. Do you want to optimize path generation? \n\nStoring rows and joining allow you to detect loops just by reading across a single row, and a row would represent an acceptable path. In fact n joins would generate all accept n-paths.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Honestly, for quick and dirty, from collections import namedtuple to define the relation by name. In graph DBs, you have some named relation you&amp;#39;re querying for, and then you can store objects in those coordinates of the tuples. A graph then is just a set of relational tuples.&lt;/p&gt;\n\n&lt;p&gt;The problem becomes storing arrays of this cleanly, in which case I would honestly just implement it as a 3-field data frame, 4 if you want weight.&lt;/p&gt;\n\n&lt;p&gt;(Relation; Left; Right; Weight)&lt;/p&gt;\n\n&lt;p&gt;You would need the tuples to represent one way relations and you can create symmetry by just creating a duplicate symmetric tuple.&lt;/p&gt;\n\n&lt;p&gt;Not sure how memory looks for this implementation, but for readability and extensibility to databases at least, namedtuples provide tht extra set of named relational functionality that could be managed by a simple factory, and storing it in a table structure would give you some added query functionality and freedom to export the structure elsewhere for querying. &lt;/p&gt;\n\n&lt;p&gt;The draw back of the data frames is that row by row comparisons would suck, but you gain the relational join operator without needing to implement it yourself. But that&amp;#39;s less a data structures question and more of a use case question. Do you want to optimize path generation? &lt;/p&gt;\n\n&lt;p&gt;Storing rows and joining allow you to detect loops just by reading across a single row, and a row would represent an acceptable path. In fact n joins would generate all accept n-paths.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg6pvde", "score_hidden": false, "stickied": false, "created": 1492066778.0, "created_utc": 1492037978.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}]