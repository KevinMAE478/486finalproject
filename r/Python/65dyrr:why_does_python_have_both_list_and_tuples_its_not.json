[{"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t3", "data": {"contest_mode": false, "banned_by": null, "media_embed": {}, "subreddit": "Python", "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;its confusing some times &lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;enumerable&lt;/code&gt; return tuples &lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;splits&lt;/code&gt; return lists \n....&lt;/p&gt;\n\n&lt;p&gt;could you explain why python need them both .. &lt;/p&gt;\n\n&lt;p&gt;Thank you . &lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "selftext": "its confusing some times \n\n`enumerable` return tuples \n\n`splits` return lists \n....\n\ncould you explain why python need them both .. \n\nThank you . ", "likes": null, "suggested_sort": null, "user_reports": [], "secure_media": null, "link_flair_text": null, "id": "65dyrr", "gilded": 0, "secure_media_embed": {}, "clicked": false, "score": 40, "report_reasons": null, "author": "eid-a", "saved": false, "mod_reports": [], "name": "t3_65dyrr", "subreddit_name_prefixed": "r/Python", "approved_by": null, "over_18": false, "domain": "self.Python", "hidden": false, "thumbnail": "", "subreddit_id": "t5_2qh0y", "edited": false, "link_flair_css_class": null, "author_flair_css_class": null, "downs": 0, "brand_safe": true, "archived": false, "removal_reason": null, "is_self": true, "hide_score": false, "spoiler": false, "permalink": "/r/Python/comments/65dyrr/why_does_python_have_both_list_and_tuples_its_not/", "num_reports": null, "locked": false, "stickied": false, "created": 1492220316.0, "url": "https://www.reddit.com/r/Python/comments/65dyrr/why_does_python_have_both_list_and_tuples_its_not/", "author_flair_text": null, "quarantine": false, "title": "Why does python have both list and tuples , its not obvious to me ?", "created_utc": 1492191516.0, "distinguished": null, "media": null, "upvote_ratio": 0.81, "num_comments": 32, "visited": false, "subreddit_type": "public", "ups": 40}}], "after": null, "before": null}}, {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": "", "user_reports": [], "id": "dg9h4h4", "gilded": 0, "archived": false, "score": 111, "report_reasons": null, "author": "novel_yet_trivial", "parent_id": "t3_65dyrr", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "One is mutable, one is not. Similar to `bytes` vs `bytearray` or `set` vs `frozenset`. Tuples are (very slightly) faster to produce. \n\nHowever more important is the semantic difference. \n\nA tuple is for a group of dissimilar things that are related to each other. The order and length of a tuple is usually very important, mixing the order or changing the length would corrupt the data. For example we can describe a house by the type of walls, how many stories, type of roof: `house = ('brick', 1, 'tile')`. \n\nA list is for collections of similar things. The order is sometimes important but often can be mixed, and the length is usually variable. For example we can describe the rooms in a house: `house = ['bathroom', 'bedroom', 'kitchen', 'bathroom']`.\n\n`enumerate` returns tuples because it returns exactly 2 dissimilar things that are related. Same for `zip`. On the other hand, `split` returns a collection of similar things, where the length is variable.  ", "edited": 1492192260.0, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;One is mutable, one is not. Similar to &lt;code&gt;bytes&lt;/code&gt; vs &lt;code&gt;bytearray&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; vs &lt;code&gt;frozenset&lt;/code&gt;. Tuples are (very slightly) faster to produce. &lt;/p&gt;\n\n&lt;p&gt;However more important is the semantic difference. &lt;/p&gt;\n\n&lt;p&gt;A tuple is for a group of dissimilar things that are related to each other. The order and length of a tuple is usually very important, mixing the order or changing the length would corrupt the data. For example we can describe a house by the type of walls, how many stories, type of roof: &lt;code&gt;house = (&amp;#39;brick&amp;#39;, 1, &amp;#39;tile&amp;#39;)&lt;/code&gt;. &lt;/p&gt;\n\n&lt;p&gt;A list is for collections of similar things. The order is sometimes important but often can be mixed, and the length is usually variable. For example we can describe the rooms in a house: &lt;code&gt;house = [&amp;#39;bathroom&amp;#39;, &amp;#39;bedroom&amp;#39;, &amp;#39;kitchen&amp;#39;, &amp;#39;bathroom&amp;#39;]&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;enumerate&lt;/code&gt; returns tuples because it returns exactly 2 dissimilar things that are related. Same for &lt;code&gt;zip&lt;/code&gt;. On the other hand, &lt;code&gt;split&lt;/code&gt; returns a collection of similar things, where the length is variable.  &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg9h4h4", "score_hidden": false, "stickied": false, "created": 1492220750.0, "created_utc": 1492191950.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 111}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": "", "user_reports": [], "id": "dgb5zoa", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "cybervegan", "parent_id": "t1_dgb41wq", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "Most certainly. On both counts.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Most certainly. On both counts.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dgb5zoa", "score_hidden": false, "stickied": false, "created": 1492318688.0, "created_utc": 1492289888.0, "depth": 6, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dgb41wq", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "breamoreboy", "parent_id": "t1_dgazdd4", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "Ned has forgotten more about Python than you'll probably ever know.\n\nAs for tuples against lists who really cares?  Why bother about microoptimizations in Python when the entire ethos is about readability and maintainability, hence programmer time and money.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Ned has forgotten more about Python than you&amp;#39;ll probably ever know.&lt;/p&gt;\n\n&lt;p&gt;As for tuples against lists who really cares?  Why bother about microoptimizations in Python when the entire ethos is about readability and maintainability, hence programmer time and money.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dgb41wq", "score_hidden": false, "stickied": false, "created": 1492316056.0, "created_utc": 1492287256.0, "depth": 5, "mod_reports": [], "subreddit_type": "public", "ups": 1}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": "", "user_reports": [], "id": "dgb7co2", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "elbiot", "parent_id": "t1_dgazdd4", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "I think you're both right. A tuple is not more simple. It's an array of pointers. It's also got that array in the struct, which does not make it more simple but makes it slightly faster to instantiate. But by such a small amount it isn't even worth talking about. You can't optimize things like cache hits in python because the interpreter is going to do what it wants.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I think you&amp;#39;re both right. A tuple is not more simple. It&amp;#39;s an array of pointers. It&amp;#39;s also got that array in the struct, which does not make it more simple but makes it slightly faster to instantiate. But by such a small amount it isn&amp;#39;t even worth talking about. You can&amp;#39;t optimize things like cache hits in python because the interpreter is going to do what it wants.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dgb7co2", "score_hidden": false, "stickied": false, "created": 1492320593.0, "created_utc": 1492291793.0, "depth": 5, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dgazdd4", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "cybervegan", "parent_id": "t1_dgarxu3", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "You can't know everyone involved ;-) I recognised Raymond, but had to look Ned up. My bad.\n\nIf Ned comes back with an explanation of why I'm wrong, I'll gladly defer.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;You can&amp;#39;t know everyone involved ;-) I recognised Raymond, but had to look Ned up. My bad.&lt;/p&gt;\n\n&lt;p&gt;If Ned comes back with an explanation of why I&amp;#39;m wrong, I&amp;#39;ll gladly defer.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dgazdd4", "score_hidden": false, "stickied": false, "created": 1492309730.0, "created_utc": 1492280930.0, "depth": 4, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dgarxu3", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "elbiot", "parent_id": "t1_dgaffuv", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "I like how cybervegan just told Ned Batchelder to look into a very important python contributor named Raymond Hettinger and to use timeit.  Ah, the internet", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I like how cybervegan just told Ned Batchelder to look into a very important python contributor named Raymond Hettinger and to use timeit.  Ah, the internet&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dgarxu3", "score_hidden": false, "stickied": false, "created": 1492299478.0, "created_utc": 1492270678.0, "depth": 3, "mod_reports": [], "subreddit_type": "public", "ups": 3}}], "after": null, "before": null}}, "user_reports": [], "id": "dgaffuv", "gilded": 0, "archived": false, "score": 4, "report_reasons": null, "author": "cybervegan", "parent_id": "t1_dg9we5n", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "Ok, things change, so since I learnt that tuples were more efficient, I don't know, maybe 15 years ago, things might have changed. I don't have time to deep dive this, but a quick google search does turn up evidence that certain operations (such as instantiation) are faster. And the data structures *are* indeed different, but not drastically so: the list of pointers to elements is kept *inside* the tuple struct, whereas for a list, it is *external* to the struct. This has implications for CPU cache locality - extra indirection means more cache flushes, which will slow things down. \n\nThis stackoverflow question discusses this and shows several views, with an answer from Raymond Hettinger (a very important Python contributor) which explains about the data structures: http://stackoverflow.com/questions/68630/are-tuples-more-efficient-than-lists-in-python\n\nHowever, if you are ever bothered about the performance of using one method versus another, the only real way to know for sure is to *test* it, under your particular use case. `timeit` can help immensely here.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Ok, things change, so since I learnt that tuples were more efficient, I don&amp;#39;t know, maybe 15 years ago, things might have changed. I don&amp;#39;t have time to deep dive this, but a quick google search does turn up evidence that certain operations (such as instantiation) are faster. And the data structures &lt;em&gt;are&lt;/em&gt; indeed different, but not drastically so: the list of pointers to elements is kept &lt;em&gt;inside&lt;/em&gt; the tuple struct, whereas for a list, it is &lt;em&gt;external&lt;/em&gt; to the struct. This has implications for CPU cache locality - extra indirection means more cache flushes, which will slow things down. &lt;/p&gt;\n\n&lt;p&gt;This stackoverflow question discusses this and shows several views, with an answer from Raymond Hettinger (a very important Python contributor) which explains about the data structures: &lt;a href=\"http://stackoverflow.com/questions/68630/are-tuples-more-efficient-than-lists-in-python\"&gt;http://stackoverflow.com/questions/68630/are-tuples-more-efficient-than-lists-in-python&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;However, if you are ever bothered about the performance of using one method versus another, the only real way to know for sure is to &lt;em&gt;test&lt;/em&gt; it, under your particular use case. &lt;code&gt;timeit&lt;/code&gt; can help immensely here.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dgaffuv", "score_hidden": false, "stickied": false, "created": 1492270735.0, "created_utc": 1492241935.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 4}}], "after": null, "before": null}}, "user_reports": [], "id": "dg9we5n", "gilded": 0, "archived": false, "score": 5, "report_reasons": null, "author": "nedbatchelder", "parent_id": "t1_dg9vn4n", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "Tuples don't have a simpler data structure than lists. They are both vectors of object references, and there is only a microscopic efficiency difference, if any.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Tuples don&amp;#39;t have a simpler data structure than lists. They are both vectors of object references, and there is only a microscopic efficiency difference, if any.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg9we5n", "score_hidden": false, "stickied": false, "created": 1492239660.0, "created_utc": 1492210860.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": 5}}], "after": null, "before": null}}, "user_reports": [], "id": "dg9vn4n", "gilded": 0, "archived": false, "score": 5, "report_reasons": null, "author": "cybervegan", "parent_id": "t3_65dyrr", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "The main reason is efficiency and the other is immutability and they're both deeply entwined. Because tuples don't have to support changes - adding, removing, sorting etc. they can use a simpler, more efficient data structure, so they're faster to operate on. But also because they can't be changed - they are *immutable* - they can be used as dictionary keys, whereas lists cannot.\n\n\n    tup = (1,2,3)\n    dct1 = { tup: \"blah\" } # this will work\n    lst = [1,2,3]\n    dct2 = { lst: \"blah\" } # this will give you a key error", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;The main reason is efficiency and the other is immutability and they&amp;#39;re both deeply entwined. Because tuples don&amp;#39;t have to support changes - adding, removing, sorting etc. they can use a simpler, more efficient data structure, so they&amp;#39;re faster to operate on. But also because they can&amp;#39;t be changed - they are &lt;em&gt;immutable&lt;/em&gt; - they can be used as dictionary keys, whereas lists cannot.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;tup = (1,2,3)\ndct1 = { tup: &amp;quot;blah&amp;quot; } # this will work\nlst = [1,2,3]\ndct2 = { lst: &amp;quot;blah&amp;quot; } # this will give you a key error\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg9vn4n", "score_hidden": false, "stickied": false, "created": 1492238654.0, "created_utc": 1492209854.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 5}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": "", "user_reports": [], "id": "dgary0n", "gilded": 0, "archived": false, "score": 4, "report_reasons": null, "author": "jstrickler", "parent_id": "t3_65dyrr", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "The best analogy for tuples is to think of a tuple as a *record*, like one row in a database table. The table itself is more like a list, because you can add and delete rows, but each record is fixed size, and the position of each element is important. \n\nAnother way of thinking of a tuple is that it is similar to a C *struct* -- as others have said, a fixed-size collection of similar things. \n\nEven though it technically is an iterable, you would NOT normally use a **for** loop with a tuple, because it is not a series of similar things, but a collection of *related* things. ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;The best analogy for tuples is to think of a tuple as a &lt;em&gt;record&lt;/em&gt;, like one row in a database table. The table itself is more like a list, because you can add and delete rows, but each record is fixed size, and the position of each element is important. &lt;/p&gt;\n\n&lt;p&gt;Another way of thinking of a tuple is that it is similar to a C &lt;em&gt;struct&lt;/em&gt; -- as others have said, a fixed-size collection of similar things. &lt;/p&gt;\n\n&lt;p&gt;Even though it technically is an iterable, you would NOT normally use a &lt;strong&gt;for&lt;/strong&gt; loop with a tuple, because it is not a series of similar things, but a collection of &lt;em&gt;related&lt;/em&gt; things. &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dgary0n", "score_hidden": false, "stickied": false, "created": 1492299486.0, "created_utc": 1492270686.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 4}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": "", "user_reports": [], "id": "dg9kr10", "gilded": 0, "archived": false, "score": 14, "report_reasons": null, "author": "mfitzp", "parent_id": "t1_dg9jnpd", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "It's better to think of tuples as simple data objects than lists of values. They're useful any time you want to work with *connected* pieces of information. \n\nFor a lookup, it's a contrived example *and not practical advice* but one situation where you have two pieces of directly connected info is login. Tuples allow you to bundle these sorts of grouped information together and then work with them as a unit, e.g.\n\n    user_pass = [\n        (\"username1\", \"password1\"), \n        (\"username2\", \"password2\")...\n    ]\n\n    (user, password) in user_pass\n\nYou could use the same sort of lookup on a dict to get some other data. Think about how you would do the above without a tuple structure.\n\n    user_pass = {\n        (\"username1\", \"password1\"): \"api_key1\",\n        (\"username2\", \"password2\"): \"api_key2\"\n    ...\n    }\n\n     api_key = user_pass.get((user, password), None)\n\nOther examples would be (x, y) coordinates, and (first_name, last_name) pairs.\n   ", "edited": 1492251139.0, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;It&amp;#39;s better to think of tuples as simple data objects than lists of values. They&amp;#39;re useful any time you want to work with &lt;em&gt;connected&lt;/em&gt; pieces of information. &lt;/p&gt;\n\n&lt;p&gt;For a lookup, it&amp;#39;s a contrived example &lt;em&gt;and not practical advice&lt;/em&gt; but one situation where you have two pieces of directly connected info is login. Tuples allow you to bundle these sorts of grouped information together and then work with them as a unit, e.g.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;user_pass = [\n    (&amp;quot;username1&amp;quot;, &amp;quot;password1&amp;quot;), \n    (&amp;quot;username2&amp;quot;, &amp;quot;password2&amp;quot;)...\n]\n\n(user, password) in user_pass\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You could use the same sort of lookup on a dict to get some other data. Think about how you would do the above without a tuple structure.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;user_pass = {\n    (&amp;quot;username1&amp;quot;, &amp;quot;password1&amp;quot;): &amp;quot;api_key1&amp;quot;,\n    (&amp;quot;username2&amp;quot;, &amp;quot;password2&amp;quot;): &amp;quot;api_key2&amp;quot;\n...\n}\n\n api_key = user_pass.get((user, password), None)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Other examples would be (x, y) coordinates, and (first_name, last_name) pairs.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg9kr10", "score_hidden": false, "stickied": false, "created": 1492225061.0, "created_utc": 1492196261.0, "depth": 4, "mod_reports": [], "subreddit_type": "public", "ups": 14}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": "", "user_reports": [], "id": "dga29qg", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "thegreattriscuit", "parent_id": "t1_dg9l2zd", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "Damn, you said what I said but better and with an actual justification.  Nice.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Damn, you said what I said but better and with an actual justification.  Nice.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dga29qg", "score_hidden": false, "stickied": false, "created": 1492247494.0, "created_utc": 1492218694.0, "depth": 5, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg9l2zd", "gilded": 0, "archived": false, "score": 9, "report_reasons": null, "author": "Vaphell", "parent_id": "t1_dg9jnpd", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "consider a sparsely populated grid. Instead of storing a list of rows of cells you could just have (x,y) as keys.\n\n10x10 grid with 3 items is a difference between a collection of 100 objects where 3 are different and 1 dict with 3.\n\nanything that can be unambiguously identified by some kind of compound key can be stored in a tuple-indexed dict.", "edited": 1492196939.0, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;consider a sparsely populated grid. Instead of storing a list of rows of cells you could just have (x,y) as keys.&lt;/p&gt;\n\n&lt;p&gt;10x10 grid with 3 items is a difference between a collection of 100 objects where 3 are different and 1 dict with 3.&lt;/p&gt;\n\n&lt;p&gt;anything that can be unambiguously identified by some kind of compound key can be stored in a tuple-indexed dict.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg9l2zd", "score_hidden": false, "stickied": false, "created": 1492225461.0, "created_utc": 1492196661.0, "depth": 4, "mod_reports": [], "subreddit_type": "public", "ups": 9}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": "", "user_reports": [], "id": "dg9r74c", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "bheklilr", "parent_id": "t1_dg9jnpd", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "I've had plenty of use cases.  A somewhat common one that I see is when I have a pattern like\n\n    if condition:\n        if x == 'A':\n            do_a()\n        elif x == 'B':\n            do_c()\n        else:\n            do_default()\n    else:\n        if x = 'A':\n            do_other_a()\n        elif x == 'B':\n            do_other_b()\n        elif x == 'C':\n            do_c()\n        else:\n            do_default()\n\nIt's much nicer (IMO) to do\n\n    {\n        (True,  'A'): do_a,\n        (True,  'B'): do_b,\n        (False, 'A'): do_other_a,\n        (False, 'B'): do_other_b,\n        (False, 'C'): do_c,\n    }.get((condition, x), do_default)()\n\nIt's pretty much a switch statement, just with data rather than a control structure.  That dictionary might also be populated from user inputs, so it makes this pattern more scalable as options for `x` are added.  Also, if you have another condition to add to this, editing the keys to have 3 elements instead of 2 is pretty easy, whereas editing multiple nested dictionaries or ifs becomes more difficult.  With the nested style (dict or if) each branch has to handle the default case.\n\nI also have an example in the project I'm currently working on, which has to work with a bunch of products.  Each product has a unique series number/part number combination, although it is possible to have two identical part numbers in different series.  In part of the code it just makes a lot of sense to have a dictionary storing all of these with the structure\n\n    {(series_number, part_number): part_info}\n\nWhen a part is selected, it raises an event containing the series number and part number, so I use that tuple as an index to get the part information out that is needed for performing the next operation.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;ve had plenty of use cases.  A somewhat common one that I see is when I have a pattern like&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;if condition:\n    if x == &amp;#39;A&amp;#39;:\n        do_a()\n    elif x == &amp;#39;B&amp;#39;:\n        do_c()\n    else:\n        do_default()\nelse:\n    if x = &amp;#39;A&amp;#39;:\n        do_other_a()\n    elif x == &amp;#39;B&amp;#39;:\n        do_other_b()\n    elif x == &amp;#39;C&amp;#39;:\n        do_c()\n    else:\n        do_default()\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It&amp;#39;s much nicer (IMO) to do&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;{\n    (True,  &amp;#39;A&amp;#39;): do_a,\n    (True,  &amp;#39;B&amp;#39;): do_b,\n    (False, &amp;#39;A&amp;#39;): do_other_a,\n    (False, &amp;#39;B&amp;#39;): do_other_b,\n    (False, &amp;#39;C&amp;#39;): do_c,\n}.get((condition, x), do_default)()\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It&amp;#39;s pretty much a switch statement, just with data rather than a control structure.  That dictionary might also be populated from user inputs, so it makes this pattern more scalable as options for &lt;code&gt;x&lt;/code&gt; are added.  Also, if you have another condition to add to this, editing the keys to have 3 elements instead of 2 is pretty easy, whereas editing multiple nested dictionaries or ifs becomes more difficult.  With the nested style (dict or if) each branch has to handle the default case.&lt;/p&gt;\n\n&lt;p&gt;I also have an example in the project I&amp;#39;m currently working on, which has to work with a bunch of products.  Each product has a unique series number/part number combination, although it is possible to have two identical part numbers in different series.  In part of the code it just makes a lot of sense to have a dictionary storing all of these with the structure&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;{(series_number, part_number): part_info}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;When a part is selected, it raises an event containing the series number and part number, so I use that tuple as an index to get the part information out that is needed for performing the next operation.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg9r74c", "score_hidden": false, "stickied": false, "created": 1492232860.0, "created_utc": 1492204060.0, "depth": 4, "mod_reports": [], "subreddit_type": "public", "ups": 3}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": "", "user_reports": [], "id": "dg9v7xl", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "auriscope", "parent_id": "t1_dg9nit9", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "You can skip dict initialization like this:\n\n    from collections import defaultdict\n    g = defaultdict(list) # calls the function passed as argument whenever KeyError would occur\n    g[0].append(1) # adds an edge from 0 to 1 in the adjacency list\n\nFor nested dicts, you need to do this:\n\n    g = defaultdict(lambda : defaultdict(list))\n    g[0][1].append(2)\n", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;You can skip dict initialization like this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;from collections import defaultdict\ng = defaultdict(list) # calls the function passed as argument whenever KeyError would occur\ng[0].append(1) # adds an edge from 0 to 1 in the adjacency list\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;For nested dicts, you need to do this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;g = defaultdict(lambda : defaultdict(list))\ng[0][1].append(2)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg9v7xl", "score_hidden": false, "stickied": false, "created": 1492238080.0, "created_utc": 1492209280.0, "depth": 5, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg9nit9", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "Quijoticmoose", "parent_id": "t1_dg9jnpd", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "I actually use it fairly often.\n\nI usually think of a `tuple`-keyed `dict` as isomorphic to a nested `dict`:\n\n    d[(a, b, c)] == d[a][b][c]\n\nHowever, it saves you a few steps in initializing; in order to do the nested `dict` you have to create both the containing dict and its lower-level ones, i.e.,\n\n    overall_data = dict()\n    for s in list_of_students:\n        overall_data[s] = dict()\n        overall_data[s]['English Grade'] = get_english_grade(s)\n\n(If there is an easy way to skip having to create the inner `dict`, I welcome the solution!)\n\nSometimes it might be more straightforward to do:\n\n    overall_data = dict()\n    for s in list_of_students:\n        overall_data[(s, 'English Grade')] = get_english_grade(s)\n", "edited": 1492199785.0, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I actually use it fairly often.&lt;/p&gt;\n\n&lt;p&gt;I usually think of a &lt;code&gt;tuple&lt;/code&gt;-keyed &lt;code&gt;dict&lt;/code&gt; as isomorphic to a nested &lt;code&gt;dict&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;d[(a, b, c)] == d[a][b][c]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;However, it saves you a few steps in initializing; in order to do the nested &lt;code&gt;dict&lt;/code&gt; you have to create both the containing dict and its lower-level ones, i.e.,&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;overall_data = dict()\nfor s in list_of_students:\n    overall_data[s] = dict()\n    overall_data[s][&amp;#39;English Grade&amp;#39;] = get_english_grade(s)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;(If there is an easy way to skip having to create the inner &lt;code&gt;dict&lt;/code&gt;, I welcome the solution!)&lt;/p&gt;\n\n&lt;p&gt;Sometimes it might be more straightforward to do:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;overall_data = dict()\nfor s in list_of_students:\n    overall_data[(s, &amp;#39;English Grade&amp;#39;)] = get_english_grade(s)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg9nit9", "score_hidden": false, "stickied": false, "created": 1492228404.0, "created_utc": 1492199604.0, "depth": 4, "mod_reports": [], "subreddit_type": "public", "ups": 2}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": "", "user_reports": [], "id": "dg9tjpi", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "maxm", "parent_id": "t1_dg9jnpd", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "A simple use case is a threaded discussion forum. Instead of making a recursive structure you can just use integer tuples and sort those.\n\n    1\n    1,1\n    1,2\n    2\n    2,1\n    2,1,1", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;A simple use case is a threaded discussion forum. Instead of making a recursive structure you can just use integer tuples and sort those.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;1\n1,1\n1,2\n2\n2,1\n2,1,1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg9tjpi", "score_hidden": false, "stickied": false, "created": 1492235863.0, "created_utc": 1492207063.0, "depth": 4, "mod_reports": [], "subreddit_type": "public", "ups": 2}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": "", "user_reports": [], "id": "dga0w6g", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "SearchAtlantis", "parent_id": "t1_dg9jnpd", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "Simplified work example. Data for measures come in from two different days systems. \n\nSo I might make a dictionary whose key is (ID, measure, data system a):dataframe and (ID, measure, data system b):dataframe. ", "edited": 1492219332.0, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Simplified work example. Data for measures come in from two different days systems. &lt;/p&gt;\n\n&lt;p&gt;So I might make a dictionary whose key is (ID, measure, data system a):dataframe and (ID, measure, data system b):dataframe. &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dga0w6g", "score_hidden": false, "stickied": false, "created": 1492245635.0, "created_utc": 1492216835.0, "depth": 4, "mod_reports": [], "subreddit_type": "public", "ups": 1}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": "", "user_reports": [], "id": "dga26g0", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "thegreattriscuit", "parent_id": "t1_dg9jnpd", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "Off the top of my head, if you want to store information about a coordinate on an x,y plane you could do this:\n\n    important_points = {\n        (0, 0): {'label': 'origin', 'value_1': 100, 'value_2': 200},\n        (10, 10): {'label': 'center', 'value_1': 0, 'value_2': 0}\n    }\n\nSo basically any time you want to store information about unique combinations of certain values.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Off the top of my head, if you want to store information about a coordinate on an x,y plane you could do this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;important_points = {\n    (0, 0): {&amp;#39;label&amp;#39;: &amp;#39;origin&amp;#39;, &amp;#39;value_1&amp;#39;: 100, &amp;#39;value_2&amp;#39;: 200},\n    (10, 10): {&amp;#39;label&amp;#39;: &amp;#39;center&amp;#39;, &amp;#39;value_1&amp;#39;: 0, &amp;#39;value_2&amp;#39;: 0}\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So basically any time you want to store information about unique combinations of certain values.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dga26g0", "score_hidden": false, "stickied": false, "created": 1492247366.0, "created_utc": 1492218566.0, "depth": 4, "mod_reports": [], "subreddit_type": "public", "ups": 1}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": "", "user_reports": [], "id": "dgabo6w", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "baubleglue", "parent_id": "t1_dg9jnpd", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "&gt; what are the use cases\n\nLook at the way Redis DB keys are named [\"user:1000:followers\"](https://redis.io/topics/data-types-intro) or any `group by` SQL query - that is exactly the use case when you can use tuples as a key. ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;blockquote&gt;\n&lt;p&gt;what are the use cases&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Look at the way Redis DB keys are named &lt;a href=\"https://redis.io/topics/data-types-intro\"&gt;&amp;quot;user:1000:followers&amp;quot;&lt;/a&gt; or any &lt;code&gt;group by&lt;/code&gt; SQL query - that is exactly the use case when you can use tuples as a key. &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dgabo6w", "score_hidden": false, "stickied": false, "created": 1492262051.0, "created_utc": 1492233251.0, "depth": 4, "mod_reports": [], "subreddit_type": "public", "ups": 1}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": "", "user_reports": [], "id": "dg9knx3", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "pvkooten", "parent_id": "t1_dg9jnpd", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "It's very nice, unfortunately the main reason *not* to do it, is because it won't serialize to JSON. A simple case could be when (1, 2) is considered different from (2, 1) as keys. I'm sure you will find a use case yourself in some time... being aware it is possible is good enough.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;It&amp;#39;s very nice, unfortunately the main reason &lt;em&gt;not&lt;/em&gt; to do it, is because it won&amp;#39;t serialize to JSON. A simple case could be when (1, 2) is considered different from (2, 1) as keys. I&amp;#39;m sure you will find a use case yourself in some time... being aware it is possible is good enough.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg9knx3", "score_hidden": false, "stickied": false, "created": 1492224957.0, "created_utc": 1492196157.0, "depth": 4, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg9jnpd", "gilded": 0, "archived": false, "score": 0, "report_reasons": null, "author": "eid-a", "parent_id": "t1_dg9jd4n", "subreddit_name_prefixed": "r/Python", "controversiality": 1, "body": "what are the use cases that u have to use a `tuple` as a `dict` key ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;what are the use cases that u have to use a &lt;code&gt;tuple&lt;/code&gt; as a &lt;code&gt;dict&lt;/code&gt; key &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg9jnpd", "score_hidden": false, "stickied": false, "created": 1492223751.0, "created_utc": 1492194951.0, "depth": 3, "mod_reports": [], "subreddit_type": "public", "ups": 0}}], "after": null, "before": null}}, "user_reports": [], "id": "dg9jd4n", "gilded": 0, "archived": false, "score": 12, "report_reasons": null, "author": "Vaphell", "parent_id": "t1_dg9hrvv", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "tuples are hashable, which means they can be used as dict keys. Lists are not, so they cannot.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;tuples are hashable, which means they can be used as dict keys. Lists are not, so they cannot.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg9jd4n", "score_hidden": false, "stickied": false, "created": 1492223391.0, "created_utc": 1492194591.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 12}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": {"kind": "Listing", "data": {"modhash": "", "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": "", "user_reports": [], "id": "dg9kvo8", "gilded": 0, "archived": false, "score": 7, "report_reasons": null, "author": "tunisia3507", "parent_id": "t1_dg9juss", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "You'd be surprised, there are definitely use cases for tuples as keys! For example, if you had a hierarchical naming scheme but didn't want to faff with nested dictionaries with different depths in different branches of the tree, or if you were using tuples as thin objects, like defining playing cards as (number, suit) like (1, 'S'). Your dictionary could be the string representation of those cards, like {(1, 'S'): 'Ace of Spades'}.\n\nAs for the default argument, here are a couple of examples.\n\n    def foo(lst=[]):\n        lst.append(1)\n        return lst\n        \n    lst1 = foo()\n    lst2 = foo()\n\nWhat do you think `lst1` and `lst2` are? Are they the same object or different objects? They are actually both references to the same list, which means appending to one will append to both.\n\nThe default arguments are only interpreted once, when `foo()` is interpreted (not called!). Which means that every subsequent call of `foo()` is referring to the same list in memory, and every new call appends to the same list. So calling `foo()` for a third time means that lst1 = lst2 = [1, 1, 1].\n\nI came across this issue when trying to code blackjack some years ago:\n\n    class Player:\n        def __init__(self, hand=[]):\n            self.hand = hand\n            \n    player1 = Player()\n    player1.hand.append('Ace of Spades')\n    player2 = Player()\n    print(player2.hand)\n\nAnd I was shocked to discover that all the players had identical hands at all times.\n\nThe accepted pattern to get around this is usually:\n\n    def foo(lst=None):\n        if lst is None:\n            lst = []\n        lst.append(1)\n        return lst\n\nIn this case, a new list is instantiated for every call of `foo()`.\n\nYou could also do:\n\n    def bar(inputs=(1,2,3)):\n        numbers = list(inputs)  # also helps for sets, iterators\n        numbers.append(1)\n        return numbers", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;You&amp;#39;d be surprised, there are definitely use cases for tuples as keys! For example, if you had a hierarchical naming scheme but didn&amp;#39;t want to faff with nested dictionaries with different depths in different branches of the tree, or if you were using tuples as thin objects, like defining playing cards as (number, suit) like (1, &amp;#39;S&amp;#39;). Your dictionary could be the string representation of those cards, like {(1, &amp;#39;S&amp;#39;): &amp;#39;Ace of Spades&amp;#39;}.&lt;/p&gt;\n\n&lt;p&gt;As for the default argument, here are a couple of examples.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;def foo(lst=[]):\n    lst.append(1)\n    return lst\n\nlst1 = foo()\nlst2 = foo()\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;What do you think &lt;code&gt;lst1&lt;/code&gt; and &lt;code&gt;lst2&lt;/code&gt; are? Are they the same object or different objects? They are actually both references to the same list, which means appending to one will append to both.&lt;/p&gt;\n\n&lt;p&gt;The default arguments are only interpreted once, when &lt;code&gt;foo()&lt;/code&gt; is interpreted (not called!). Which means that every subsequent call of &lt;code&gt;foo()&lt;/code&gt; is referring to the same list in memory, and every new call appends to the same list. So calling &lt;code&gt;foo()&lt;/code&gt; for a third time means that lst1 = lst2 = [1, 1, 1].&lt;/p&gt;\n\n&lt;p&gt;I came across this issue when trying to code blackjack some years ago:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;class Player:\n    def __init__(self, hand=[]):\n        self.hand = hand\n\nplayer1 = Player()\nplayer1.hand.append(&amp;#39;Ace of Spades&amp;#39;)\nplayer2 = Player()\nprint(player2.hand)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And I was shocked to discover that all the players had identical hands at all times.&lt;/p&gt;\n\n&lt;p&gt;The accepted pattern to get around this is usually:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;def foo(lst=None):\n    if lst is None:\n        lst = []\n    lst.append(1)\n    return lst\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In this case, a new list is instantiated for every call of &lt;code&gt;foo()&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;You could also do:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;def bar(inputs=(1,2,3)):\n    numbers = list(inputs)  # also helps for sets, iterators\n    numbers.append(1)\n    return numbers\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg9kvo8", "score_hidden": false, "stickied": false, "created": 1492225217.0, "created_utc": 1492196417.0, "depth": 4, "mod_reports": [], "subreddit_type": "public", "ups": 7}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": "", "user_reports": [], "id": "dg9vzpo", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "jimminy", "parent_id": "t1_dg9juss", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "Never say never.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Never say never.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg9vzpo", "score_hidden": false, "stickied": false, "created": 1492239121.0, "created_utc": 1492210321.0, "depth": 4, "mod_reports": [], "subreddit_type": "public", "ups": 3}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": "", "user_reports": [], "id": "dga6o9d", "gilded": 0, "archived": false, "score": 1, "report_reasons": null, "author": "JimBoonie69", "parent_id": "t1_dg9juss", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "yeah, kinda of funny but we just pushed some code that uses tuples as keys in a dict!", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;yeah, kinda of funny but we just pushed some code that uses tuples as keys in a dict!&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dga6o9d", "score_hidden": false, "stickied": false, "created": 1492253725.0, "created_utc": 1492224925.0, "depth": 4, "mod_reports": [], "subreddit_type": "public", "ups": 1}}], "after": null, "before": null}}, "user_reports": [], "id": "dg9juss", "gilded": 0, "archived": false, "score": 0, "report_reasons": null, "author": "eid-a", "parent_id": "t1_dg9ingo", "subreddit_name_prefixed": "r/Python", "controversiality": 1, "body": "I don't think I'd ever want to make a `dict` key a tuple , but however sets would make sense if tuples always have the same `id` which I think they don't , could u explain the default argument , if possible with an example please ,, thank u . ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I don&amp;#39;t think I&amp;#39;d ever want to make a &lt;code&gt;dict&lt;/code&gt; key a tuple , but however sets would make sense if tuples always have the same &lt;code&gt;id&lt;/code&gt; which I think they don&amp;#39;t , could u explain the default argument , if possible with an example please ,, thank u . &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg9juss", "score_hidden": false, "stickied": false, "created": 1492223985.0, "created_utc": 1492195185.0, "depth": 3, "mod_reports": [], "subreddit_type": "public", "ups": 0}}], "after": null, "before": null}}, "user_reports": [], "id": "dg9ingo", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "tunisia3507", "parent_id": "t1_dg9hrvv", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "Performance differences are generally small if they exist at all. I agree that on reflection, it seems to be inconsistent with python's \"consenting adults\" philosophy, but there are times when you need immutable/ hashable sequences - for example inserting them into sets or using them as keys in dicts, or as the default argument in a function definition. I don't know anything about ruby, but js didn't support default arguments for a long time (some browsers still don't) and I don't know how it deals with mutables in there now, and its set implementation may be hash-based but doesn't define hashable/ unhashable types so it's unreliable.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Performance differences are generally small if they exist at all. I agree that on reflection, it seems to be inconsistent with python&amp;#39;s &amp;quot;consenting adults&amp;quot; philosophy, but there are times when you need immutable/ hashable sequences - for example inserting them into sets or using them as keys in dicts, or as the default argument in a function definition. I don&amp;#39;t know anything about ruby, but js didn&amp;#39;t support default arguments for a long time (some browsers still don&amp;#39;t) and I don&amp;#39;t know how it deals with mutables in there now, and its set implementation may be hash-based but doesn&amp;#39;t define hashable/ unhashable types so it&amp;#39;s unreliable.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg9ingo", "score_hidden": false, "stickied": false, "created": 1492222546.0, "created_utc": 1492193746.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 3}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": "", "user_reports": [], "id": "dg9in3u", "gilded": 0, "archived": false, "score": 2, "report_reasons": null, "author": "__deerlord__", "parent_id": "t1_dg9hrvv", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "Tuples are faster. You could write a dict using integer keys, and it would be referenced just like a list: my_dict[1]\n\nSo youre asking why tuples exist if you can do the same things with lists. Why do lists exist if you can do the same thing with dicts? Because they are used for different situations.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Tuples are faster. You could write a dict using integer keys, and it would be referenced just like a list: my_dict[1]&lt;/p&gt;\n\n&lt;p&gt;So youre asking why tuples exist if you can do the same things with lists. Why do lists exist if you can do the same thing with dicts? Because they are used for different situations.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg9in3u", "score_hidden": false, "stickied": false, "created": 1492222535.0, "created_utc": 1492193735.0, "depth": 2, "mod_reports": [], "subreddit_type": "public", "ups": 2}}], "after": null, "before": null}}, "user_reports": [], "id": "dg9hrvv", "gilded": 0, "archived": false, "score": -3, "report_reasons": null, "author": "eid-a", "parent_id": "t1_dg9h1a9", "subreddit_name_prefixed": "r/Python", "controversiality": 1, "body": "I know that , but why does it need 2 ? is a performance thing ?\nbecause `js` doesn't have it `ruby` doesn't have it ... ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;I know that , but why does it need 2 ? is a performance thing ?\nbecause &lt;code&gt;js&lt;/code&gt; doesn&amp;#39;t have it &lt;code&gt;ruby&lt;/code&gt; doesn&amp;#39;t have it ... &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg9hrvv", "score_hidden": false, "stickied": false, "created": 1492221507.0, "created_utc": 1492192707.0, "depth": 1, "mod_reports": [], "subreddit_type": "public", "ups": -3}}], "after": null, "before": null}}, "user_reports": [], "id": "dg9h1a9", "gilded": 0, "archived": false, "score": 3, "report_reasons": null, "author": "tunisia3507", "parent_id": "t3_65dyrr", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "Lists are mutable (you can append to them, delete from them etc.), and tuples aren't. So tuples are better for read-only variables (although if you store a mutable in a tuple that can still be changed), whereas lists are used where you need to change stuff.", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Lists are mutable (you can append to them, delete from them etc.), and tuples aren&amp;#39;t. So tuples are better for read-only variables (although if you store a mutable in a tuple that can still be changed), whereas lists are used where you need to change stuff.&lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg9h1a9", "score_hidden": false, "stickied": false, "created": 1492220650.0, "created_utc": 1492191850.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 3}}, {"kind": "t1", "data": {"subreddit_id": "t5_2qh0y", "removal_reason": null, "link_id": "t3_65dyrr", "likes": null, "replies": "", "user_reports": [], "id": "dg9nuf4", "gilded": 0, "archived": false, "score": 5, "report_reasons": null, "author": "Daenyth", "parent_id": "t3_65dyrr", "subreddit_name_prefixed": "r/Python", "controversiality": 0, "body": "There's a bit of a semantic difference too. Lists are generally used as collections of things off the same type, tuples imply a grouping of related values that might be differing types. ", "edited": false, "downs": 0, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;There&amp;#39;s a bit of a semantic difference too. Lists are generally used as collections of things off the same type, tuples imply a grouping of related values that might be differing types. &lt;/p&gt;\n&lt;/div&gt;", "subreddit": "Python", "name": "t1_dg9nuf4", "score_hidden": false, "stickied": false, "created": 1492228787.0, "created_utc": 1492199987.0, "depth": 0, "mod_reports": [], "subreddit_type": "public", "ups": 5}}], "after": null, "before": null}}]